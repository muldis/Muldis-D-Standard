Muldis_D Plain_Text 'http://muldis.com' '0.201.0.-9'
meta script 'Unicode 9.0 UTF-8'

`#########################################################################`
`#########################################################################`

(\Package : (
    identity : (
        package_base_name : [\Core],
        authority : 'http://muldis.com',
        version_number : '0.201.0.-9',
    ),
    foundation : (
        authority : 'http://muldis.com',
        version_number : '0.201.0.-9',
    ),
    floating : {\@package, \@package::Source_Code},
    materials : (

`#########################################################################`

        Any : (\Function : (
            is_type_definer : True,
            evaluates : True,
            default : False,
        )),

        None : (\Function : (
            is_type_definer : True,
            evaluates : False,
        )),

        same : (\Function : (
            returns : \@Boolean,
            matches : (\@Any, \@Any),
            is_commutative : True,
            evaluates : (args --> \foundation::same::()),
        )),

        "=" : (\Alias : ( of : \@same )),

        not_same : (\Function : (
            negates : \@same,
            is_commutative : True,
        )),

        "!=" : (\Alias : ( of : \@not_same )),

        Unicode_Aliases::"≠" : (\Alias : ( of : \@not_same )),

        is_a : (\Function : (
            returns : \@Boolean,
            matches : (\@Any, \@Signature),
            evaluates : ((args:.\0,) --> Signature_to_Function_Call_But_0::(args:.\1)),
        )),

        not_is_a : (\Function : (
            negates : \@is_a,
        )),

`#########################################################################`

        Excuse::"" : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Excuse
                and_then guard args:.\0:> is_a (
                    0 : \Any(),
                )
            ),
            default : (\Excuse : (\@Excuse::No_Reason,)),
        )),

        Excuse::No_Reason : (\Function : (
            is_type_definer : True,
            constant : (\Excuse : (\@material,)),
        )),

        coalesce : (\Function : (
            returns : \@Any,
            matches : (\@Any, \@Any),
            is_associative : True,
            is_idempotent : True,
            left_identity : (Excuse::No_Reason()),
            evaluates : (if Excuse args:.\0 then args:.\1 else args:.\0),
        )),

        "??" : (\Alias : ( of : \@coalesce )),

        anticoalesce : (\Function : (
            returns : \@Any,
            matches : (\@Any, \@Any),
            is_associative : True,
            is_idempotent : True,
            left_identity : True,
            evaluates : (if Excuse args:.\0 then args:.\0 else args:.\1),
        )),

        "!!" : (\Alias : ( of : \@anticoalesce )),

`#########################################################################`

        Orderable::"" : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        Excuse::Before_All_Others : (\Function : (
            is_type_definer : True,
            composes : {\@Orderable},
            constant : (\Excuse : (\@material,)),
        )),

        Excuse::After_All_Others : (\Function : (
            is_type_definer : True,
            composes : {\@Orderable},
            constant : (\Excuse : (\@material,)),
        )),

        in_order::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Orderable, \@Orderable),
        )),

        in_order::Before_All_Others_L : (\Function : (
            returns : \@Boolean,
            matches : (\@Excuse::Before_All_Others, \@Orderable),
            implements : \@folder::"",
            evaluates : (True),
        )),

        in_order::Before_All_Others_R : (\Function : (
            returns : \@Boolean,
            matches : (\@Orderable, \@Excuse::Before_All_Others),
            implements : \@folder::"",
            evaluates : (args:.\0 = args:.\1),
        )),

        in_order::After_All_Others_L : (\Function : (
            returns : \@Boolean,
            matches : (\@Excuse::After_All_Others, \@Orderable),
            implements : \@folder::"",
            evaluates : (args:.\0 = args:.\1),
        )),

        in_order::After_All_Others_R : (\Function : (
            returns : \@Boolean,
            matches : (\@Orderable, \@Excuse::After_All_Others),
            implements : \@folder::"",
            evaluates : (True),
        )),

        before : (\Function : (
            commutes : \@after,
        )),

        "<" : (\Alias : ( of : \@before )),

        after : (\Function : (
            negates : \@before_or_same,
        )),

        ">" : (\Alias : ( of : \@after )),

        before_or_same : (\Alias : ( of : \@in_order )),

        "<=" : (\Alias : ( of : \@before_or_same )),

        Unicode_Aliases::"≤" : (\Alias : ( of : \@before_or_same )),

        after_or_same : (\Function : (
            commutes : \@before_or_same,
        )),

        ">=" : (\Alias : ( of : \@after_or_same )),

        Unicode_Aliases::"≥" : (\Alias : ( of : \@after_or_same )),

        min : (\Function : (
            returns : \@Orderable,
            matches : (\@Orderable, \@Orderable),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : (Excuse::After_All_Others()),
            evaluates : (if args:.\0 in_order args:.\1 then args:.\0 else args:.\1),
        )),

        max : (\Function : (
            returns : \@Orderable,
            matches : (\@Orderable, \@Orderable),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : (Excuse::Before_All_Others()),
            evaluates : (if args:.\0 in_order args:.\1 then args:.\1 else args:.\0),
        )),

        minmax : (\Function : (
            returns : (\@Orderable, \@Orderable),
            matches : (\@Orderable, \@Orderable),
            is_commutative : True,
            evaluates : (if args:.\0 in_order args:.\1 then args else (args:.\1, args:.\0)),
        )),

`#########################################################################`

        Successable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        asset::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Successable),
        )),

        succ : (\Function : (
            returns : {\@Successable, \@Excuse::After_All_Others},
            matches : (\@Successable),
            evaluates : (args:.\0 nth_succ 1),
        )),

        nth_succ::"" : (\Function : (
            virtual : True,
            returns : {\@Successable, \@Excuse::After_All_Others},
            matches : (\@Successable, \@Integer::NN),
        )),

`#########################################################################`

        Bicessable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Orderable, \@Successable},
            provides_default_for : {\@Orderable, \@Successable},
        )),

        pred : (\Function : (
            returns : {\@Bicessable, \@Excuse::Before_All_Others},
            matches : (\@Bicessable),
            evaluates : (args:.\0 nth_pred 1),
        )),

        nth_pred::"" : (\Function : (
            virtual : True,
            returns : {\@Bicessable, \@Excuse::Before_All_Others},
            matches : (\@Bicessable, \@Integer::NN),
        )),

`#########################################################################`

        Boolable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        to_Boolean::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Boolable),
        )),

        so  : (\Alias : ( of : \@to_Boolean )),
        "?" : (\Alias : ( of : \@to_Boolean )),

        not_so : (\Function : (
            negates : \@to_Boolean,
        )),

        "!?" : (\Alias : ( of : \@not_so )),

`#########################################################################`

        Boolean : (\Function : (
            is_type_definer : True,
            composes : {\@Bicessable, \@Boolable},
            provides_default_for : {\@Boolable},
            evaluates : \foundation::is_a_Boolean::(),
            default : False,
        )),

        False : (\Function : (
            is_type_definer : True,
            constant : False,
        )),

        Unicode_Aliases::"⊥" : (\Alias : ( of : \@False )),

        True : (\Function : (
            is_type_definer : True,
            constant : True,
        )),

        Unicode_Aliases::"⊤" : (\Alias : ( of : \@True )),

        in_order::Boolean : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            implements : \@folder::"",
            evaluates : (!args:.\0 or args:.\1),
        )),

        asset::Boolean : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        nth_pred::Boolean : (\Function : (
            returns : {\@False, \@Excuse::Before_All_Others},
            matches : (\@Boolean, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\1 = 0 then args:.\0 else if args:.\1 = 1 and args:.\0 then False else Excuse::Before_All_Others()),
        )),

        nth_succ::Boolean : (\Function : (
            returns : {\@True, \@Excuse::After_All_Others},
            matches : (\@Boolean, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\1 = 0 then args:.\0 else if args:.\1 = 1 and !args:.\0 then True else Excuse::After_All_Others()),
        )),

        to_Boolean::Boolean : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        not : (\Function : (
            negates : \@to_Boolean::Boolean,
        )),

        "!" : (\Alias : ( of : \@not )),

        Unicode_Aliases::"¬" : (\Alias : ( of : \@not )),

        and : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : True,
            evaluates : (args:.\0 and_then args:.\1),
        )),

        Unicode_Aliases::"∧" : (\Alias : ( of : \@and )),

        nand : (\Function : (
            negates : \@and,
            is_commutative : True,
        )),

        not_and : (\Alias : ( of : \@nand )),

        Unicode_Aliases::"⊼" : (\Alias : ( of : \@nand )),
        Unicode_Aliases::"↑" : (\Alias : ( of : \@nand )),

        or : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : False,
            evaluates : (args:.\0 or_else args:.\1),
        )),

        Unicode_Aliases::"∨" : (\Alias : ( of : \@or )),

        nor : (\Function : (
            negates : \@or,
            is_commutative : True,
        )),

        not_or : (\Alias : ( of : \@nor )),

        Unicode_Aliases::"⊽" : (\Alias : ( of : \@nor )),
        Unicode_Aliases::"↓" : (\Alias : ( of : \@nor )),

        xnor : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            is_associative : True,
            is_commutative : True,
            identity : True,
            evaluates : (args:.\0 = args:.\1),
        )),

        iff : (\Alias : ( of : \@xnor )),

        Unicode_Aliases::"↔" : (\Alias : ( of : \@xnor )),

        xor : (\Function : (
            negates : \@xnor,
            is_associative : True,
            is_commutative : True,
            identity : False,
        )),

        Unicode_Aliases::"⊻" : (\Alias : ( of : \@xor )),
        Unicode_Aliases::"↮" : (\Alias : ( of : \@xor )),

        imp : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            evaluates : (if args:.\0 then args:.\1 else True),
        )),

        implies : (\Alias : ( of : \@imp )),

        Unicode_Aliases::"→" : (\Alias : ( of : \@imp )),

        nimp : (\Function : (
            negates : \@imp,
        )),

        not_implies : (\Alias : ( of : \@nimp )),

        Unicode_Aliases::"↛" : (\Alias : ( of : \@nimp )),

        if : (\Function : (
            commutes : \@imp,
        )),

        Unicode_Aliases::"←" : (\Alias : ( of : \@if )),

        nif : (\Function : (
            commutes : \@nimp,
        )),

        not_if : (\Alias : ( of : \@nif )),

        Unicode_Aliases::"↚" : (\Alias : ( of : \@nif )),

`#########################################################################`

        Round_Meth::"" : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \folder::Attr_Name(),
                )
            ),
            default : (\@material : (\To_Zero,)),
        )),

        Round_Meth::Attr_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Attr_Name::(), \"⊆@"::( 1:
                \@(Down,Up,To_Zero,To_Inf
                ,Half_Down,Half_Up,Half_To_Zero,Half_To_Inf
                ,Half_Even,Half_Odd)
            )],
            default : \To_Zero,
        )),

        RM : (\Function : (
            returns : \@Round_Meth,
            matches : (\@Round_Meth::Attr_Name),
            evaluates : ((\@Round_Meth : (args:.\0,))),
        )),

`#########################################################################`

        Numerical : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Boolable},
        )),

        Excuse::Div_By_Zero : (\Function : (
            is_type_definer : True,
            constant : (\Excuse : (\@material,)),
        )),

        Excuse::Zero_To_The_Zero : (\Function : (
            is_type_definer : True,
            constant : (\Excuse : (\@material,)),
        )),

        to_Boolean::Numerical : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Numerical),
            implements : \@folder::"",
        )),

        is_zero : (\Function : (
            negates : \@to_Boolean::Numerical,
        )),

        zero::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical),
        )),

        opposite::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical),
        )),

        additive_inverse : (\Alias : ( of : \@opposite )),

        reciprocal::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical),
        )),

        multiplicative_inverse : (\Alias : ( of : \@reciprocal )),

        modulus::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical),
        )),

        abs : (\Alias : ( of : \@modulus )),

        plus::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
            is_associative : True,
            is_commutative : True,
            repeater : \@times,
        )),

        "+" : (\Alias : ( of : \@plus )),

        minus::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
        )),

        "-" : (\Function : (
            returns : \@Numerical,
            matches : {(\@Numerical), (\@Numerical, \@Numerical)},
            evaluates : (args --> (if degree::(args) = 1 then \opposite::() else \minus::())),
        )),

        Unicode_Aliases::"−" : (\Alias : ( of : "-" )),

        modulus_minus : (\Function : (
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
            is_commutative : True,
            evaluates : (modulus args:.\0 - args:.\1),
        )),

        abs_minus : (\Alias : ( of : \@modulus_minus )),
        "|-|"     : (\Alias : ( of : \@modulus_minus )),

        Unicode_Aliases::"|−|" : (\Alias : ( of : \@modulus_minus )),

        times::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
            is_associative : True,
            is_commutative : True,
            repeater : \@integral_nn_power,
        )),

        "*" : (\Alias : ( of : \@times )),

        Unicode_Aliases::"×" : (\Alias : ( of : \@times )),

        multiple_of::"" : (\Function : (
            virtual : True,
            returns : {\@Boolean, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical),
        )),

        nearest_multiple_of : (\Function : (
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
            evaluates : (if is_zero args:.\1 then Excuse::Div_By_Zero()
                else guard args:.\1 * (args:.\0 div args:.\1)),
        )),

        round : (\Alias : ( of : \@nearest_multiple_of )),

        fractional_divided_by::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical),
        )),

        "/" : (\Alias : ( of : \@fractional_divided_by )),

        Unicode_Aliases::"÷" : (\Alias : ( of : \@fractional_divided_by )),
        Unicode_Aliases::"∕" : (\Alias : ( of : \@fractional_divided_by )),

        integral_divided_by::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
        )),

        div : (\Alias : ( of : \@integral_divided_by )),

        modulo : (\Function : (
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
            evaluates : (if is_zero args:.\1 then Excuse::Div_By_Zero()
                else guard args:.\0 - (args:.\0 nearest_multiple_of args:.\1)),
        )),

        mod : (\Alias : ( of : \@modulo )),

        divided_by_and_modulo::"" : (\Function : (
            returns : ({Numerical, Excuse::Div_By_Zero}, {Numerical, Excuse::Div_By_Zero}),
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
            evaluates : ((args:.\0 div args:.\1, args:.\0 mod args:.\1)),
        )),

        integral_power::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Zero_To_The_Zero},
            matches : (\@Numerical, \@Integral),
        )),

        "**" : (\Alias : ( of : \@integral_power )),

        integral_nn_power::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Zero_To_The_Zero},
            matches : (\@Numerical, \@Integral::NN),
        )),

        power : (\Alias : ( of : \@integral_nn_power )),

`#########################################################################`

        Integral::"" : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Bicessable, \@Numerical},
            provides_default_for : {\@Bicessable, \@Numerical},
        )),

        Integral::NN : (\Function : (
            is_type_definer : True,
            evaluates : (Integral args:.\0 and_then guard
                args:.\0 >= zero::(args:.\0)),
        )),

        Integral::P : (\Function : (
            is_type_definer : True,
            evaluates : (Integral::NN::(args:.\0) and_then guard
                args:.\0 > zero::(args:.\0)),
            default : (succ::(Integral::())),
        )),

        "--" : (\Function : (
            returns : {\@Integral, \@Excuse::Before_All_Others},
            matches : (\@Integral),
            evaluates : (pred args:.\0),
        )),

        "++" : (\Function : (
            returns : {\@Integral, \@Excuse::After_All_Others},
            matches : (\@Integral),
            evaluates : (succ args:.\0),
        )),

        to_Integer::"" : (\Function : (
            virtual : True,
            returns : \@Integer,
            matches : (\@Integral),
        )),

        factorial::"" : (\Function : (
            virtual : True,
            returns : \@Integral::P,
            matches : (\@Integral::NN),
        )),

        gcd : (\Function : (
            returns : \@Integral::P,
            matches : (\@Integral::NN, \@Integral::NN),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : ((if is_zero args:.\1 then args:.\0 else guard material::(args:.\1, mod::(args:.\0, args:.\1, RM::(\To_Zero))))
                note 'Calculate using the Euclidean algorithm.'),
        )),

        greatest_common_divisor : (\Alias : ( of : \@gcd )),

        lcm : (\Function : (
            returns : \@Integral::NN,
            matches : (\@Integral::NN, \@Integral::NN),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : (if is_zero args:.\0 or is_zero args:.\1 then zero args:.\0
                else guard div::(args:.\0 * args:.\1, args:.\0 gcd args:.\1, RM::(\To_Zero))),
        )),

        least_common_multiple : (\Alias : ( of : \@lcm )),

        coprime : (\Function : (
            returns : \@Boolean,
            matches : (\@Integral, \@Integral),
            evaluates : ((abs::(args:.\0) gcd abs::(args:.\1)) = succ::(zero args:.\0)),
        )),

`#########################################################################`

        Integer::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Integral},
            provides_default_for : {\@Integral},
            evaluates : \foundation::is_a_Integer::(),
            default : 0,
        )),

        Integer::NN : (\Function : (
            is_type_definer : True,
            evaluates : [\Integer::(), \">="::( 1: 0 )],
        )),

        Integer::P : (\Function : (
            is_type_definer : True,
            evaluates : [\Integer::NN(), \">"::( 1: 0 )],
            default : 1,
        )),

        in_order::Integer : (\Function : (
            returns : \@Boolean,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Integer_in_order::()),
        )),

        asset::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        nth_pred::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer::NN),
            implements : \@folder::Integral,
            evaluates : (args:.\0 - args:.\1),
        )),

        nth_succ::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer::NN),
            implements : \@folder::Integral,
            repeater : \@plus::Integer,
            evaluates : (args:.\0 + args:.\1),
        )),

        to_Boolean::Integer : (\Function : (
            returns : \@Boolean,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : (args:.\0 != 0),
        )),

        zero::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : (0),
        )),

        opposite::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Integer_opposite::()),
        )),

        reciprocal::Integer : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : (1 / args:.\0),
        )),

        modulus::Integer : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Integer_modulus::()),
        )),

        plus::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 0,
            repeater : \@times::Integer,
            evaluates : (args --> \foundation::Integer_plus::()),
        )),

        minus::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            right_identity : 0,
            evaluates : (args --> \foundation::Integer_minus::()),
        )),

        times::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 1,
            repeater : \@integral_nn_power::Integer,
            evaluates : (args --> \foundation::Integer_times::()),
        )),

        multiple_of::Integer : (\Function : (
            returns : {\@Boolean, \@Excuse::Div_By_Zero},
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : (if args:.\1 = 0 then Excuse::Div_By_Zero()
                else guard args --> \foundation::Integer_multiple_of::()),
        )),

        fractional_divided_by::Integer : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            right_identity : 1,
            evaluates : (
                n ::= args:.\0;
                d ::= args:.\1;

                returns if d = 0 then Excuse::Div_By_Zero() else guard q;

                q ::= (\Fraction : (
                    numerator   : div::((if d > 0 then n else -n), gcd, RM::(\To_Zero)),
                    denominator : div::((if d > 0 then d else -d), gcd, RM::(\To_Zero)),
                ));

                gcd ::= gcd::(abs::(n), abs::(d));
            ),
        )),

        integral_divided_by::Integer : (\Function : (
            returns : {\@Integer, \@Excuse::Div_By_Zero},
            matches : (\@Integer, \@Integer, \@Round_Meth),
            implements : \@folder::"",
            right_identity : 1,
            evaluates : (
                dividend   ::= args:.\0;
                divisor    ::= args:.\1;
                round_meth ::= args:.\2;

                returns if divisor = 0 then Excuse::Div_By_Zero() else guard e1;

                e1 note 'This is the case where we are dividing by a non-zero.';

                e1 ::=   if dividend = 0       then 0
                    else if divisor  = 1       then dividend
                    else if dividend = divisor then 1
                    else if divisor  = -1      then -dividend
                    else                            e2
                ;

                e2 note 'This is the case where the divisor and dividend do not'
                    ' equal each other and neither of them is a zero or a one.';

                e2 ::= (
                    real_q_is_neg ::= dividend < 0 xor divisor < 0;
                    rtz_quotient  ::= \foundation::Integer_divided_by_rtz::()
                        <-- (dividend, divisor);
                    rtz_remainder ::= dividend - (divisor * rtz_quotient);

                    returns if rtz_remainder = 0 then rtz_quotient else e3;
                );

                e3 note 'This is the case where the divisor does not divide the'
                    ' dividend evenly and the real number division result would'
                    ' have a fractional part, so we decide how to round that.';

                e3 ::= (
                    rti_quotient ::= rtz_quotient + (if real_q_is_neg then -1 else 1);
                    rdn_quotient ::= rtz_quotient + (if real_q_is_neg then -1 else 0);
                    rup_quotient ::= rtz_quotient + (if real_q_is_neg then  0 else 1);

                    returns given round_meth
                        when RM::(\Down)    then rdn_quotient
                        when RM::(\Up)      then rup_quotient
                        when RM::(\To_Zero) then rtz_quotient
                        when RM::(\To_Inf)  then rti_quotient
                        default
                                 if (2 * abs::(rtz_remainder)) < abs::(divisor) then rtz_quotient
                            else if (2 * abs::(rtz_remainder)) > abs::(divisor) then rti_quotient
                            else e4
                    ;
                );

                e4 note 'This is the case where real division remainder is'
                    ' exactly one-half so we decide how to round that.';

                e4 ::= (
                    q ::= \foundation::Integer_divided_by_rtz::() <-- (abs::(rtz_quotient),2)
                    r ::= abs::(rtz_quotient) - (2 * q);
                    rtz_quotient_is_even ::= r = 0;

                    returns given round_meth
                        when RM::(\Half_Down)    then rdn_quotient
                        when RM::(\Half_Up)      then rup_quotient
                        when RM::(\Half_To_Zero) then rtz_quotient
                        when RM::(\Half_To_Inf)  then rti_quotient
                        when RM::(\Half_Even)    then
                            (if rtz_quotient_is_even then rtz_quotient else rti_quotient)
                        when RM::(\Half_Odd)     then
                            (if rtz_quotient_is_even then rti_quotient else rtz_quotient)
                        default fail  `oops, an unhandled case`
                    ;
                );
            ),
        )),

        integral_power::Integer : (\Function : (
            returns : {\@Fraction, \@Excuse::Zero_To_The_Zero},
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : (if args:.\0 = 0 and args:.\1 = 0 then Excuse::Zero_To_The_Zero()
                else guard args:.\0 / 1 ** args:.\1),
        )),

        integral_nn_power::Integer : (\Function : (
            returns : {\@Integer, \@Excuse::Zero_To_The_Zero},
            matches : (\@Integer, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\0 = 0 and args:.\1 = 0 then Excuse::Zero_To_The_Zero()
                else guard args --> \foundation::Integer_nn_power::()),
        )),

        to_Integer::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        factorial::Integer : (\Function : (
            returns : \@Integer::P,
            matches : (\@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Integer_factorial::()),
        )),

`#########################################################################`

        Fractional::"" : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Orderable, \@Numerical},
        )),

        Fractional::NN : (\Function : (
            is_type_definer : True,
            evaluates : (Fractional args:.\0 and_then guard
                args:.\0 >= zero::(args:.\0)),
        )),

        to_Fraction::"" : (\Function : (
            virtual : True,
            returns : \@Fraction,
            matches : (\@Fractional),
        )),

        numerator::"" : (\Function : (
            virtual : True,
            returns : \@Integral,
            matches : (\@Fractional),
        )),

        denominator::"" : (\Function : (
            virtual : True,
            returns : \@Integral::P,
            matches : (\@Fractional),
        )),

`#########################################################################`

        Fraction::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Fractional},
            provides_default_for : {\@Fractional},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Fraction
                and_then guard
                    args:.\0:> is_a (
                        numerator : \Integer::(),
                        denominator : \Integer::P(),
                    )
                and_then guard
                    args:.\0:>.\numerator coprime args:.\0:>.\denominator
            ),
            default : 0.0,
        )),

        Fraction::NN : (\Function : (
            is_type_definer : True,
            evaluates : [\Fraction::(), \">="::( 1: 0.0 )],
        )),

        in_order::Fraction : (\Function : (
            returns : \@Boolean,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            evaluates : (
                <-- if(denominator args:.\0) = (denominator args:.\1)
                    then in_order::(numerator args:.\0, numerator args:.\1)
                 else
                  (
                    common_d ::= lcm::(denominator args:.\0, denominator args:.\1);
                    returns in_order::(
                        (numerator args:.\0) * div::(common_d, denominator args:.\0, RM::(\To_Zero)),
                        (numerator args:.\1) * div::(common_d, denominator args:.\1, RM::(\To_Zero)),
                    );
                  )
            ),
        )),

        to_Boolean::Fraction : (\Function : (
            returns : \@Boolean,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : (args:.\0 != 0.0),
        )),

        zero::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : (0.0),
        )),

        opposite::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : (-(numerator args:.\0) / (denominator args:.\0)),
        )),

        reciprocal::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : (if args:.\0 = 0.0 then Excuse::Div_By_Zero()
                else guard (denominator args:.\0) / (numerator args:.\0)),
        )),

        modulus::Fraction : (\Function : (
            returns : \@Fraction::NN,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : (abs::(numerator args:.\0) / (denominator args:.\0)),
        )),

        plus::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 0.0,
            repeater : \@times::Fraction_Integer,
            evaluates : (
                <-- if (denominator args:.\0) = (denominator args:.\1)
                    then (numerator args:.\0) + (numerator args:.\1) / (denominator args:.\0)
                 else
                  (
                    common_d ::= lcm::(denominator args:.\0, denominator args:.\1);
                    returns ((numerator args:.\0) * div::(common_d, denominator args:.\0, RM::(\To_Zero)))
                        + ((numerator args:.\1) * div::(common_d, denominator args:.\1, RM::(\To_Zero)))
                        / common_d;
                  )
            ),
        )),

        minus::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            right_identity : 0.0,
            evaluates : (args:.\0 + -args:.\1),
        )),

        times::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 1.0,
            repeater : \@integral_nn_power::Fraction,
            evaluates : (((numerator args:.\0) * (numerator args:.\1))
                / ((denominator args:.\0) * (denominator args:.\1))),
        )),

        times::Fraction_Integer : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Integer),
            implements : \@folder::"",
            evaluates : (((numerator args:.\0) * args:.\1) / (denominator args:.\0)),
        )),

        multiple_of::Fraction : (\Function : (
            returns : {\@Boolean, \@Excuse::Div_By_Zero},
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            evaluates : (if args:.\1 = 0.0 then Excuse::Div_By_Zero()
                else guard (args:.\0 mod args:.\1) = 0.0),
        )),

        fractional_divided_by::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            right_identity : 1.0,
            evaluates : (if args:.\1 = 0.0 then Excuse::Div_By_Zero()
                else guard args:.\0 * reciprocal::(args:.\1)),
        )),

        integral_divided_by::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Fraction, \@Fraction, \@Round_Meth),
            implements : \@folder::"",
            right_identity : 1.0,
            evaluates : (
                d ::= lcm::(denominator args:.\0, denominator args:.\1);
                n0 ::= (numerator args:.\0) * div::(d, denominator args:.\0, RM::(\To_Zero));
                n1 ::= (numerator args:.\1) * div::(d, denominator args:.\1, RM::(\To_Zero));
                returns if args:.\1 = 0.0 then Excuse::Div_By_Zero()
                    else guard div::(n0 * d, n1 * d, args:.\2) / 1;
            ),
        )),

        integral_power::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Zero_To_The_Zero},
            matches : (\@Fraction, \@Integer),
            implements : \@folder::"",
            evaluates : (\integral_nn_power::()
                <-- (if args:.\1 >= 0 then args else (reciprocal::(args:.\0), -args:.\1))),
        )),

        integral_nn_power::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Zero_To_The_Zero},
            matches : (\@Fraction, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\0 = 0.0 and args:.\1 = 0 then Excuse::Zero_To_The_Zero()
                else guard ((numerator args:.\0) ** args:.\1) / ((denominator args:.\0) ** args:.\1)),
        )),

        to_Fraction::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        numerator::Fraction : (\Function : (
            returns : \@Integer,
            matches : (\@Fraction),
            evaluates : (args:.\0:>.\numerator),
        )),

        denominator::Fraction : (\Function : (
            returns : \@Integer::P,
            matches : (\@Fraction),
            evaluates : (args:.\0:>.\denominator),
        )),

`#########################################################################`

        Emptyable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Boolable},
        )),

        Excuse::No_Empty_Value : (\Function : (
            is_type_definer : True,
            constant : (\Excuse : (\@material,)),
        )),

        to_Boolean::Emptyable : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Emptyable),
            implements : \@folder::"",
        )),

        has_any_members : (\Alias : ( of : \@to_Boolean::Emptyable )),

        is_empty : (\Function : (
            negates : \@to_Boolean::Emptyable,
        )),

        Unicode_Aliases::"∅?" : (\Alias : ( of : \@is_empty )),

        empty::"" : (\Function : (
            virtual : True,
            returns : {\@Emptyable, \@Excuse::No_Empty_Value},
            matches : (\@Emptyable),
        )),

        Unicode_Aliases::"∅" : (\Alias : ( of : \@empty )),

`#########################################################################`

        Stringy : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Orderable, \@Emptyable},
            provides_default_for : {\@Emptyable},
        )),

        substring_of::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Stringy, \@Stringy),
        )),

        superstring_of : (\Function : (
            commutes : \@substring_of,
        )),

        proper_substring_or_superstring : (\Function : (
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
            evaluates : (args:.\0 != args:.\1 and (args:.\0 substring_or_superstring args:.\1)),
        )),

        substring_or_superstring : (\Function : (
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
            evaluates : ((args:.\0 substring_of args:.\1) or (args:.\0 superstring_of args:.\1)),
        )),

        overlaps_string::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
        )),

        disjoint_string::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
        )),

        catenate::"" : (\Function : (
            virtual : True,
            returns : \@Stringy,
            matches : (\@Stringy, \@Stringy),
            is_associative : True,
            repeater : \@replicate,
        )),

        "~" : (\Alias : ( of : \@catenate )),

        replicate::"" : (\Function : (
            virtual : True,
            returns : \@Stringy,
            matches : (\@Stringy, \@Integer::NN),
        )),

        "~#" : (\Alias : ( of : \@replicate )),

`#########################################################################`

        Bits : (\Function : (
            is_type_definer : True,
            composes : {\@Stringy},
            provides_default_for : {\@Stringy},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Bits
                and_then guard args:.\0:> is_a (
                    bits : \String::Bits(),
                )
            ),
            default : \~?'',
        )),

        String::Bits : (\Function : (
            is_type_definer : True,
            evaluates : [\String::(), \all::( 1: \in::( 1: 0..1 ) )],
        )),

        in_order::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            evaluates : ((Bits_to_String_Bits args:.\0) in_order (Bits_to_String_Bits args:.\1)),
        )),

        to_Boolean::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits),
            implements : \@folder::"",
            evaluates : (args:.\0 != \~?''),
        )),

        empty::Bits : (\Function : (
            returns : \@Bits,
            matches : (\@Bits),
            implements : \@folder::"",
            evaluates : (\~?''),
        )),

        substring_of::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            evaluates : ((Bits_to_String_Bits args:.\0) substring_of (Bits_to_String_Bits args:.\1)),
        )),

        overlaps_string::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((Bits_to_String_Bits args:.\0)
                overlaps_string (Bits_to_String_Bits args:.\1)),
        )),

        disjoint_string::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((Bits_to_String_Bits args:.\0)
                disjoint_string (Bits_to_String_Bits args:.\1)),
        )),

        catenate::Bits : (\Function : (
            returns : \@Bits,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            is_associative : True,
            identity : \~?'',
            repeater : \@replicate::Bits,
            evaluates : (Bits_from_String_Bits::((Bits_to_String_Bits args:.\0)
                ~ (Bits_to_String_Bits args:.\1))),
        )),

        replicate::Bits : (\Function : (
            returns : \@Bits,
            matches : (\@Bits, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (Bits_from_String_Bits::((Bits_to_String_Bits args:.\0) ~# args:.\1)),
        )),

        Bits_from_String_Bits : (\Function : (
            returns : \@Bits,
            matches : (\@String::Bits),
            evaluates : ((\Bits : (bits : args:.\0,))),
        )),

        Bits_to_String_Bits : (\Function : (
            returns : \@String::Bits,
            matches : (\@Bits),
            evaluates : (args:.\0:>.\bits),
        )),

`#########################################################################`

        Blob : (\Function : (
            is_type_definer : True,
            composes : {\@Stringy},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Blob
                and_then guard args:.\0:> is_a (
                    octets : \String::Octets(),
                )
            ),
            default : \~+'',
        )),

        String::Octets : (\Function : (
            is_type_definer : True,
            evaluates : [\String::(), \all::( 1: \in::( 1: 0..255 ) )],
        )),

        in_order::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            evaluates : ((Blob_to_Octets args:.\0) in_order (Blob_to_Octets args:.\1)),
        )),

        to_Boolean::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob),
            implements : \@folder::"",
            evaluates : (args:.\0 != \~+''),
        )),

        empty::Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Blob),
            implements : \@folder::"",
            evaluates : (\~+''),
        )),

        substring_of::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            evaluates : ((Blob_to_Octets args:.\0) substring_of (Blob_to_Octets args:.\1)),
        )),

        overlaps_string::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((Blob_to_Octets args:.\0) overlaps_string (Blob_to_Octets args:.\1)),
        )),

        disjoint_string::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((Blob_to_Octets args:.\0) disjoint_string (Blob_to_Octets args:.\1)),
        )),

        catenate::Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            is_associative : True,
            identity : \~+'',
            repeater : \@replicate::Blob,
            evaluates : (Blob_from_Octets::((Blob_to_Octets args:.\0) ~ (Blob_to_Octets args:.\1))),
        )),

        replicate::Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Blob, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (Blob_from_Octets::((Blob_to_Octets args:.\0) ~# args:.\1)),
        )),

        Blob_from_Octets : (\Function : (
            returns : \@Blob,
            matches : (\@String::Octets),
            evaluates : ((\Blob : (octets : args:.\0,))),
        )),

        Blob_to_Octets : (\Function : (
            returns : \@String::Octets,
            matches : (\@Blob),
            evaluates : (args:.\0:>.\octets),
        )),

`#########################################################################`

        Textual : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Stringy},
        )),

        to_Text::"" : (\Function : (
            virtual : True,
            returns : \@Text,
            matches : (\@Textual),
        )),

`#########################################################################`

        Text::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Textual},
            provides_default_for : {\@Textual},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Text
                and_then guard args:.\0:> is_a (
                    maximal_chars : \String::Maximal_Chars(),
                )
            ),
            default : '',
        )),

        String::Maximal_Chars : (\Alias : ( of : \@String )),

        Text::Unicode : (\Function : (
            is_type_definer : True,
            evaluates : (Text args:.\0 and_then guard
                String::Unicode_Codes::(Text_from_Maximal_Chars args:.\0)),
        )),

        String::Unicode_Codes : (\Function : (
            is_type_definer : True,
            evaluates : [\String::Maximal_Chars(),
                \all::( 1: \in::( 1: ?..{0..0xD7FF,0xE000..0x10FFFF} ) )],
        )),

        Text::ASCII : (\Function : (
            is_type_definer : True,
            evaluates : (Text::Unicode::(args:.\0) and_then guard
                String::ASCII_Chars::(Text_from_Unicode_Codes args:.\0)),
        )),

        String::ASCII_Chars : (\Function : (
            is_type_definer : True,
            evaluates : [\String::Unicode_Codes(), \all::( 1: \in::( 1: 0..127 ) )],
        )),

        in_order::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            evaluates : ((Text_to_Maximal_Chars args:.\0) in_order (Text_to_Maximal_Chars args:.\1)),
        )),

        to_Boolean::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text),
            implements : \@folder::"",
            evaluates : (args:.\0 != ''),
        )),

        empty::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text),
            implements : \@folder::"",
            evaluates : (''),
        )),

        substring_of::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            evaluates : ((Text_to_Maximal_Chars args:.\0)
                substring_of (Text_to_Maximal_Chars args:.\1)),
        )),

        overlaps_string::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((Text_to_Maximal_Chars args:.\0)
                overlaps_string (Text_to_Maximal_Chars args:.\1)),
        )),

        disjoint_string::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((Text_to_Maximal_Chars args:.\0)
                disjoint_string (Text_to_Maximal_Chars args:.\1)),
        )),

        catenate::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            is_associative : True,
            identity : '',
            repeater : \@replicate::Text,
            evaluates : (Text_from_Maximal_Chars::((Text_to_Maximal_Chars args:.\0)
                ~ (Text_to_Maximal_Chars args:.\1))),
        )),

        replicate::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (Text_from_Maximal_Chars::((Text_to_Maximal_Chars args:.\0) ~# args:.\1)),
        )),

        to_Text::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        Text_from_Maximal_Chars : (\Function : (
            returns : \@Text,
            matches : (\@String::Maximal_Chars),
            evaluates : ((\Text : (maximal_chars : args:.\0,))),
        )),

        Text_to_Maximal_Chars : (\Function : (
            returns : \@String::Maximal_Chars,
            matches : (\@Text),
            evaluates : (args:.\0:>.\maximal_chars),
        )),

        Text_from_Unicode_Codes : (\Function : (
            returns : \@Text::Unicode,
            matches : (\@String::Unicode_Codes),
            evaluates : (Text_from_Maximal_Chars args:.\0),
        )),

        Text_to_Unicode_Codes : (\Function : (
            returns : \@String::Unicode_Codes,
            matches : (\@Text::Unicode),
            evaluates : (Text_to_Maximal_Chars args:.\0),
        )),

        Text_from_ASCII_Chars : (\Function : (
            returns : \@Text::ASCII,
            matches : (\@String::ASCII_Chars),
            evaluates : (Text_from_Unicode_Codes args:.\0),
        )),

        Text_to_ASCII_Chars : (\Function : (
            returns : \@String::ASCII_Chars,
            matches : (\@Text::ASCII),
            evaluates : (Text_to_Unicode_Codes args:.\0),
        )),

        Blob_is_UTF_8 : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob),
            evaluates : (...),
        )),

        Text_from_UTF_8_Blob : (\Function : (
            returns : {\@Text::Unicode, \@Excuse::Unicode::..., ...},
            matches : (\@Blob),
            evaluates : (...),
        )),

        Text_from_UTF_8_Blob_with_repl_Text : (\Function : (
            returns : \@Text::Unicode,
            matches : (\@Blob, \@Text::Unicode),
            evaluates : (...),
        )),

        Text_from_UTF_8_Blob_with_repl_char : (\Function : (
            returns : \@Text::Unicode,
            matches : (\@Blob),
            evaluates : (Text_from_UTF_8_Blob_with_repl_Text::(args:.\0,'\\c<0xFFFD>')),
        )),

        Text_to_UTF_8_Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Text::Unicode),
            evaluates : (...),
        )),

        Blob_is_ASCII : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob),
            evaluates : (String::ASCII_Chars(Blob_to_Octets args:.\0)),
        )),

        Text_from_ASCII_Blob : (\Function : (
            returns : {\@Text::ASCII, \@Excuse::ASCII::High_Bit_Not_Zero},
            matches : (\@Blob),
            evaluates : (
                octets ::= Blob_to_Octets args:.\0;
                returns if String::ASCII_Chars(octets)
                    then guard Text_from_ASCII_Chars octets
                    else Excuse::ASCII::High_Bit_Not_Zero();
            ),
        )),

        Text_from_ASCII_Blob_with_repl_Text : (\Function : (
            returns : \@Text::ASCII,
            matches : (\@Blob, \@Text::ASCII),
            evaluates : (
                src_octets ::= Blob_to_Octets args:.\0;
                repl_chars ::= Text_to_ASCII_Chars args:.\1;
                result_chars ::=
                    given #repl_chars
                        when 0 then
                            src_octets where \in::( 1: 0..127 )
                        when 1 then guard
                            src_octets
                                map \(if args:.\0 in 0..127 then args:.\0 else args:.\1)
                                    \<-- (1 : repl_chars.0,)
                        default
                            src_octets
                                map \(if args:.\0 in 0..127 then [args:.\0] else args:.\1)
                                    \<-- (1 : repl_chars,)
                                reduce \catenate::()
                    ;
                returns Text_from_ASCII_Chars result_chars;
            ),
        )),

        Text_to_ASCII_Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Text::ASCII),
            evaluates : (Blob_from_Octets::(Text_to_ASCII_Chars args:.\0)),
        )),

`#########################################################################`

        Accessible : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        has_any_at::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Accessible, \@Any),
        )),

        ".?" : (\Alias : ( of : \@has_any_at )),

        not_has_any_at : (\Function : (
            negates : \@has_any_at,
        )),

        ".!?" : (\Alias : ( of : \@not_has_any_at )),

        has_mapping_at::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (Accessible, (Any, Any)),
        )),

        ".:?" : (\Alias : ( of : \@has_mapping_at )),

        mapping_at::"" : (\Function : (
            virtual : True,
            returns : (\@Any, \@Any),
            matches : (\@Accessible, \@Any),
            accepts : (args:.\0 .? args:.\1),
        )),

        ".:" : (\Alias : ( of : \@mapping_at )),

        at::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Accessible, \@Any),
            accepts : (args:.\0 .? args:.\1),
        )),

        "." : (\Alias : ( of : \@at )),

        maybe_at::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Accessible, \@Any),
        )),

        ".!" : (\Alias : ( of : \@maybe_at )),

        replace_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (Accessible, (Any, Any)),
            accepts : (args:.\0 .? (args:.\1.\0)),
        )),

        ".:=" : (\Alias : ( of : \@replace_at )),

        shiftless_insert_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (Accessible, (Any, Any)),
            accepts : (not args:.\0 .? (args:.\1.\0)),
        )),

        ".+" : (\Alias : ( of : \@shiftless_insert_at )),

        shiftless_remove_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (\@Accessible, \@Any),
            accepts : (args:.\0 .? args:.\1),
        )),

        ".-" : (\Alias : ( of : \@shiftless_remove_at )),

        replace_or_insert_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (Accessible, (Any, Any)),
        )),

        ".=+" : (\Alias : ( of : \@replace_or_insert_at )),

        shiftless_maybe_remove_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (\@Accessible, \@Any),
        )),

        ".?-" : (\Alias : ( of : \@shiftless_maybe_remove_at )),

`#########################################################################`

        Homogeneous : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Emptyable},
        )),

        singular::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous),
        )),

        only_member::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Homogeneous),
            accepts : (singular args:.\0),
        )),

        in : (\Function : (
            commutes : \@has,
        )),

        Unicode_Aliases::"∈" : (\Alias : ( of : \@in )),

        not_in : (\Function : (
            commutes : \@not_has,
        )),

        Unicode_Aliases::"∉" : (\Alias : ( of : \@not_in )),

        has : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Any),
            evaluates : (has_n::(args:.\0, args:.\1, 1)),
        )),

        Unicode_Aliases::"∋" : (\Alias : ( of : \@has )),

        not_has : (\Function : (
            negates : \@has,
        )),

        Unicode_Aliases::"∌" : (\Alias : ( of : \@not_has )),

        has_n::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Any, \@Integer::NN),
        )),

        multiplicity::"" : (\Function : (
            virtual : True,
            returns : \@Integer::NN,
            matches : (\@Homogeneous, \@Any),
        )),

        all_unique::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous),
        )),

        unique::"" : (\Function : (
            virtual : True,
            returns : \@Homogeneous,
            matches : (\@Homogeneous),
        )),

        proper_subset_of : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            evaluates : (args:.\0 != args:.\1 and (args:.\0 subset_of args:.\1)),
        )),

        Unicode_Aliases::"⊂" : (\Alias : ( of : \@proper_subset_of )),

        not_proper_subset_of : (\Function : (
            negates : \@proper_subset_of,
        )),

        Unicode_Aliases::"⊄" : (\Alias : ( of : \@not_proper_subset_of )),

        proper_superset_of : (\Function : (
            commutes : \@proper_subset_of,
        )),

        Unicode_Aliases::"⊃" : (\Alias : ( of : \@proper_superset_of )),

        not_proper_superset_of : (\Function : (
            negates : \@proper_superset_of,
        )),

        Unicode_Aliases::"⊅" : (\Alias : ( of : \@not_proper_superset_of )),

        subset_of::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
        )),

        Unicode_Aliases::"⊆" : (\Alias : ( of : \@subset_of )),

        not_subset_of : (\Function : (
            negates : \@subset_of,
        )),

        Unicode_Aliases::"⊈" : (\Alias : ( of : \@not_subset_of )),

        superset_of : (\Function : (
            commutes : \@subset_of,
        )),

        Unicode_Aliases::"⊇" : (\Alias : ( of : \@superset_of )),

        not_superset_of : (\Function : (
            negates : \@superset_of,
        )),

        Unicode_Aliases::"⊉" : (\Alias : ( of : \@not_superset_of )),

        same_members::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
        )),

        proper_subset_or_superset : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
            evaluates : (not (args:.\0 same_members args:.\1) and (args:.\0 subset_or_superset args:.\1)),
        )),

        subset_or_superset : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
            evaluates : ((args:.\0 subset_of args:.\1) or (args:.\0 superset_of args:.\1)),
        )),

        overlaps_members::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
        )),

        disjoint_members::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
        )),

        any::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Signature),
        )),

        there_exists : (\Alias : ( of : \@any )),

        Unicode_Aliases::"∃" : (\Alias : ( of : \@any )),

        none : (\Function : (
            negates : \@any,
        )),

        there_does_not_exist : (\Alias : ( of : \@none )),

        Unicode_Aliases::"∄" : (\Alias : ( of : \@none )),

        all : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Signature),
            evaluates : (args:.\0 none \not_is_a::( 1: args:.\1 )),
        )),

        for_all : (\Alias : ( of : \@all )),

        Unicode_Aliases::"∀" : (\Alias : ( of : \@all )),

        not_all : (\Function : (
            negates : \@all,
        )),

`#########################################################################`

        Unionable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Homogeneous},
        )),

        insert : (\Function : (
            returns : \@Unionable,
            matches : (\@Unionable, \@Any),
            evaluates : (insert_n::(args:.\0, args:.\1, 1)),
        )),

        insert_n::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Any, \@Integer::NN),
        )),

        remove : (\Function : (
            returns : \@Unionable,
            matches : (\@Unionable, \@Any),
            evaluates : (remove_n::(args:.\0, args:.\1, 1)),
        )),

        remove_n::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Any, \@Integer::NN),
        )),

        member_plus::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
            is_associative : True,
        )),

        Unicode_Aliases::"⊎" : (\Alias : ( of : \@member_plus )),

        except::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
        )),

        Unicode_Aliases::"∖" : (\Alias : ( of : \@except )),

        intersect::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
            is_associative : True,
            is_idempotent : True,
        )),

        Unicode_Aliases::"∩" : (\Alias : ( of : \@intersect )),

        union::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
            is_idempotent : True,
        )),

        Unicode_Aliases::"∪" : (\Alias : ( of : \@union )),

        exclusive::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
        )),

        symm_diff : (\Alias : ( of : \@exclusive )),

        Unicode_Aliases::"∆" : (\Alias : ( of : \@exclusive )),

        nest::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable),
            accepts : (...),
        )),

        group : (\Alias : ( of : \@nest )),

        unnest::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable),
            accepts : (...),
        )),

        ungroup : (\Alias : ( of : \@unnest )),

        where::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Signature),
        )),

        Unicode_Aliases::"σ" : (\Alias : ( of : \@where )),

        filtering : (\Function : (
            commutes : \@where,
        )),

        map::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Function_Call_But_0),
        )),

        reduce::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Unionable, \@Function_Call_But_0_1),
        )),

`#########################################################################`

        Discrete : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Unionable},
            provides_default_for : {\@Unionable},
        )),

        to_Set::"" : (\Function : (
            virtual : True,
            returns : \@Set,
            matches : (\@Discrete),
        )),

        "?|" : (\Alias : ( of : \@to_Set )),

        to_Bag::"" : (\Function : (
            virtual : True,
            returns : \@Bag,
            matches : (\@Discrete),
        )),

        "+|" : (\Alias : ( of : \@to_Bag )),

        count::"" : (\Function : (
            virtual : True,
            returns : \@Integer::NN,
            matches : (\@Discrete),
        )),

        cardinality : (\Alias : ( of : \@count )),
        "#"         : (\Alias : ( of : \@count )),

        unique_count::"" : (\Function : (
            virtual : True,
            returns : \@Integer::NN,
            matches : (\@Discrete),
        )),

        order : (\Function : (
            returns : \@Positional,
            matches : (\@Discrete),
            evaluates : (args:.\0 order_using \in_order::()),
        )),

        order_using::"" : (\Function : (
            virtual : True,
            returns : \@Positional,
            matches : (\@Discrete, \@Function_Call_But_0_1),
        )),

`#########################################################################`

        Positional : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Stringy, \@Discrete, \@Accessible},
            provides_default_for : {\@Discrete},
        )),

        Excuse::No_Such_Ord_Pos : (\Function : (
            is_type_definer : True,
            constant : (\Excuse : (\@material,)),
        )),

        singular::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional),
            implements : \@folder::"",
            evaluates : ((unique_count args:.\0) = 1),
        )),

        only_member::Positional : (\Function : (
            returns : \@Any,
            matches : (\@Positional),
            implements : \@folder::"",
            accepts : (singular args:.\0),
            evaluates : (first args:.\0),
        )),

        subset_of::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            evaluates : ((to_Bag args:.\0) subset_of (to_Bag args:.\1)),
        )),

        same_members::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((to_Bag args:.\0) same_members (to_Bag args:.\1)),
        )),

        overlaps_members::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((to_Bag args:.\0) overlaps_members (to_Bag args:.\1)),
        )),

        disjoint_members::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : ((to_Bag args:.\0) disjoint_members (to_Bag args:.\1)),
        )),

        member_plus::Positional : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_associative : True,
            evaluates : (args:.\0 ~ args:.\1),
        )),

        unique_count::Positional : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Positional),
            implements : \@folder::"",
            evaluates : (count::(to_Set args:.\0)),
        )),

        has_any_at::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            evaluates : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 < first_unused_ord_pos::(args:.\0)),
        )),

        has_mapping_at::Positional : (\Function : (
            returns : \@Boolean,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            evaluates : (args:.\0 .? (args:.\1.\0) and_then guard args:.\0.(args:.\1.\0) = (args:.\1.\1)),
        )),

        mapping_at::Positional : (\Function : (
            returns : (\@Integer, \@Any),
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            accepts : (args:.\0 .? args:.\1),
            evaluates : ((args:.\1, args:.\0.args:.\1)),
        )),

        maybe_at::Positional : (\Function : (
            returns : \@Any,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            evaluates : (if args:.\0 .? args:.\1 then guard args:.\0.args:.\1 else Excuse::No_Such_Ord_Pos()),
        )),

        replace_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            accepts : (args:.\0 .? (args:.\1.\0)),
            evaluates : (
                src ::= args:.\0;
                rop ::= args:.\1.\0;
                repl_member ::= args:.\1.\1;
                fop ::= first_ord_pos src;
                lop ::= last_ord_pos src;
                emp ::= empty src;
                returns (if rop > fop then guard slice_range::(src, fop, --rop) else emp)
                    insert repl_member
                    catenate (if rop < lop then guard slice_range::(src, ++rop, lop) else emp);
            ),
        )),

        shiftless_insert_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            accepts : (args:.\1.\0 = first_unused_ord_pos::(args:.\0)),
            evaluates : (args:.\0 insert args:.\1.\1),
        )),

        shiftless_remove_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 = --first_unused_ord_pos::(args:.\0)),
            evaluates : (nonlast args:.\0),
        )),

        replace_or_insert_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 <= first_unused_ord_pos::(args:.\0)),
            evaluates : (if args:.\0 .? (args:.\1.\0) then guard args:.\0 .:= (args:.\1.\0) else guard args:.\0 .+ (args:.\1.\0)),
        )),

        shiftless_maybe_remove_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 >= --first_unused_ord_pos::(args:.\0)),
            evaluates : (if args:.\1 = --first_unused_ord_pos::(args:.\0) then guard nonlast args:.\0 else args:.\0),
        )),

        to_Array::"" : (\Function : (
            virtual : True,
            returns : \@Array,
            matches : (\@Positional),
        )),

        "~|" : (\Alias : ( of : \@to_Array )),

        squish : (\Function : (
            returns : \@Positional,
            matches : (\@Positional),
            evaluates : (args:.\0 map \(( group : args:.\0, member : False ))
                pipe nest map \(args:.\0.\group)),
        )),

        first_possible_ord_pos::"" : (\Function : (
            virtual : True,
            returns : \@Integer,
            matches : (\@Positional),
        )),

        first_unused_ord_pos : (\Function : (
            returns : \@Integer,
            matches : (\@Positional),
            evaluates : (first_possible_ord_pos::(args:.\0) + #args:.\0),
        )),

        first_ord_pos : (\Function : (
            returns : \@Integer,
            matches : (\@Positional),
            accepts : (so args:.\0),
            evaluates : (first_possible_ord_pos::(args:.\0)),
        )),

        last_ord_pos : (\Function : (
            returns : \@Integer,
            matches : (\@Positional),
            accepts : (so args:.\0),
            evaluates : (--first_unused_ord_pos::(args:.\0)),
        )),

        slice_n::"" : (\Function : (
            virtual : True,
            returns : \@Positional,
            matches : (\@Positional, \@Integer, \@NN_Integer),
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 + args:.\2 <= first_unused_ord_pos::(args:.\0)),
        )),

        slice_range : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Integer, \@Integer),
            accepts : (so args:.\0 and args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\2 < first_unused_ord_pos::(args:.\0)),
            evaluates : (slice_n::(args:.\0, args:.\1, args:.\2 - args:.\1 + 1)),
        )),

        first : (\Function : (
            returns : \@Any,
            matches : (\@Positional),
            accepts : (so args:.\0),
            evaluates : (args:.\0 . first_ord_pos::(args:.\0)),
        )),

        nonfirst : (\Function : (
            returns : \@Positional,
            matches : (\@Positional),
            accepts : (so args:.\0),
            evaluates : (slice_range::(args:.\0, ++first_ord_pos::(args:.\0), last_ord_pos::(args:.\0))),
        )),

        last : (\Function : (
            returns : \@Any,
            matches : (\@Positional),
            accepts : (so args:.\0),
            evaluates : (args:.\0 . last_ord_pos::(args:.\0)),
        )),

        nonlast : (\Function : (
            returns : \@Positional,
            matches : (\@Positional),
            accepts : (so args:.\0),
            evaluates : (slice_range::(args:.\0, first_ord_pos::(args:.\0), --last_ord_pos::(args:.\0))),
        )),

        ord_pos_succ_all_matches::"" : (\Function : (
            virtual : True,
            returns : \@Integer,
            matches : (\@Positional, \@Positional),
            is_commutative : True,
        )),

`#########################################################################`

        Array::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Positional},
            provides_default_for : {\@Positional},
            evaluates : \foundation::is_a_Array::(),
            default : [],
        )),

        String::"" : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(), \all::( 1: \Integer::() )],
        )),

        Array::Empty : (\Function : (
            is_type_definer : True,
            constant : [],
        )),

        Unicode_Aliases::"~∅" : (\Alias : ( of : \@Array::Empty )),

        in_order::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            evaluates : (
                i ::= args:.\0 ord_pos_succ_all_matches args:.\1;
              returns
                if not args:.\0 .? i then
                    e1 ::= True
                else if not args:.\1 .? i then
                    False
                else guard
                    e2 ::= args:.\0.i in_order args:.\1.i;

                e1 note 'This is the case where LHS is a leading subsequence of or is equal to RHS.';
                e2 note 'This will succeed iff in_order() is defined for the member type.';
            ),
        )),

        to_Boolean::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (args:.\0 != []),
        )),

        empty::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : ([]),
        )),

        substring_of::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_substring_of::()),
        )),

        overlaps_string::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args --> \foundation::Array_overlaps_string::()),
        )),

        disjoint_string::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args --> \foundation::Array_disjoint_string::()),
        )),

        catenate::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_associative : True,
            identity : [],
            repeater : \@replicate::Array,
            evaluates : (args --> \foundation::Array_catenate::()),
        )),

        replicate::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_replicate::()),
        )),

        has_n::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_has_n::()),
        )),

        multiplicity::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array, \@Any),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_multiplicity::()),
        )),

        all_unique::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_all_unique::()),
        )),

        unique::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_unique::()),
        )),

        any::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Signature),
            implements : \@folder::"",
            evaluates : ((args:.\0, Signature_to_Function_Call_But_0::(args:.\1)) --> \foundation::Array_any::()),
        )),

        insert_n::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_insert_n::()),
        )),

        remove_n::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_remove_n::()),
        )),

        except::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            right_identity : [],
            evaluates : (args --> \foundation::Array_except::()),
        )),

        intersect::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_associative : True,
            is_idempotent : True,
            evaluates : (args --> \foundation::Array_intersect::()),
        )),

        union::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_idempotent : True,
            identity : [],
            evaluates : (args --> \foundation::Array_union::()),
        )),

        exclusive::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            identity : [],
            evaluates : (args --> \foundation::Array_exclusive::()),
        )),

        nest::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (args --> \foundation::Array_nest::()),
        )),

        unnest::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (args --> \foundation::Array_unnest::()),
        )),

        where::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Signature),
            implements : \@folder::"",
            evaluates : ((args:.\0, Signature_to_Function_Call_But_0::(args:.\1))
                --> \foundation::Array_where::()),
        )),

        map::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_map::()),
        )),

        reduce::Array : (\Function : (
            returns : \@Any,
            matches : (\@Array, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_reduce::()),
        )),

        to_Set::Array : (\Function : (
            returns : \@Set,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (to_Set::(to_Bag args:.\0)),
        )),

        to_Bag::Array : (\Function : (
            returns : \@Bag,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_to_Bag::()),
        )),

        count::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_count::()),
        )),

        order_using::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Array_order_using::()),
        )),

        at::Array : (\Function : (
            returns : \@Any,
            matches : (\@Array, \@Integer::NN),
            implements : \@folder::"",
            accepts : (args:.\0 .? args:.\1),
            evaluates : (args --> \foundation::Array_at::()),
        )),

        to_Array::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        first_possible_ord_pos::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : (0),
        )),

        slice_n::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@NN_Integer, \@NN_Integer),
            implements : \@folder::"",
            accepts : (args:.\1 + args:.\2 <= #args:.\0),
            evaluates : (args --> \foundation::Array_slice_n::()),
        )),

        ord_pos_succ_all_matches::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args --> \foundation::Array_ord_pos_succ_all_matches::()),
        )),

`#########################################################################`

        Setty : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

`#########################################################################`

        Set::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Discrete, \@Setty},
            provides_default_for : {\@Setty},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Set
                and_then guard args:.\0:> is_a (
                    members : \Bag(),
                )
                and_then guard all_unique args:.\0:>.\members
            ),
            default : {},
        )),

        Set::Empty : (\Function : (
            is_type_definer : True,
            constant : {},
        )),

        Unicode_Aliases::"?∅" : (\Alias : ( of : \@Set::Empty )),

        to_Boolean::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (args:.\0 != {}),
        )),

        empty::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : ({}),
        )),

        singular::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (singular args:.\0:>.\members),
        )),

        only_member::Set : (\Function : (
            returns : \@Any,
            matches : (\@Set),
            implements : \@folder::"",
            accepts : (singular args:.\0),
            evaluates : (only_member args:.\0:>.\members),
        )),

        has_n::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (has_n::(args:.\0:>.\members, args:.\1, args:.\2)),
        )),

        multiplicity::Set : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Set, \@Any),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\members multiplicity args:.\1),
        )),

        all_unique::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (True),
        )),

        unique::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        subset_of::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\members subset_of args:.\1:>.\members),
        )),

        same_members::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args:.\0 = args:.\1),
        )),

        overlaps_members::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args:.\0:>.\members overlaps_members args:.\1:>.\members),
        )),

        disjoint_members::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args:.\0:>.\members disjoint_members args:.\1:>.\members),
        )),

        any::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Signature),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\members any args:.\1),
        )),

        insert_n::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\0 has args:.\1 or args:.\2 = 0 then args:.\0
                else (\Set : (members : insert_n::(args:.\0:>.\members, args:.\1, 1),))),
        )),

        remove_n::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : ((\Set : (members : remove_n::(args:.\0:>.\members, args:.\1, args:.\2),))),
        )),

        member_plus::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {},
            evaluates : (args:.\0 union args:.\1),
        )),

        except::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            right_identity : {},
            evaluates : ((\Set : (members : args:.\0:>.\members except args:.\1:>.\members,))),
        )),

        intersect::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : ((\Set : (members : args:.\0:>.\members intersect args:.\1:>.\members,))),
        )),

        union::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {},
            evaluates : ((\Set : (members : args:.\0:>.\members union args:.\1:>.\members,))),
        )),

        exclusive::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : {},
            evaluates : ((\Set : (members : args:.\0:>.\members exclusive args:.\1:>.\members,))),
        )),

        nest::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            accepts : (...),
            evaluates : ((\Set : (members : nest args:.\0:>.\members,))),
        )),

        unnest::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            accepts : (...),
            evaluates : ((\Set : (members : unnest args:.\0:>.\members,))),
        )),

        where::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Signature),
            implements : \@folder::"",
            evaluates : ((\Set : (members : args:.\0:>.\members where args:.\1,))),
        )),

        map::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : ((\Set : (members : args:.\0:>.\members map args:.\1,))),
        )),

        reduce::Set : (\Function : (
            returns : \@Any,
            matches : (\@Set, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : ((\Set : (members : args:.\0:>.\members reduce args:.\1,))),
        )),

        to_Set::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        to_Bag::Set : (\Function : (
            returns : \@Bag,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\members),
        )),

        count::Set : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (count args:.\0:>.\members),
        )),

        unique_count::Set : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : (count args:.\0),
        )),

        order_using::Set : (\Function : (
            returns : \@Array,
            matches : (\@Set, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\members order_using args:.\1),
        )),

`#########################################################################`

        Bag::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Discrete},
            evaluates : \foundation::is_a_Bag::(),
            default : {0:0},
        )),

        Bag::Empty : (\Function : (
            is_type_definer : True,
            constant : {0:0},
        )),

        Unicode_Aliases::"+∅" : (\Alias : ( of : \@Bag::Empty )),

        to_Boolean::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : (args:.\0 != {0:0}),
        )),

        empty::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : ({0:0}),
        )),

        singular::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_singular::()),
        )),

        only_member::Bag : (\Function : (
            returns : \@Any,
            matches : (\@Bag),
            implements : \@folder::"",
            accepts : (singular args:.\0),
            evaluates : (args --> \foundation::Bag_only_member::()),
        )),

        has_n::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_has_n::()),
        )),

        multiplicity::Bag : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Bag, \@Any),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_multiplicity::()),
        )),

        all_unique::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_all_unique::()),
        )),

        unique::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_unique::()),
        )),

        subset_of::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_subset_of::()),
        )),

        same_members::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args:.\0 = args:.\1),
        )),

        overlaps_members::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args --> \foundation::Bag_overlaps_members::()),
        )),

        disjoint_members::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (args --> \foundation::Bag_disjoint_members::()),
        )),

        any::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Signature),
            implements : \@folder::"",
            evaluates : ((args:.\0, Signature_to_Function_Call_But_0::(args:.\1)) --> \foundation::Bag_any::()),
        )),

        insert_n::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_insert_n::()),
        )),

        remove_n::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_remove_n::()),
        )),

        member_plus::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : {0:0},
            evaluates : (args --> \foundation::Bag_member_plus::()),
        )),

        except::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            right_identity : {0:0},
            evaluates : (args --> \foundation::Bag_except::()),
        )),

        intersect::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : (args --> \foundation::Bag_intersect::()),
        )),

        union::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {0:0},
            evaluates : (args --> \foundation::Bag_union::()),
        )),

        exclusive::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : {0:0},
            evaluates : (args --> \foundation::Bag_exclusive::()),
        )),

        nest::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (args --> \foundation::Bag_nest::()),
        )),

        unnest::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (args --> \foundation::Bag_unnest::()),
        )),

        where::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Signature),
            implements : \@folder::"",
            evaluates : ((args:.\0, Signature_to_Function_Call_But_0::(args:.\1)) --> \foundation::Bag_where::()),
        )),

        map::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_map::()),
        )),

        reduce::Bag : (\Function : (
            returns : \@Any,
            matches : (\@Bag, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_reduce::()),
        )),

        to_Set::Bag : (\Function : (
            returns : \@Set,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : ((\Set : (members : unique args:.\0,))),
        )),

        to_Bag::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        count::Bag : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_count::()),
        )),

        unique_count::Bag : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_unique_count::()),
        )),

        order_using::Bag : (\Function : (
            returns : \@Array,
            matches : (\@Bag, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Bag_order_using::()),
        )),

`#########################################################################`

        Attributive : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        Excuse::No_Such_Attr_Name : (\Function : (
            is_type_definer : True,
            constant : (\Excuse : (\@material,)),
        )),

        Excuse::Not_Same_Heading : (\Function : (
            is_type_definer : True,
            constant : (\Excuse : (\@material,)),
        )),

        has_any_attrs::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Attributive),
        )),

        "?@" : (\Alias : ( of : \@has_any_attrs )),

        is_nullary : (\Function : (
            negates : \@has_any_attrs,
        )),

        "!?@" : (\Alias : ( of : \@is_nullary )),

        nullary::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive),
        )),

        is_unary::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Attributive),
        )),

        degree::"" : (\Function : (
            virtual : True,
            returns : \@Integer::NN,
            matches : (\@Attributive),
        )),

        "#@" : (\Alias : ( of : \@degree )),

        heading::"" : (\Function : (
            virtual : True,
            returns : \@Heading,
            matches : (\@Attributive),
        )),

        "@" : (\Alias : ( of : \@heading )),

        subheading_of : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            evaluates : ((@args:.\0, @args:.\1) --> \foundation::Tuple_subheading_of::()),
        )),

        Unicode_Aliases::"⊆@" : (\Alias : ( of : \@subheading_of )),

        superheading_of : (\Function : (
            commutes : \@subheading_of,
        )),

        has_subheading : (\Alias : ( of : \@superheading_of )),
        "@?"           : (\Alias : ( of : \@superheading_of )),

        Unicode_Aliases::"⊇@" : (\Alias : ( of : \@superheading_of )),

        same_heading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : (@args:.\0 = @args:.\1),
        )),

        "=@" : (\Alias : ( of : \@same_heading )),

        proper_subheading_or_superheading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : (@args:.\0 != @args:.\1 and (args:.\0 subheading_or_superheading args:.\1)),
        )),

        subheading_or_superheading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : ((args:.\0 subheading_of args:.\1) or (args:.\0 superheading_of args:.\1)),
        )),

        overlaps_heading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : ((@args:.\0, @args:.\1) --> \foundation::Tuple_overlaps_heading::()),
        )),

        disjoint_heading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : ((@args:.\0, @args:.\1) --> \foundation::Tuple_disjoint_heading::()),
        )),

        except_heading : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            evaluates : ((@args:.\0, @args:.\1) --> \foundation::Tuple_except_heading::()),
        )),

        Unicode_Aliases::"∖@" : (\Alias : ( of : \@except_heading )),

        intersect_heading : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : ((@args:.\0, @args:.\1) --> \foundation::Tuple_intersect_heading::()),
        )),

        Unicode_Aliases::"∩@" : (\Alias : ( of : \@intersect_heading )),

        union_heading : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : (),
            evaluates : ((@args:.\0, @args:.\1) --> \foundation::Tuple_union_heading::()),
        )),

        Unicode_Aliases::"∪@" : (\Alias : ( of : \@union_heading )),

        exclusive : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            is_associative : True,
            is_commutative : True,
            identity : (),
            evaluates : ((@args:.\0, @args:.\1) --> \foundation::Tuple_exclusive_heading::()),
        )),

        symm_diff_heading : (\Alias : ( of : \@exclusive_heading )),

        Unicode_Aliases::"∆@" : (\Alias : ( of : \@exclusive_heading )),

        rename::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Renaming),
            accepts : (...),
        )),

        "@:=" : (\Alias : ( of : \@rename )),

        Unicode_Aliases::"ρ" : (\Alias : ( of : \@rename )),

        renaming : (\Function : (
            commutes : \@rename,
        )),

        can_project_matching::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Attributive, \@Structural),
        )),

        "%=?" : (\Alias : ( of : \@can_project_matching )),

        on::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            accepts : (args:.\0 @? args:.\1),
        )),

        project : (\Alias : ( of : \@on )),
        "%="    : (\Alias : ( of : \@on )),

        Unicode_Aliases::"π" : (\Alias : ( of : \@on )),

        from : (\Function : (
            commutes : \@on,
        )),

        maybe_on : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            evaluates : (args:.\0 on (args:.\0 intersect_heading args:.\1)),
        )),

        "%!" : (\Alias : ( of : \@maybe_on )),

        update::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Structural),
            accepts : (args:.\0 @? args:.\1),
        )),

        "%:=" : (\Alias : ( of : \@update )),

        extend::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Structural),
            accepts : (args:.\0 disjoint_heading args:.\1),
        )),

        "%+" : (\Alias : ( of : \@extend )),

        but : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            accepts : (args:.\0 @? args:.\1),
            evaluates : (args:.\0 on (args:.\0 except_heading args:.\1)),
        )),

        project_all_but : (\Alias : ( of : \@but )),
        "%-"            : (\Alias : ( of : \@but )),

        update_or_extend : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Structural),
            evaluates : (args:.\0 on (args:.\0 except_heading args:.\1) extend args:.\1),
        )),

        "%=+" : (\Alias : ( of : \@update_or_extend )),

        maybe_but : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            evaluates : (args:.\0 but (args:.\0 intersect_heading args:.\1)),
        )),

        "%?-" : (\Alias : ( of : \@maybe_but )),

`#########################################################################`

        Structural : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Attributive, \@Accessible},
            provides_default_for : {\@Attributive, \@Accessible},
        )),

        can_project_matching::Structural : (\Function : (
            returns : \@Boolean,
            matches : (\@Structural, \@Structural),
            implements : \@folder::"",
            evaluates : (args:.\0 @? args:.\1 and_then guard args:.\0 %= @args:.\1 = args:.\1),
        )),

        has_any_at::Structure : (\Function : (
            returns : \@Boolean,
            matches : (\@Structure, \@Attr_Name),
            implements : \@folder::"",
            evaluates : (args:.\0 @? args:.\1),
        )),

        has_mapping_at::Structural : (\Function : (
            returns : \@Boolean,
            matches : (Structural, (Attr_Name, Any)),
            implements : \@folder::"",
            evaluates : (args:.\0 .? (args:.\1.\0) and_then guard args:.\0.(args:.\1.\0) = (args:.\1.\1)),
        )),

        mapping_at::Structural : (\Function : (
            returns : (\@Attr_Name, \@Any),
            matches : (\@Structural, \@Attr_Name),
            implements : \@folder::"",
            accepts : (args:.\0 .? args:.\1),
            evaluates : ((args:.\1, args:.\0.args:.\1)),
        )),

        maybe_at::Structural : (\Function : (
            returns : \@Any,
            matches : (\@Structural, \@Attr_Name),
            implements : \@folder::"",
            evaluates : (if args:.\0 .? args:.\1 then guard args:.\0.args:.\1 else Excuse::No_Such_Attr_Name()),
        )),

        replace_at::Structure : (\Function : (
            returns : \@Structure,
            matches : (Structure, (Attr_Name, Any)),
            implements : \@folder::"",
            accepts : (args:.\0 .? (args:.\1.\0)),
            evaluates : (args:.\0 update D1::(args:.\1)),
        )),

        shiftless_insert_at::Structure : (\Function : (
            returns : \@Structure,
            matches : (Structure, (Attr_Name, Any)),
            implements : \@folder::"",
            accepts : (not args:.\0 .? (args:.\1.\0)),
            evaluates : (args:.\0 extend D1::(args:.\1)),
        )),

        shiftless_remove_at::Structure : (\Function : (
            returns : \@Structure,
            matches : (\@Structure, \@Attr_Name),
            implements : \@folder::"",
            accepts : (args:.\0 .? args:.\1),
            evaluates : (args:.\0 but args:.\1),
        )),

        replace_or_insert_at::Structural : (\Function : (
            returns : \@Structural,
            matches : (Structural, (Attr_Name, Any)),
            implements : \@folder::"",
            evaluates : (args:.\0 update_or_extend D1::(args:.\1)),
        )),

        shiftless_maybe_remove_at::Structural : (\Function : (
            returns : \@Structural,
            matches : (\@Structural, \@Attr_Name),
            implements : \@folder::"",
            evaluates : (args:.\0 maybe_but args:.\1),
        )),

        to_Tuple::"" : (\Function : (
            virtual : True,
            returns : \@Tuple,
            matches : (\@Structural),
        )),

        "%" : (\Alias : ( of : \@to_Tuple )),

`#########################################################################`

        Tuple::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Structural},
            provides_default_for : {\@Structural},
            evaluates : \foundation::is_a_Tuple::(),
            default : (),
        )),

        Tuple::D0 : (\Function : (
            is_type_definer : True,
            constant : (),
        )),

        Tuple::D1 : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \is_unary::()],
            default : (False,),
        )),

        D1 : (\Function : (
            returns : \@Tuple::D1,
            matches : (\@Attr_Name, \@Any),
            evaluates : (args --> \foundation::Tuple_D1_select::()),
        )),

        has_any_attrs::Tuple : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : (args:.\0 != ()),
        )),

        nullary::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : (()),
        )),

        is_unary::Tuple : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : (degree::(args:.\0) = 1),
        )),

        degree::Tuple : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Tuple_degree::()),
        )),

        heading::Tuple : (\Function : (
            returns : \@Heading,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : (args --> \foundation::Tuple_heading::()),
        )),

        rename::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Renaming),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (args --> \foundation::Tuple_rename::()),
        )),

        on::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Heading),
            implements : \@folder::"",
            accepts : (args:.\0 @? args:.\1),
            evaluates : (args --> \foundation::Tuple_on::()),
        )),

        update::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Tuple),
            implements : \@folder::"",
            accepts : (args:.\0 @? args:.\1),
            evaluates : (args --> \foundation::Tuple_update::()),
        )),

        extend::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Tuple),
            implements : \@folder::"",
            accepts : (args:.\0 disjoint_heading args:.\1),
            is_associative : True,
            is_commutative : True,
            identity : (),
            evaluates : (args --> \foundation::Tuple_extend::()),
        )),

        at::Tuple : (\Function : (
            returns : \@Any,
            matches : (\@Tuple, \@Attr_Name),
            implements : \@folder::"",
            accepts : (args:.\0 .? args:.\1),
            evaluates : (args:.\0 :. (args:.\1)),
        )),

        to_Tuple::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : (args:.\0),
        )),

        any_attrs : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple, \@Signature),
            evaluates : ((args:.\0, Signature_to_Function_Call_But_0::(args:.\1))
                --> \foundation::Tuple_any_attrs::()),
        )),

        none_of_attrs : (\Function : (
            negates : \@any_attrs,
        )),

        all_attrs : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple, \@Signature),
            evaluates : (args:.\0 none_of_attrs \not_is_a::( 1: args:.\1 )),
        )),

        not_all_attrs : (\Function : (
            negates : \@all_attrs,
        )),

        all_attr_assets : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple, \@Signature),
            evaluates : (args:.\0 all_attrs \(args:.\1 <-- (args:.\0.\asset,))
                \<-- (1 : Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        attrs_where : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Signature),
            evaluates : ((args:.\0, Signature_to_Function_Call_But_0::(args:.\1))
                --> \foundation::Tuple_attrs_where::()),
        )),

        attrs_map : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Function_Call_But_0),
            evaluates : (args --> \foundation::Tuple_attrs_map::()),
        )),

        attrs_reduce : (\Function : (
            returns : \@Any,
            matches : (\@Tuple, \@Function_Call_But_0_1),
            evaluates : (args --> \foundation::Tuple_attrs_reduce::()),
        )),

`#########################################################################`

        Relational : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Unionable, \@Attributive},
        )),

        to_Boolean::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (? |args:.\0),
        )),

        empty::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (select_Relational::( like: args:.\0, heading: @args:.\0, body: empty |args:.\0 )),
        )),

        singular::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (singular |args:.\0),
        )),

        only_member::Relational : (\Function : (
            returns : \@Structural,
            matches : (\@Relational),
            implements : \@folder::"",
            accepts : (singular args:.\0),
            evaluates : (only_member |args:.\0),
        )),

        has_n::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Structural, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\0 =@ args:.\1 then guard has_n::(|args:.\0, args:.\1, args:.\2)
                else Excuse::Not_Same_Heading),
        )),

        multiplicity::Relational : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            evaluates : (|args:.\0 multiplicity args:.\1),
        )),

        all_unique::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (all_unique |args:.\0),
        )),

        unique::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (select_Relational::( like: args:.\0, heading: @args:.\0, body: unique |args:.\0 )),
        )),

        subset_of::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            evaluates : (if args:.\0 =@ args:.\1 then guard |args:.\0 subset_of |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        same_members::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (if args:.\0 =@ args:.\1 then guard |args:.\0 same_members |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        overlaps_members::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (if args:.\0 =@ args:.\1 then guard |args:.\0 overlaps_members |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        disjoint_members::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : (if args:.\0 =@ args:.\1 then guard |args:.\0 disjoint_members |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        any::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational, \@Signature),
            implements : \@folder::"",
            evaluates : (|args:.\0 any args:.\1),
        )),

        insert_n::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Structural, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: insert_n::(|args:.\0, args:.\1, args:.\2) )
                else Excuse::Not_Same_Heading),
        )),

        remove_n::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Structural, \@Integer::NN),
            implements : \@folder::"",
            evaluates : (if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: remove_n::(|args:.\0, args:.\1, args:.\2) )
                else Excuse::Not_Same_Heading),
        )),

        member_plus::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_associative : True,
            evaluates : (if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 member_plus |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        except::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            evaluates : (if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 except |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        intersect::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_associative : True,
            is_idempotent : True,
            evaluates : (if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 intersect |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        union::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_idempotent : True,
            evaluates : (if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 union |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        exclusive::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            evaluates : (if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 exclusive |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        nest::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (...),
        )),

        unnest::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (...),
        )),

        where::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Signature),
            implements : \@folder::"",
            evaluates : (select_Relational::( like: args:.\0, heading: @args:.\0, body: |args:.\0 where args:.\1 )),
        )),

        map::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : (...),
        )),

        reduce::Relational : (\Function : (
            returns : \@Any,
            matches : (\@Relational, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : (|args:.\0 reduce args:.\1),
        )),

        has_any_attrs::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (@args:.\0 != ()),
        )),

        nullary::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (args:.\0 on ()),
        )),

        is_unary::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (is_unary @args:.\0),
        )),

        degree::Relational : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : (degree @args:.\0),
        )),

        rename::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Renaming),
            implements : \@folder::"",
            accepts : (...),
            evaluates : (select_Relational::( like: args:.\0, heading: @args:.\0 rename args:.\1,
                body: |args:.\0 map \rename::( 1: args:.\1 ) )),
        )),

        can_project_matching::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            evaluates : (args:.\0 @? args:.\1
                and_then guard |args:.\0 all \(args:.\0 %= @args:.\1 = args:.\1) \<-- (1 : args:.\1,)),
        )),

        on::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Heading),
            implements : \@folder::"",
            accepts : (args:.\0 @? args:.\1),
            evaluates : (select_Relational::( like: args:.\0, heading: @args:.\0 on args:.\1,
                body: |args:.\0 map \on::( 1: args:.\1 ) )),
        )),

        update::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            accepts : (args:.\0 @? args:.\1),
            evaluates : (select_Relational::( like: args:.\0, heading: @args:.\0,
                body: |args:.\0 map \update::( 1: args:.\1 ) )),
        )),

        extend::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            accepts : (args:.\0 disjoint_heading args:.\1),
            evaluates : (select_Relational::( like: args:.\0, heading: @args:.\0 extend args:.\1,
                body: |args:.\0 map \extend::( 1: args:.\1 ) )),
        )),

        body::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Relational),
        )),

        "|" : (\Alias : ( of : \@body )),

        select_Relational::"" : (\Function : (
            virtual : True,
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Relational, heading : \@Heading, body : \@Unionable),
        )),

`#########################################################################`

        Tuple_Array::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Relational, \@Positional},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Tuple_Array
                and_then guard args:.\0:> is_a ( heading : \Heading::(), body : \Array::() )
                and_then guard args:.\0:>.\body all \Tuple::()
                and_then guard args:.\0:>.\body all \(@args:.\0 = args:.\1) \<-- (args:.\0:>.\heading)
            ),
            default : (~%@()),
        )),

        Tuple_Array::D0C0 : (\Function : (
            is_type_definer : True,
            constant : ~%@(),
        )),

        Tuple_Array::D0C1 : (\Function : (
            is_type_definer : True,
            constant : ~%[()],
        )),

        heading::Tuple_Array : (\Function : (
            returns : \@Heading,
            matches : (\@Tuple_Array),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\heading),
        )),

        body::Tuple_Array : (\Function : (
            returns : \@Array,
            matches : (\@Tuple_Array),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\body),
        )),

        select_Relational::Tuple_Array : (\Function : (
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Tuple_Array, heading : \@Heading, body : \@Array),
            implements : \@folder::"",
            evaluates : ((\Tuple_Array : (args %= \@(heading,body)))),
        )),

`#########################################################################`

        Relation::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Relational, \@Discrete, \@Setty},
            provides_default_for : {\@Relational},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Relation
                and_then guard args:.\0:> is_a ( heading : \Heading::(), body : \Set::() )
                and_then guard args:.\0:>.\body all \Tuple::()
                and_then guard args:.\0:>.\body all \(@args:.\0 = args:.\1) \<-- (args:.\0:>.\heading)
            ),
            default : (?%@()),
        )),

        Relation::D0C0 : (\Function : (
            is_type_definer : True,
            constant : ?%@(),
        )),

        Relation::D0C1 : (\Function : (
            is_type_definer : True,
            constant : ?%{()},
        )),

        heading::Relation : (\Function : (
            returns : \@Heading,
            matches : (\@Relation),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\heading),
        )),

        body::Relation : (\Function : (
            returns : \@Set,
            matches : (\@Relation),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\body),
        )),

        select_Relational::Relation : (\Function : (
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Relation, heading : \@Heading, body : \@Set),
            implements : \@folder::"",
            evaluates : ((\Relation : (args %= \@(heading,body)))),
        )),

`#########################################################################`

        Tuple_Bag::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Relational, \@Discrete},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Tuple_Bag
                and_then guard args:.\0:> is_a ( heading : \Heading::(), body : \Bag::() )
                and_then guard args:.\0:>.\body all \Tuple::()
                and_then guard args:.\0:>.\body all \(@args:.\0 = args:.\1) \<-- (args:.\0:>.\heading)
            ),
            default : (+%@()),
        )),

        Tuple_Bag::D0C0 : (\Function : (
            is_type_definer : True,
            constant : +%@(),
        )),

        Tuple_Bag::D0C1 : (\Function : (
            is_type_definer : True,
            constant : +%{()},
        )),

        heading::Tuple_Bag : (\Function : (
            returns : \@Heading,
            matches : (\@Tuple_Bag),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\heading),
        )),

        body::Tuple_Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Tuple_Bag),
            implements : \@folder::"",
            evaluates : (args:.\0:>.\body),
        )),

        select_Relational::Tuple_Bag : (\Function : (
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Tuple_Bag, heading : \@Heading, body : \@Bag),
            implements : \@folder::"",
            evaluates : ((\Tuple_Bag : (args %= \@(heading,body)))),
        )),

`#########################################################################`

        Intervalish : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Homogeneous},
        )),

`#########################################################################`

        Interval::"" : (\Function : (
            is_type_definer : True,
            composes : {\@Intervalish, \@Setty},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Interval
                and_then guard args:.\0:> is_a \Interval::Attrs()
            ),
            default : (Excuse::Before_All_Others()..Excuse::After_All_Others()),
        )),

        Interval::Attrs : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), ...],
        )),

`#########################################################################`

        Unionable_Intervalish : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Intervalish, \@Unionable},
        )),

`#########################################################################`

        Interval_Set : (\Function : (
            is_type_definer : True,
            composes : {\@Unionable_Intervalish, \@Setty},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Interval_Set
                and_then guard args:.\0:> is_a (
                    members : \Interval_Bag(),
                )
                and_then guard all_unique args:.\0:>.\members
            ),
            default : ...,
        )),

`#########################################################################`

        Interval_Bag : (\Function : (
            is_type_definer : True,
            composes : {\@Unionable_Intervalish},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Interval_Bag
                and_then guard args:.\0:> is_a (
                    members : \Tuple_Bag(),
                )
                and_then guard ...
            ),
            default : ...,
        )),

`#########################################################################`

        Quantitative : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\@Numerical},
        )),

`#########################################################################`

        Quantity : (\Function : (
            is_type_definer : True,
            composes : {\@Quantitative},
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Quantity
                and_then guard args:.\0:> is_a (
                    0 : \Relation(),
                )
            ),
            default : ...,
        )),

`#########################################################################`

        Capsule : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::is_a_Capsule::(),
            default : (False : ()),
        )),

`#########################################################################`

        Reference::"" : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::is_a_Reference::(),
            default : () --> \foundation::default_Reference::(),
        )),

`#########################################################################`

        External::"" : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::is_a_External::(),
            default : () --> \foundation::default_External::(),
        )),

        External::call_function : (\Function : (
            returns : \@Any,
            matches : (\@Any),
            evaluates : (\foundation::External_call_function::() <-- args),
        )),

`#########################################################################`

        Source_Code::Package : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Package
                and_then guard args:.\0:> is_a (
                    identity : \Package::Identity::(),
                    foundation : \Package::Foundation::(),
                    uses : \Package::Uses_Map::(),
                    entry : \Package::Entry_Point::(),
                    floating : \Package::Floating::(),
                    materials : \Package::Folder::(),
                )
            ),
            default : ...,
        )),

        Source_Code::Package::Identity : (\Function : (
            is_type_definer : True,
            evaluates : (
                package_base_name : \Package::Base_Name::(),
                authority : \Package::Canon_Authority::(),
                version_number : \Package::Canon_Version_Number::(),
            ),
        )),

        Source_Code::Package::Foundation : (\Function : (
            is_type_definer : True,
            evaluates : (
                authority : \Package::Canon_Authority::(),
                version_number : \Package::Canon_Version_Number::(),
            ),
        )),

        Source_Code::Package::Base_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Attr_Name_List::(), \so::(), \"∌"::( 1: \"" )],
        )),

        Source_Code::Package::Canon_Authority : (\Function : (
            is_type_definer : True,
            evaluates : [\Text::(), \so::()],
        )),

        Source_Code::Package::Canon_Version_Number : (\Function : (
            is_type_definer : True,
            evaluates : [\Text::(), \so::()],
        )),

        Source_Code::Package::Uses_Map : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \".!?"::( 1: \"" ),
                \all_attr_assets::( 1: \Package::Uses_Item() )],
        )),

        Source_Code::Package::Uses_Item : (\Function : (
            is_type_definer : True,
            evaluates : (
                package_base_name : \Package::Base_Name::(),
                authority : \Package::Canon_Authority::(),
                version_number : \Package::Canon_Version_Number::(),
            ),
        )),

        Source_Code::Package::Entry_Point : (\Function : (
            is_type_definer : True,
            evaluates : \Absolute_Name::(),
        )),

        Source_Code::Package::Floating : (\Function : (
            is_type_definer : True,
            evaluates : [\Set::(), \all::( 1: \Absolute_Name::() )],
        )),

        Source_Code::Package::Folder : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(),
                \all_attr_assets::( 1: {\Package::Folder(), \Material::()} )],
        )),

        Source_Code::Material : (\Function : (
            is_type_definer : True,
            evaluates : {\@Alias, \@Function, \@Procedure},
            default : ...,
        )),

        Source_Code::Alias : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Alias
                and_then guard args:.\0:> is_a (
                    of : \Identity_Identifier(),
                )
            ),
            default : ((\Alias : (of : Identity_Identifier::(),))),
        )),

        Source_Code::Function : (\Function : (
            is_type_definer : True,
            evaluates : (
                function ::= args:.\0;

                returns Capsule function
                    and_then guard function:< = \Function
                    and_then guard when_well_formed_Capsule;

                traits ::= function:>;

                when_well_formed_Capsule ::=
                    if traits .:? (\is_type_definer, True) then
                        if traits .:? (\is_generalization, True) then
                            when_generalized_type_definer
                        else if traits.?\constant then
                            when_singleton_type_definer
                        else
                            when_regular_type_definer
                    else
                        when_regular_function;

                when_generalized_type_definer ::=
                    traits is_a (\@Signature::Tuple_Attrs_Match : (
                        is_type_definer : (type : \True::(),),
                        is_generalization : (type : \True::(),),
                        default : (type : \Expression::(), optional : True),
                    ) %+ type_specialization_attrs_template)
                    and_then type_specialization_attrs_constraint;

                when_singleton_type_definer ::=
                    traits is_a (\@Signature::Tuple_Attrs_Match : (
                        is_type_definer : (type : \True::(),),
                        is_generalization : (type : \False::(), optional : True),
                        constant : (type : \Expression::(),),
                    ) %+ type_specialization_attrs_template)
                    and_then type_specialization_attrs_constraint;

                when_regular_type_definer ::=
                    traits is_a (\@Signature::Tuple_Attrs_Match : (
                        is_type_definer : (type : \True::(),),
                        is_generalization : (type : \False::(), optional : True),
                        evaluates : (type : {\Expression::(), \Signature::()},),
                        default : (type : \Expression::(), optional : True),
                    ) %+ type_specialization_attrs_template)
                    and_then type_specialization_attrs_constraint;

                type_specialization_attrs_template ::=
                    (
                        composes : (type : \Set_of_Identity_Identifier::(), optional : True),
                        provides_default_for : (type : \Set_of_Identity_Identifier::(), optional : True),
                    );

                type_specialization_attrs_constraint ::=
                    if traits.?\provides_default_for then
                        traits.?\composes
                        and_then guard traits:.\provides_default_for ⊆ traits:.\composes
                    else
                        True;

                when_regular_function ::=
                    traits is_a (\@Signature::Tuple_Attrs_Match : (
                        is_type_definer : (type : \False::(), optional : True),
                        virtual : (type : \Boolean::(), optional : True),
                        commutes : (type : \Identity_Identifier::(), optional : True),
                        negates : (type : \Identity_Identifier::(), optional : True),
                        returns : (type : \Signature::(), optional : True),
                        matches : (type : \Signature::Tuple_Attrs_Match_Simple(), optional : True),
                        implements : (type : ..., optional : True),
                        overrides : (type : ..., optional : True),
                        accepts : (type : \Expression::(), optional : True),
                        intends : (type : \Expression::(), optional : True),
                        is_associative : (type : \Boolean::(), optional : True),  `two-way associative`
                        is_commutative : (type : \Boolean::(), optional : True),
                        is_idempotent : (type : \Boolean::(), optional : True),
                        identity : (type : \Expression::(), optional : True),  `iff two-sided identity element exists`
                        left_identity : (type : \Expression::(), optional : True),  `iff only left-identity element exists`
                        right_identity : (type : \Expression::(), optional : True),  `iff only right-identity element exists`
                        repeater : (type : ..., optional : True),
                        evaluates : (type : \Expression::(), optional : True),
                    ));
            ),
            default : ...,
        )),

        Source_Code::Procedure : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \Procedure
                and_then guard args:.\0:> is_a (\@Signature::Tuple_Attrs_Match : (
                    virtual : (type : \Boolean::(), optional : True),
                    matches : (type : \Signature::Tuple_Attrs_Match_Simple(), optional : True),
                    implements : (type : ..., optional : True),
                    overrides : (type : ..., optional : True),
                    accepts : (type : \Expression::(), optional : True),
                    intends : (type : \Expression::(), optional : True),
                    performs : (type : \Statement::(), optional : True),
                ))
            ),
            default : ...,
        )),

        Source_Code::Signature::"" : (\Function : (
            is_type_definer : True,
            evaluates : {
                \@Function_Call_But_0,
                \@folder::Conjunction,
                \@folder::Disjunction,
                \@folder::Tuple_Attrs_Match_Simple,
                \@folder::Tuple_Attrs_Match,
            },
            default : \Any::(),
        )),

        Source_Code::Signature::Conjunction : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(), \all::( 1: \Signature::() )],
        )),

        Source_Code::Signature::Disjunction : (\Function : (
            is_type_definer : True,
            evaluates : [\Set::(), \all::( 1: \Signature::() )],
        )),

        Source_Code::Signature::Tuple_Attrs_Match_Simple : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \all_attr_assets::( 1: \Signature::() )],
        )),

        Source_Code::Signature::Tuple_Attrs_Match : (\Function : (
            is_type_definer : True,
            evaluates : (
                tuple_sig ::= args:.\0;
                returns Capsule tuple_sig
                    and_then guard tuple_sig:< = \@material
                    and_then guard tuple_sig:> all_attr_assets \(
                        attr_sig ::= args:.\0;
                        returns Tuple attr_sig
                            and_then guard
                                attr_sig ⊆@ \@(type,optional)
                                and
                                (attr_sig.?\type and_then guard Signature attr_sig.\type)
                                and
                                if attr_sig.?\optional
                                    then guard Boolean attr_sig.\optional
                                    else True
                            ;
                    );
            ),
        )),

        Source_Code::Expression : (\Function : (
            is_type_definer : True,
            evaluates : {
                \@Literal,
                \@Args,
                \@Evaluates,
                \@If_Then_Else_Expr,
                \@And_Then,
                \@Or_Else,
                \@Given_When_Default_Expr,
                \@Guard,
                \@Factorization,
                \@Expansion,
            },
            default : (\@Literal : (False,)),
        )),

        Source_Code::Literal : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Any::(),
                )
            ),
            default : (\@material : (False,)),
        )),

        Source_Code::Args : (\Function : (
            is_type_definer : True,
            constant : \@material,
        )),

        Source_Code::Evaluates : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                )
            ),
            default : (\@material : ...),
        )),

        Source_Code::If_Then_Else_Expr : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                    1 : \Expression::(),
                    2 : \Expression::(),
                )
            ),
            default : (\@material : ((\@Literal : (False,)),
                (\@Literal : (False,)), (\@Literal : (False,)))),
        )),

        Source_Code::And_Then : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                    1 : \Expression::(),
                )
            ),
            default : (\@material : ((\@Literal : (False,)),
                (\@Literal : (False,)))),
        )),

        Source_Code::Or_Else : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                    1 : \Expression::(),
                )
            ),
            default : (\@material : ((\@Literal : (False,)),
                (\@Literal : (False,)))),
        )),

        Source_Code::Given_When_Default_Expr : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                    1 : [\Set::(), \all::( 1: (
                        0 : \Expression::(),
                        1 : \Expression::(),
                    ) )],
                    2 : \Expression::(),
                )
            ),
            default : (\@material : ((\@Literal : (False,)),
                {}, (\@Literal : (False,)))),
        )),

        Source_Code::Guard : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                )
            ),
            default : (\@material : ((\@Literal : (False,)),)),
        )),

        Source_Code::Factorization : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    factors : [\Tuple::(), \all_attr_assets::( 1: \Expression::() )],
                    returns : \Expression::(),
                )
            ),
            default : (\@material : (factors : (), returns : (\@Literal : (False,)))),
        )),

        Source_Code::Expansion : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    factor : \Attr_Name::(),
                )
            ),
            default : (\@material : (factor : \"",)),
        )),

        Source_Code::Statement : (\Function : (
            is_type_definer : True,
            evaluates : {
                \@Performs,
                \@If_Then_Else_Stmt,
                \@Given_When_Default_Stmt,
                \@Block,
                \@Leave,
                \@Iterate,
                \@Declare,
            },
            default : (\@Block : ([],)),
        )),

        Source_Code::Performs : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                )
            ),
            default : (\@material : ...),
        )),

        Source_Code::If_Then_Else_Stmt : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                    1 : \Statement::(),
                    2 : \Statement::(),
                )
            ),
            default : (\@material : ((\@Literal : (False,)),
                (\@Block : ([],)), (\@Block : ([],)))),
        )),

        Source_Code::Given_When_Default_Stmt : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Expression::(),
                    1 : [\Set::(), \all::( 1: (
                        0 : \Expression::(),
                        1 : \Statement::(),
                    ) )],
                    2 : \Statement::(),
                )
            ),
            default : (\@material : ((\@Literal : (False,)),
                {}, (\@Block : ([],)))),
        )),

        Source_Code::Block : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (\@Signature::Tuple_Attrs_Match : (
                    0 : (type : [\Array::(), \all::( 1: \Statement::() )]),
                    label : (type : \Attr_Name::(), optional : True),
                ))
            ),
            default : (\@material : ([],)),
        )),

        Source_Code::Leave : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (\@Signature::Tuple_Attrs_Match : (
                    label : (type : \Attr_Name::(), optional : True),
                ))
            ),
            default : (\@material : ()),
        )),

        Source_Code::Iterate : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (\@Signature::Tuple_Attrs_Match : (
                    label : (type : \Attr_Name::(), optional : True),
                ))
            ),
            default : (\@material : ()),
        )),

        Source_Code::Declare : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    0 : \Attr_Name::(),
                )
            ),
            default : (\@material : (\"",)),
        )),

        Source_Code::Heading : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \all_attr_assets::( 1: \False::() )],
        )),

        Source_Code::Attr_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Heading::(), \is_unary::()],
        )),

        Source_Code::Attr_Name_List : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(), \all::( 1: \Attr_Name::() )],
        )),

        Source_Code::Local_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Attr_Name_List::(), \so::(), \(
                given args:.\0.0
                    when \foundation then #args:.\0 = 2
                    when \used       then #args:.\0 ≥ 2  `elem 2 is pkg local alias`
                    when \package    then #args:.\0 ≥ 1
                    when \folder     then #args:.\0 ≥ 1
                    when \material   then #args:.\0 = 1
                    when \floating   then #args:.\0 ≥ 2
                    default False
            )],
            default : [\foundation, ...],
        )),

        Source_Code::Absolute_Name : (\Function : (
            is_type_definer : True,
            evaluates : (Local_Name args:.\0 and_then guard
                args:.\0.0 ⊆@ \@(foundation,used,package)),
        )),

        Source_Code::Function_Call : (\Function : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    func : {\Local_Name::(), \Function::()},
                    args : \Tuple::(),
                )
            ),
            default : (\@material : (
                func : (\Function : (evaluates : (False))),
                args : (),
            )),
        )),

        Source_Code::Function_Call_But_0 : (\Function : (
            is_type_definer : True,
            evaluates : (Function_Call args:.\0 and_then guard
                args:.\0.\args disjoint_heading \0),
        )),

        Source_Code::Function_Call_But_0_1 : (\Function : (
            is_type_definer : True,
            evaluates : (Function_Call args:.\0 and_then guard
                args:.\0.\args disjoint_heading \@(0..1)),
        )),

        Source_Code::Procedure_Call : (\Procedure : (
            is_type_definer : True,
            evaluates : (
                Capsule args:.\0
                and_then guard args:.\0:< = \@material
                and_then guard args:.\0:> is_a (
                    proc : {\Local_Name::(), \Procedure::()},
                    args : \Tuple::(),
                )
            ),
            default : (\@material : (
                proc : (\Procedure : (performs : [])),
                args : (),
            )),
        )),

        Source_Code::Key_Asset_Pair : (\Function : (
            is_type_definer : True,
            evaluates : (Tuple args:.\0 and_then guard
                @args:.\0 = \@(key,asset)),
        )),

        Source_Code::Signature_to_Function_Call_But_0 : (\Function : (
            returns : \@Function_Call_But_0,
            matches : (\@Signature),
            evaluates : (
                sig ::= args:.\0;
                returns
                    if Function_Call_But_0 sig then
                        sig
                    else if Signature::Conjunction sig then guard
                        \(
                            topic    ::= args:.\0;
                            conj_sig ::= args:.\sig;
                            returns empty::(conj_sig)
                                or_else guard topic is_a first::(conj_sig)
                                and_then guard topic is_a nonfirst::(conj_sig)
                        ) \<-- (:sig,)
                    else if Signature::Disjunction sig then guard
                        \(
                            topic    ::= args:.\0;
                            disj_sig ::= args:.\sig;
                            returns disj_sig any \(args:.\topic is_a args:.\0) \<-- (:topic,)
                        ) \<-- (:sig,)
                    else if Signature::Tuple_Attrs_Match_Simple sig then guard
                        \(
                            topic     ::= args:.\0;
                            tuple_sig ::= args:.\sig;
                            returns Tuple topic
                                and_then guard topic =@ tuple_sig
                                and_then guard
                                    tuple_sig all_attrs \(
                                        name     ::= args:.\0:.\name;
                                        attr_sig ::= args:.\0:.\asset;
                                        topic    ::= args:.\topic;
                                        returns topic.name is_a attr_sig;
                                    ) \<-- (:topic,)
                        ) \<-- (:sig,)
                    else if Signature::Tuple_Attrs_Match sig then guard
                        \(
                            topic     ::= args:.\0;
                            tuple_sig ::= args:.\sig;
                            returns Tuple topic
                                and_then guard
                                    topic ⊆@ tuple_sig
                                    and
                                    (tuple_sig all_attrs \(
                                        name     ::= args:.\0:.\name;
                                        attr_sig ::= args:.\0:.\asset;
                                        topic    ::= args:.\topic;
                                        returns if topic.?name
                                            then guard topic.name is_a attr_sig
                                            else attr_sig.?\optional
                                        ;
                                    ) \<-- (:topic,))
                        ) \<-- (:sig,)
                    else
                        fail  `We should never get here.`
                    ;
            ),
        )),

`#########################################################################`

        Source_Code::Annotation::"" : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

`#########################################################################`

        Source_Code::Decoration::"" : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

`#########################################################################`

    ),
))

`#########################################################################`
`#########################################################################`
