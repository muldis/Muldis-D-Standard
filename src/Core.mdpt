Muldis_D:Plain_Text:"http://muldis.com":"0.201.0.-9";
script Unicode:8.0:UTF-8;

`#########################################################################`
`#########################################################################`

package
{
    identity MD ::= Core:"http://muldis.com":"0.201.0.-9";
    foundation "http://muldis.com":"0.201.0.-9";
    floating {::MD, ::MD::Round_Meth, ::MD::Capsule, ::MD::Source_Code};

`#########################################################################`

    ::MD::Any ::= selection default (False);

    ::MD::None ::= selection of {};

    ::MD::same ::= function --> Boolean <-- (Any, Any)
        is commutative
        : (\<*args -->^ FDN__same);

    ::MD::"=" ::= alias of same;

    ::MD::not_same ::= function negates same
        is commutative;

    ::MD::"!=" ::= alias of not_same;

    ::MD::Unicode_Aliases::"≠" ::= alias of not_same;

    ::MD::is_a ::= function --> Boolean <-- (Any, Contract_Name)
        : ((\<0,) --> (\Function_Call wrap (func: \<1, args: ())));

    ::MD::not_is_a ::= function negates is_a;

    ::MD::default ::= function --> Any <-- (Contract_Name)
        : (() --> (\Function_Call wrap (func: \<0, args: ())));

`#########################################################################`

    ::MD::Excuse::"" ::= interface;

    ::MD::Excuse::No_Reason ::= constant
        composes Excuse and_provides_its_default;

    ::MD::or_else ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (Excuse \<0 ?? \<1 !! \<0);

    ::MD::coalesce ::= alias of or_else;

    ::MD::and_then ::= function --> Any <-- (Any, Any)
        is {associative,idempotent}
        : (Excuse \<0 ?? \<0 !! \<1);

`#########################################################################`

    ::MD::Orderable ::= interface
        requires_implements in_order;

    ::MD::Neg_Inf ::= constant composes {Orderable, Excuse};

    ::MD::Unicode_Aliases::"-∞" ::= alias of Neg_Inf;

    ::MD::Pos_Inf ::= constant composes {Orderable, Excuse};

    ::MD::Unicode_Aliases::"+∞" ::= alias of Pos_Inf;

    ::MD::in_order::"" ::= function virtual
        --> Boolean <-- (Orderable, Orderable);

    ::MD::in_order::Neg_Inf_L ::= function --> Boolean <-- (Neg_Inf, Orderable)
        implements 2::""
        : (True);

    ::MD::in_order::Neg_Inf_R ::= function --> Boolean <-- (Orderable, Neg_Inf)
        implements 2::""
        : (\<*args --> \same::());

    ::MD::in_order::Pos_Inf_L ::= function --> Boolean <-- (Pos_Inf, Orderable)
        implements 2::""
        : (\<*args --> \same::());

    ::MD::in_order::Pos_Inf_R ::= function --> Boolean <-- (Orderable, Pos_Inf)
        implements 2::""
        : (True);

    ::MD::before ::= function commutes after;

    ::MD::"<" ::= alias of before;

    ::MD::after ::= function negates before_or_same;

    ::MD::">" ::= alias of after;

    ::MD::before_or_same ::= alias of in_order;

    ::MD::"<=" ::= alias of before_or_same;

    ::MD::Unicode_Aliases::"≤" ::= alias of before_or_same;

    ::MD::after_or_same ::= function commutes before_or_same;

    ::MD::">=" ::= alias of after_or_same;

    ::MD::Unicode_Aliases::"≥" ::= alias of after_or_same;

    ::MD::min ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (+∞)
        : (\<*args --> \in_order::() ?? \<0 !! \<1);

    ::MD::max ::= function --> Orderable <-- (Orderable, Orderable)
        is {associative,commutative,idempotent} identity (-∞)
        : (\<*args --> \in_order::() ?? \<1 !! \<0);

    ::MD::minmax ::= function
        --> (Orderable, Orderable) <-- (Orderable, Orderable)
        is commutative
        : (\<*args --> \in_order::() ?? \<*args !! (\<1, \<0));

`#########################################################################`

    ::MD::Successable ::= interface
        requires_implements {asset,succ};

    ::MD::asset::"" ::= function virtual --> Any <-- (Successable);

    ::MD::succ::"" ::= function virtual
        --> {Successable, Pos_Inf} <-- (Successable);

    ::MD::nth_succ ::= function
        --> {Successable, Pos_Inf} <-- (Successable, Integer_NN)
    : (
        if !?\<1 then
            \<0
        else
            if Excuse::(s ::= succ \<0) then
                s
            else
                s nth_succ --\<1
    );

`#########################################################################`

    ::MD::Bicessable ::= interface
        composes {Orderable and_provides_its_default,
            Successable and_provides_its_default}
        requires_implements {in_order,asset,pred,succ};

    ::MD::pred::"" ::= function virtual
        --> {Bicessable, Neg_Inf} <-- (Bicessable);

    ::MD::nth_pred ::= function
        --> {Bicessable, Neg_Inf} <-- (Bicessable, Integer_NN)
    : (
        if !?\<1 then
            \<0
        else
            if Excuse::(s ::= pred \<0) then
                s
            else
                s nth_pred --\<1
    );

`#########################################################################`

    ::MD::Boolable ::= interface requires_implements to_Boolean;

    ::MD::to_Boolean::"" ::= function virtual --> Boolean <-- (Boolable);

    ::MD::so  ::= alias of to_Boolean;
    ::MD::"?" ::= alias of to_Boolean;

    ::MD::not_so ::= function negates to_Boolean;

    ::MD::"!?" ::= alias of not_so;

`#########################################################################`

    ::MD::Boolean ::= selection where (\<*args -->^ FDN__is_a_Boolean)
        default (False)
        composes {Bicessable, Boolable and_provides_its_default};

    ::MD::Bool ::= alias of Boolean;

    ::MD::False ::= constant (False);

    ::MD::Unicode_Aliases::"⊥" ::= alias of False;

    ::MD::True ::= constant (True);

    ::MD::Unicode_Aliases::"⊤" ::= alias of True;

    ::MD::in_order::Boolean ::= function --> Boolean <-- (Boolean, Boolean)
        implements 2::""
        : (!\<0 or \<1);

    ::MD::asset::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\<0);

    ::MD::pred::Boolean ::= function --> {False, Neg_Inf} <-- (Boolean)
        implements 2::""
        : (\<0 ?? False !! -∞);

    ::MD::succ::Boolean ::= function --> {True, Pos_Inf} <-- (Boolean)
        implements 2::""
        : (!\<0 ?? True !! +∞);

    ::MD::to_Boolean::Boolean ::= function --> Boolean <-- (Boolean)
        implements 2::""
        : (\<0);

    ::MD::not ::= function negates to_Boolean::Boolean;

    ::MD::"!" ::= alias of not;

    ::MD::Unicode_Aliases::"¬" ::= alias of not;

    ::MD::and ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (True)
        : (\<0 ?? \<1 !! False);

    ::MD::Unicode_Aliases::"∧" ::= alias of and;

    ::MD::nand ::= function negates and
        is commutative;

    ::MD::not_and ::= alias of nand;

    ::MD::Unicode_Aliases::"⊼" ::= alias of nand;
    ::MD::Unicode_Aliases::"↑" ::= alias of nand;

    ::MD::or ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative,idempotent} identity (False)
        : (\<0 ?? True !! \<1);

    ::MD::Unicode_Aliases::"∨" ::= alias of or;

    ::MD::nor ::= function negates or
        is commutative;

    ::MD::not_or ::= alias of nor;

    ::MD::Unicode_Aliases::"⊽" ::= alias of nor;
    ::MD::Unicode_Aliases::"↓" ::= alias of nor;

    ::MD::xnor ::= function --> Boolean <-- (Boolean, Boolean)
        is {associative,commutative} identity (True)
        : (\<*args --> \same::());

    ::MD::iff ::= alias of xnor;

    ::MD::Unicode_Aliases::"↔" ::= alias of xnor;

    ::MD::xor ::= function negates xnor
        is {associative,commutative} identity (False);

    ::MD::Unicode_Aliases::"⊻" ::= alias of xor;
    ::MD::Unicode_Aliases::"↮" ::= alias of xor;

    ::MD::imp ::= function --> Boolean <-- (Boolean, Boolean)
        : (\<0 ?? \<1 !! True);

    ::MD::implies ::= alias of imp;

    ::MD::Unicode_Aliases::"→" ::= alias of imp;

    ::MD::nimp ::= function negates imp;

    ::MD::not_implies ::= alias of nimp;

    ::MD::Unicode_Aliases::"↛" ::= alias of nimp;

    ::MD::if ::= function commutes imp;

    ::MD::Unicode_Aliases::"←" ::= alias of if;

    ::MD::nif ::= function commutes nimp;

    ::MD::not_if ::= alias of nif;

    ::MD::Unicode_Aliases::"↚" ::= alias of nif;

`#########################################################################`

    ::MD::Round_Meth ::= enumeration
        union {Down,Up,To_Zero,To_Inf
            ,Half_Down,Half_Up,Half_To_Zero,Half_To_Inf
            ,Half_Even,Half_Odd}
        default To_Zero;

`#########################################################################`

    ::MD::Numerical ::= interface
        composes Boolable
        requires_implements {to_Boolean
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power};

    ::MD::Excuse::Div_By_Zero ::= constant composes Excuse;

    ::MD::Excuse::Zero_To_The_Zero ::= constant composes Excuse;

    ::MD::to_Boolean::Numerical ::= function virtual --> Boolean <-- (Numerical)
        implements 2::"";

    ::MD::is_zero ::= function negates to_Boolean::Numerical;

    ::MD::zero::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::opposite::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::additive_inverse ::= alias of opposite;

    ::MD::reciprocal::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical);

    ::MD::multiplicative_inverse ::= alias of reciprocal;

    ::MD::modulus::"" ::= function virtual --> Numerical <-- (Numerical);

    ::MD::abs ::= alias of modulus;

    ::MD::plus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater times;

    ::MD::"+" ::= alias of plus;

    ::MD::minus::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical);

    ::MD::"-" ::= function
        --> Numerical <-- {(Numerical), (Numerical, Numerical)}
        : (\<*args --> (degree::(\<*args) = 1 ?? \opposite::() !! \minus::()));

    ::MD::Unicode_Aliases::"−" ::= alias of "-";

    ::MD::modulus_minus ::= function
        --> Numerical <-- (Numerical, Numerical)
        is commutative
        : (modulus \<*args --> \minus::());

    ::MD::abs_minus ::= alias of modulus_minus;
    ::MD::"|-|"     ::= alias of modulus_minus;

    ::MD::Unicode_Aliases::"|−|" ::= alias of modulus_minus;

    ::MD::times::"" ::= function virtual
        --> Numerical <-- (Numerical, Numerical)
        is {associative,commutative}
        repeater integral_nn_power;

    ::MD::"*" ::= alias of times;

    ::MD::Unicode_Aliases::"×" ::= alias of times;

    ::MD::multiple_of::"" ::= function virtual
        --> {Boolean, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

    ::MD::nearest_multiple_of ::= function
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth)
        : (if \<1->is_zero then Excuse::Div_By_Zero()
            else \<1 * \<*args --> \div::());

    ::MD::round ::= alias of nearest_multiple_of;

    ::MD::fractional_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero} <-- (Numerical, Numerical);

    ::MD::"/" ::= alias of fractional_divided_by;

    ::MD::Unicode_Aliases::"÷" ::= alias of fractional_divided_by;
    ::MD::Unicode_Aliases::"∕" ::= alias of fractional_divided_by;

    ::MD::integral_divided_by::"" ::= function virtual
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth);

    ::MD::div ::= alias of integral_divided_by;

    ::MD::modulo ::= function
        --> {Numerical, Excuse::Div_By_Zero}
        <-- (Numerical, Numerical, Round_Meth)
        : (if \<1->is_zero then Excuse::Div_By_Zero()
            else \<0 - \<*args --> \nearest_multiple_of::());

    ::MD::mod ::= alias of modulo;

    ::MD::divided_by_and_modulo::"" ::= function
        --> ({Numerical, Excuse::Div_By_Zero}, {Numerical, Excuse::Div_By_Zero})
        <-- (Numerical, Numerical, Round_Meth)
        : ((\<*args --> \div::(), \<*args --> \mod::()));

    ::MD::integral_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral);

    ::MD::"**" ::= alias of integral_power;

    ::MD::integral_nn_power::"" ::= function virtual
        --> {Numerical, Excuse::Zero_To_The_Zero} <-- (Numerical, Integral_NN);

    ::MD::power ::= alias of integral_nn_power;

`#########################################################################`

    ::MD::Integral ::= interface
        composes {Bicessable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order,asset,pred,succ
            ,to_Boolean
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,to_Integer,factorial};

    ::MD::Integral_NN ::= selection of Integral
        where (\<0 >= zero::(\<0));

    ::MD::Integral_P ::= selection of Integral_NN
        where (\<0 > zero::(\<0)) default (succ::(Integral::()));

    ::MD::pred::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"--" ::= alias of pred::Integral;

    ::MD::succ::Integral ::= function virtual --> Integral <-- (Integral)
        implements 2::"";

    ::MD::"++" ::= alias of succ::Integral;

    ::MD::to_Integer::"" ::= function virtual --> Integer <-- (Integral);

    ::MD::factorial::"" ::= function virtual --> Integral_P <-- (Integral_NN);

    ::MD::gcd ::= function --> Integral_P <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : ((if \<1->is_zero then \<0 else 0::(\<1, mod::(\<0, \<1, To_Zero::())))
            ::?= 'Calculate using the Euclidean algorithm.');

    ::MD::greatest_common_divisor ::= alias of gcd;

    ::MD::lcm ::= function --> Integral_NN <-- (Integral_NN, Integral_NN)
        is {commutative,associative,idempotent}
        : (if \<0->is_zero or \<1->is_zero then \<0->zero
            else div::(\<0 * \<1, \<0 gcd \<1, To_Zero::()));

    ::MD::least_common_multiple ::= alias of lcm;

    ::MD::coprime ::= function --> Boolean <-- (Integral, Integral)
        : ((abs::(\<0) gcd abs::(\<1)) = (\<0->zero->succ));

`#########################################################################`

    ::MD::Integer ::= selection where (\<*args -->^ FDN__is_a_Integer)
        default (0)
        composes Integral and_provides_its_default;

    ::MD::Integer_NN ::= selection of Integer where (\<0 >= 0);

    ::MD::Integer_P ::= selection of Integer_NN where (\<0 > 0) default (1);

    ::MD::in_order::Integer ::= function --> Boolean <-- (Integer, Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_in_order);

    ::MD::asset::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\<0);

    ::MD::pred::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        : (\<0 - 1);

    ::MD::succ::Integer ::= function --> Integer <-- (Integer)
        implements 2::Integral
        repeater plus::Integer
        : (\<0 + 1);

    ::MD::to_Boolean::Integer ::= function --> Boolean <-- (Integer)
        implements 2::""
        : (\<0 != 0);

    ::MD::zero::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (0);

    ::MD::opposite::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_opposite);

    ::MD::reciprocal::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer)
        implements 2::""
        : (1 / \<0);

    ::MD::modulus::Integer ::= function --> Integer_NN <-- (Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_modulus);

    ::MD::plus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (0)
        repeater times::Integer
        : (\<*args -->^ FDN__Integer_plus);

    ::MD::minus::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        : (\<*args -->^ FDN__Integer_minus);

    ::MD::times::Integer ::= function --> Integer <-- (Integer, Integer)
        implements 2::""
        is {associative,commutative} identity (1)
        repeater integral_nn_power::Integer
        : (\<*args -->^ FDN__Integer_times);

    ::MD::multiple_of::Integer ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \<1 = 0 then Excuse::Div_By_Zero()
            else \<*args -->^ FDN__Integer_multiple_of);

    ::MD::fractional_divided_by::Integer ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Integer, Integer)
        implements 2::""
    : (
        n ::= \<0;
        d ::= \<1;

        <-- if d = 0 then Excuse::Div_By_Zero() else q;

        q ::= (\Fraction wrap (
            numerator   : div::((d > 0 ?? n !! -n), gcd, To_Zero::()),
            denominator : div::((d > 0 ?? d !! -d), gcd, To_Zero::()),
        ));

        gcd ::= gcd::(abs::(n), abs::(d));
    );

    ::MD::integral_divided_by::Integer ::= function
        --> {Integer, Excuse::Div_By_Zero}
        <-- (Integer, Integer, Round_Meth)
        implements 2::""
    : (
        dividend   ::= \<0;
        divisor    ::= \<1;
        round_meth ::= \<2;

        <-- if divisor = 0 then Excuse::Div_By_Zero() else e1;

        e1 ::?= 'This is the case where we are dividing by a non-zero.';

        e1 ::= (
               dividend = 0       ?? 0
            !! divisor  = 1       ?? dividend
            !! dividend = divisor ?? 1
            !! divisor  = -1      ?? -dividend
            !!                       e2
        );

        e2 ::?= 'This is the case where the divisor and dividend do not'
            ' equal each other and neither of them is a zero or a one.';

        e2 ::= (
            real_q_is_neg ::= (dividend < 0 xor divisor < 0);
            rtz_quotient  ::= (FDN__Integer_divided_by_rtz
                ^<-- (dividend, divisor));
            rtz_remainder ::= (dividend - (divisor * rtz_quotient));

            <-- rtz_remainder = 0 ?? rtz_quotient !! e3;
        );

        e3 ::?= 'This is the case where the divisor does not divide the'
            ' dividend evenly and the real number division result would'
            ' have a fractional part, so we decide how to round that.';

        e3 ::= (
            rti_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 1));
            rdn_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 0));
            rup_quotient ::= (rtz_quotient + (real_q_is_neg ??  0 !! 1));

            <-- round_meth ??? {
                Down::()    : rdn_quotient,
                Up::()      : rup_quotient,
                To_Zero::() : rtz_quotient,
                To_Inf::()  : rti_quotient,
            } !!!
                   (2 * abs::(rtz_remainder)) < abs::(divisor) ?? rtz_quotient
                !! (2 * abs::(rtz_remainder)) > abs::(divisor) ?? rti_quotient
                !! e4
            ;
        );

        e4 ::?= 'This is the case where real division remainder is'
            ' exactly one-half so we decide how to round that.';

        e4 ::= (
            q ::= (FDN__Integer_divided_by_rtz ^<-- (abs::(rtz_quotient),2))
            r ::= (abs::(rtz_quotient) - (2 * q));
            rtz_quotient_is_even ::= (r = 0);

            <-- round_meth ??? {
                Half_Down::()    : rdn_quotient,
                Half_Up::()      : rup_quotient,
                Half_To_Zero::() : rtz_quotient,
                Half_To_Inf::()  : rti_quotient,
                Half_Even::()    :
                  (rtz_quotient_is_even ?? rtz_quotient !! rti_quotient),
                Half_Odd::()     :
                  (rtz_quotient_is_even ?? rti_quotient !! rtz_quotient),
            } !!! fail  `oops, an unhandled case`
        );
    );

    ::MD::integral_power::Integer ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Integer, Integer)
        implements 2::""
        : (if \<0 = 0 and \<1 = 0 then Excuse::Zero_To_The_Zero()
            else \<0 / 1 ** \<1);

    ::MD::integral_nn_power::Integer ::= function
        --> {Integer, Excuse::Zero_To_The_Zero} <-- (Integer, Integer_NN)
        implements 2::""
        : (if \<0 = 0 and \<1 = 0 then Excuse::Zero_To_The_Zero()
            else \<*args -->^ FDN__Integer_nn_power);

    ::MD::to_Integer::Integer ::= function --> Integer <-- (Integer)
        implements 2::""
        : (\<0);

    ::MD::factorial::Integer ::= function --> Integer_P <-- (Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Integer_factorial);

`#########################################################################`

    ::MD::Fractional ::= interface
        composes {Orderable and_provides_its_default,
            Numerical and_provides_its_default}
        requires_implements {in_order
            ,to_Boolean
            ,zero,opposite,reciprocal,modulus
            ,plus,minus,times,multiple_of
            ,fractional_divided_by,integral_divided_by
            ,integral_power,integral_nn_power
            ,to_Fraction,numerator,denominator};

    ::MD::Fractional_NN ::= selection of Fractional
        where (\<0 >= zero::(\<0));

    ::MD::to_Fraction::"" ::= function virtual --> Fraction <-- (Fractional);

    ::MD::numerator::"" ::= function virtual --> Integral <-- (Fractional);

    ::MD::denominator::"" ::= function virtual --> Integral_P <-- (Fractional);

`#########################################################################`

    ::MD::Fraction ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Fraction, \1::_Asset() ))
            default (0.0)
            composes Fractional and_provides_its_default;

        _Asset ::= selection of Tuple where
        (
            if
                \<0 has_just_attrs (
                    numerator : \Integer::(),
                    denominator : \Integer_P::(),
                )
            then
                \<<numerator coprime \<<denominator
            else
                False
        );
    };

    ::MD::Fraction_NN ::= selection of Fraction where (\<0 >= 0.0);

    ::MD::in_order::Fraction ::= function --> Boolean <-- (Fraction, Fraction)
        implements 2::""
    : (
        <-- (\<0->denominator) = (\<1->denominator)
            ?? in_order::(\<0->numerator, \<1->numerator)
         !!
          (
            common_d ::= lcm::(\<0->denominator, \<1->denominator);
            <-- in_order::(
                (\<0->numerator) * div::(common_d, \<0->denominator, To_Zero::()),
                (\<1->numerator) * div::(common_d, \<1->denominator, To_Zero::()),
            );
          )
    );

    ::MD::to_Boolean::Fraction ::= function --> Boolean <-- (Fraction)
        implements 2::""
        : (\<0 != 0.0);

    ::MD::zero::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (0.0);

    ::MD::opposite::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (-(\<0->numerator) / (\<0->denominator));

    ::MD::reciprocal::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction)
        implements 2::""
        : (if \<0 = 0.0 then Excuse::Div_By_Zero()
            else (\<0->denominator) / (\<0->numerator));

    ::MD::modulus::Fraction ::= function --> Fraction_NN <-- (Fraction)
        implements 2::""
        : (abs::(\<0->numerator) / (\<0->denominator));

    ::MD::plus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (0.0)
        repeater times::Fraction_Integer
    : (
        <-- (\<0->denominator) = (\<1->denominator)
            ?? (\<0->numerator) + (\<1->numerator) / (\<0->denominator)
         !!
          (
            common_d ::= lcm::(\<0->denominator, \<1->denominator);
            <-- ((\<0->numerator) * div::(common_d, \<0->denominator, To_Zero::()))
                + ((\<1->numerator) * div::(common_d, \<1->denominator, To_Zero::()))
                / common_d;
          )
    );

    ::MD::minus::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        : (\<0 + (-\<1));

    ::MD::times::Fraction ::= function --> Fraction <-- (Fraction, Fraction)
        implements 2::""
        is {associative,commutative} identity (1.0)
        repeater integral_nn_power::Fraction
        : (((\<0->numerator) * (\<1->numerator))
            / ((\<0->denominator) * (\<1->denominator)));

    ::MD::times::Fraction_Integer ::= function
        --> Fraction <-- (Fraction, Integer)
        implements 2::""
        : (((\<0->numerator) * \<1) / (\<0->denominator));

    ::MD::multiple_of::Fraction ::= function
        --> {Boolean, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \<1 = 0.0 then Excuse::Div_By_Zero()
            else \mod::() <-- \<*args = 0.0);

    ::MD::fractional_divided_by::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero} <-- (Fraction, Fraction)
        implements 2::""
        : (if \<1 = 0.0 then Excuse::Div_By_Zero()
            else \<0 * reciprocal::(\<1));

    ::MD::integral_divided_by::Fraction ::= function
        --> {Fraction, Excuse::Div_By_Zero}
        <-- (Fraction, Fraction, Round_Meth)
        implements 2::""
    : (
        d ::= lcm::(\<0->denominator, \<1->denominator);
        n0 ::= ((\<0->numerator) * div::(d, \<0->denominator, To_Zero::()));
        n1 ::= ((\<1->numerator) * div::(d, \<1->denominator, To_Zero::()));
        <-- if \<1 = 0.0 then Excuse::Div_By_Zero()
            else div::(n0 * d, n1 * d, \<2) / 1;
    );

    ::MD::integral_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer)
        implements 2::""
        : (\integral_nn_power::()
            <-- (\<1 >= 0 ?? \<*args !! (reciprocal::(\<0), -\<1)));

    ::MD::integral_nn_power::Fraction ::= function
        --> {Fraction, Excuse::Zero_To_The_Zero} <-- (Fraction, Integer_NN)
        implements 2::""
        : (if \<0 = 0.0 and \<1 = 0 then Excuse::Zero_To_The_Zero()
            else ((\<0->numerator) ** \<1) / ((\<0->denominator) ** \<1));

    ::MD::to_Fraction::Fraction ::= function --> Fraction <-- (Fraction)
        implements 2::""
        : (\<0);

    ::MD::numerator::Fraction ::= function --> Integer <-- (Fraction)
        : (unwrap::(\<0).\numerator);

    ::MD::denominator::Fraction ::= function --> Integer_P <-- (Fraction)
        : (unwrap::(\<0).\denominator);

`#########################################################################`

    ::MD::Emptyable ::= interface
        composes Boolable
        requires_implements {to_Boolean,empty};

    ::MD::Excuse::No_Empty_Value ::= constant composes Excuse;

    ::MD::to_Boolean::Emptyable ::= function virtual --> Boolean <-- (Emptyable)
        implements 2::"";

    ::MD::has_any_members ::= alias of to_Boolean::Emptyable;

    ::MD::is_empty ::= function negates to_Boolean::Emptyable;

    ::MD::Unicode_Aliases::"∅?" ::= alias of is_empty;

    ::MD::empty::"" ::= function virtual
        --> {Emptyable, Excuse::No_Empty_Value} <-- (Emptyable);

    ::MD::Unicode_Aliases::"∅" ::= alias of empty;

`#########################################################################`

    ::MD::Stringy ::= interface
        composes {Orderable, Emptyable and_provides_its_default}
        requires_implements {in_order,to_Boolean,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate};

    ::MD::substring_of::"" ::= function virtual
        --> Boolean <-- (Stringy, Stringy);

    ::MD::superstring_of ::= function commutes substring_of;

    ::MD::proper_substring_or_superstring ::= function
        --> Boolean <-- (String, String)
        is commutative
        : (\<*args --> \not_same::() and \<*args --> \substring_or_superstring::());

    ::MD::substring_or_superstring ::= function
        --> Boolean <-- (String, String)
        is commutative
        : (\<*args --> \substring_of::() or \<*args --> \superstring_of::());

    ::MD::overlaps_string::"" ::= function virtual
        --> Boolean <-- (String, String)
        is commutative;

    ::MD::disjoint_string::"" ::= function virtual
        --> Boolean <-- (String, String)
        is commutative;

    ::MD::catenate::"" ::= function virtual
        --> Stringy <-- (Stringy, Stringy)
        is associative
        repeater replicate;

    ::MD::"~" ::= alias of catenate;

    ::MD::replicate::"" ::= function virtual
        --> Stringy <-- (Stringy, Integer_NN);

    ::MD::"~#" ::= alias of replicate;

`#########################################################################`

    ::MD::Bits ::= ::= selection of Capsule
        where (has_wrapped::( \<0, \Bits, \String::Bits() ))
        default (\~?'')
        composes {Stringy and_provides_its_default};

    ::MD::String::Bits ::= selection of String
        where (\<0 all (function : (\<0 in 0..1)));

    ::MD::in_order::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        : ((\<0->Bits_to_String_Bits) in_order (\<1->Bits_to_String_Bits));

    ::MD::to_Boolean::Bits ::= function --> Boolean <-- (Bits)
        implements 2::""
        : (\<0 != \~?'');

    ::MD::empty::Bits ::= function --> Bits <-- (Bits)
        implements 2::""
        : (\~?'');

    ::MD::substring_of::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        : ((\<0->Bits_to_String_Bits) substring_of (\<1->Bits_to_String_Bits));

    ::MD::overlaps_string::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        is commutative
        : ((\<0->Bits_to_String_Bits)
            overlaps_string (\<1->Bits_to_String_Bits));

    ::MD::disjoint_string::Bits ::= function --> Boolean <-- (Bits, Bits)
        implements 2::""
        is commutative
        : ((\<0->Bits_to_String_Bits)
            disjoint_string (\<1->Bits_to_String_Bits));

    ::MD::catenate::Bits ::= function --> Bits <-- (Bits, Bits)
        implements 2::""
        is associative identity (\~?'')
        repeater replicate::Bits
        : (Bits_from_String_Bits::((\<0->Bits_to_String_Bits)
            ~ (\<1->Bits_to_String_Bits)));

    ::MD::replicate::Bits ::= function --> Bits <-- (Bits, Integer_NN)
        implements 2::""
        : (Bits_from_String_Bits::((\<0->Bits_to_String_Bits) ~# \<1));

    ::MD::Bits_from_String_Bits ::= function --> Bits <-- (String::Bits)
        : (\Bits wrap \<0);

    ::MD::Bits_to_String_Bits ::= function --> String::Bits <-- (Bits)
        : (\<0->unwrap);

`#########################################################################`

    ::MD::Blob::"" ::= selection of Capsule
        where (has_wrapped::( \<0, \Blob, \String::Octets() ))
        default (\~+'')
        composes Stringy;

    ::MD::String::Octets ::= selection of String
        where (\<0 all (function : (\<0 in 0..255)));

    ::MD::in_order::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        : ((\<0->Blob_to_Octets) in_order (\<1->Blob_to_Octets));

    ::MD::to_Boolean::Blob ::= function --> Boolean <-- (Blob)
        implements 2::""
        : (\<0 != \~+'');

    ::MD::empty::Blob ::= function --> Blob <-- (Blob)
        implements 2::""
        : (\~+'');

    ::MD::substring_of::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        : ((\<0->Blob_to_Octets) substring_of (\<1->Blob_to_Octets));

    ::MD::overlaps_string::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        is commutative
        : ((\<0->Blob_to_Octets) overlaps_string (\<1->Blob_to_Octets));

    ::MD::disjoint_string::Blob ::= function --> Boolean <-- (Blob, Blob)
        implements 2::""
        is commutative
        : ((\<0->Blob_to_Octets) disjoint_string (\<1->Blob_to_Octets));

    ::MD::catenate::Blob ::= function --> Blob <-- (Blob, Blob)
        implements 2::""
        is associative identity (\~+'')
        repeater replicate::Blob
        : (Blob_from_Octets::((\<0->Blob_to_Octets) ~ (\<1->Blob_to_Octets)));

    ::MD::replicate::Blob ::= function --> Blob <-- (Blob, Integer_NN)
        implements 2::""
        : (Blob_from_Octets::((\<0->Blob_to_Octets) ~# \<1));

    ::MD::Blob_from_Octets ::= function --> Blob <-- (String::Octets)
        : (\Blob wrap \<0);

    ::MD::Blob_to_Octets ::= function --> String::Octets <-- (Blob)
        : (\<0->unwrap);

`#########################################################################`

    ::MD::Textual ::= interface
        composes Stringy
        requires_implements {in_order,to_Boolean,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate
            ,to_Text};

    ::MD::to_Text::"" ::= function virtual --> Text <-- (Textual);

`#########################################################################`

    ::MD::Text::"" ::= selection of Capsule
        where (has_wrapped::( \<0, \Text, \String::Maximal_Chars() ))
        default ('')
        composes {Textual and_provides_its_default};

    ::MD::String::Maximal_Chars ::= alias of String;

    ::MD::Text::Unicode ::= selection of Text
        where (String::Unicode_Codes::(\<0->Text_from_Maximal_Chars));

    ::MD::String::Unicode_Codes ::= selection of String::Maximal_Chars
        where (\<0 all (function : (\<0 in ?..{0..0xD7FF,0xE000..0x10FFFF})));

    ::MD::Text::ASCII ::= selection of Text::Unicode
        where (String::ASCII_Chars::(\<0->Text_from_Unicode_Codes));

    ::MD::String::ASCII_Chars ::= selection of String::Unicode_Codes
        where (\<0 all (function : (\<0 in 0..127)));

    ::MD::in_order::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        : ((\<0->Text_to_Maximal_Chars) in_order (\<1->Text_to_Maximal_Chars));

    ::MD::to_Boolean::Text ::= function --> Boolean <-- (Text)
        implements 2::""
        : (\<0 != '');

    ::MD::empty::Text ::= function --> Text <-- (Text)
        implements 2::""
        : ('');

    ::MD::substring_of::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        : ((\<0->Text_to_Maximal_Chars)
            substring_of (\<1->Text_to_Maximal_Chars));

    ::MD::overlaps_string::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        is commutative
        : ((\<0->Text_to_Maximal_Chars)
            overlaps_string (\<1->Text_to_Maximal_Chars));

    ::MD::disjoint_string::Text ::= function --> Boolean <-- (Text, Text)
        implements 2::""
        is commutative
        : ((\<0->Text_to_Maximal_Chars)
            disjoint_string (\<1->Text_to_Maximal_Chars));

    ::MD::catenate::Text ::= function --> Text <-- (Text, Text)
        implements 2::""
        is associative identity ('')
        repeater replicate::Text
        : (Text_from_Maximal_Chars::((\<0->Text_to_Maximal_Chars)
            ~ (\<1->Text_to_Maximal_Chars)));

    ::MD::replicate::Text ::= function --> Text <-- (Text, Integer_NN)
        implements 2::""
        : (Text_from_Maximal_Chars::((\<0->Text_to_Maximal_Chars) ~# \<1));

    ::MD::to_Text::Text ::= function --> Text <-- (Text)
        implements 2::""
        : (\<0);

    ::MD::Text_from_Maximal_Chars ::= function
        --> Text <-- (String::Maximal_Chars)
        : (\Text wrap \<0);

    ::MD::Text_to_Maximal_Chars ::= function
        --> String::Maximal_Chars <-- (Text)
        : (\<0->unwrap);

    ::MD::Text_from_Unicode_Codes ::= function
        --> Text::Unicode <-- (String::Unicode_Codes)
        : (\<0->Text_from_Maximal_Chars);

    ::MD::Text_to_Unicode_Codes ::= function
        --> String::Unicode_Codes <-- (Text::Unicode)
        : (\<0->Text_to_Maximal_Chars);

    ::MD::Text_from_ASCII_Chars ::= function
        --> Text::ASCII <-- (String::ASCII_Chars)
        : (\<0->Text_from_Unicode_Codes);

    ::MD::Text_to_ASCII_Chars ::= function
        --> String::ASCII_Chars <-- (Text::ASCII)
        : (\<0->Text_to_Unicode_Codes);

    ::MD::Blob_is_UTF_8 ::= function --> Boolean <-- (Blob)
        : (...);

    ::MD::Text_from_UTF_8_Blob ::= function
        --> {Text::Unicode, Excuse::Unicode::..., ...} <-- (Blob)
        : (...);

    ::MD::Text_from_UTF_8_Blob_with_repl_Text ::= function
        --> Text::Unicode <-- (Blob, Text::Unicode)
        : (...);

    ::MD::Text_from_UTF_8_Blob_with_repl_char ::= function
        --> Text::Unicode <-- (Blob)
        : (Text_from_UTF_8_Blob_with_repl_Text::(\<0,'\\c<0xFFFD>'));

    ::MD::Text_to_UTF_8_Blob ::= function --> Blob <-- (Text::Unicode)
        : (...);

    ::MD::Blob_is_ASCII ::= function --> Boolean <-- (Blob)
        : (String::ASCII_Chars(\<0->Blob_to_Octets));

    ::MD::Text_from_ASCII_Blob ::= function
        --> {Text::ASCII, Excuse::ASCII::High_Bit_Not_Zero} <-- (Blob)
    : (
        octets ::= \<0->Blob_to_Octets;
        <-- if String::ASCII_Chars(octets)
            then octets->Text_from_ASCII_Chars
            else Excuse::ASCII::High_Bit_Not_Zero();
    );

    ::MD::Text_from_ASCII_Blob_with_repl_Text ::= function
        --> Text::ASCII <-- (Blob, Text::ASCII)
    : (
        src_octets ::= (\<0->Blob_to_Octets);
        repl_chars ::= (\<1->Text_to_ASCII_Chars);
        result_chars ::= (
            given #repl_chars
                when 0 then
                    src_octets where (function : (\<0 in 0..127))
                when 1 then
                    src_octets
                        map (function : (\<0 in 0..127 ?? \<0 !! \<1))
                            \<-- (1 : repl_chars.0,)
                default
                    src_octets
                        map (function : (\<0 in 0..127 ?? [\<0] !! \<1))
                            \<-- (1 : repl_chars,)
                        reduce \catenate::()
        );
        <-- result_chars->Text_from_ASCII_Chars;
    );

    ::MD::Text_to_ASCII_Blob ::= function --> Blob <-- (Text::ASCII)
        : (\<0->Text_to_ASCII_Chars->Blob_from_Octets);

`#########################################################################`

    ::MD::Accessible ::= interface
        requires_implements {has_any_at,has_mapping_at
            ,mapping_at,at,maybe_at
            ,replace_at,shiftless_insert_at,shiftless_remove_at
            ,replace_or_insert_at,shiftless_maybe_remove_at};

    ::MD::has_any_at::"" ::= function virtual
        --> Boolean <-- (Accessible, Any);

    ::MD::".?" ::= alias of has_any_at;

    ::MD::has_mapping_at::"" ::= function virtual
        --> Boolean <-- (Accessible, (Any, Any));

    ::MD::".:?" ::= alias of has_mapping_at;

    ::MD::mapping_at::"" ::= function virtual
        --> (Any, Any) <-- (Accessible, Any)
        requires (\<0 .? \<1);

    ::MD::".:" ::= alias of mapping_at;

    ::MD::at::"" ::= function virtual --> Any <-- (Accessible, Any)
        requires (\<0 .? \<1);

    ::MD::"." ::= alias of at;

    ::MD::maybe_at::"" ::= function virtual --> Any <-- (Accessible, Any);

    ::MD::".!" ::= alias of maybe_at;

    ::MD::replace_at::"" ::= function virtual
        --> Accessible <-- (Accessible, (Any, Any))
        requires (\<0 .? \>>0);

    ::MD::".:=" ::= alias of replace_at;

    ::MD::shiftless_insert_at::"" ::= function virtual
        --> Accessible <-- (Accessible, (Any, Any))
        requires (not \<0 .? \>>0);

    ::MD::".+" ::= alias of shiftless_insert_at;

    ::MD::shiftless_remove_at::"" ::= function virtual
        --> Accessible <-- (Accessible, Any)
        requires (\<0 .? \<1);

    ::MD::".-" ::= alias of shiftless_remove_at;

    ::MD::replace_or_insert_at::"" ::= function virtual
        --> Accessible <-- (Accessible, (Any, Any));

    ::MD::".=+" ::= alias of replace_or_insert_at;

    ::MD::shiftless_maybe_remove_at::"" ::= function virtual
        --> Accessible <-- (Accessible, Any);

    ::MD::".?-" ::= alias of shiftless_maybe_remove_at;

`#########################################################################`

    ::MD::Homogeneous ::= interface
        composes Emptyable
        requires_implements {to_Boolean,empty
            ,singular,only_member
            ,has_n,multiplicity
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,any};

    ::MD::singular::"" ::= function virtual --> Boolean <-- (Homogeneous);

    ::MD::only_member::"" ::= function virtual --> Any <-- (Homogeneous)
        requires (\<*args --> \singular::());

    ::MD::in ::= function commutes has;

    ::MD::Unicode_Aliases::"∈" ::= alias of in;

    ::MD::not_in ::= function commutes not_has;

    ::MD::Unicode_Aliases::"∉" ::= alias of not_in;

    ::MD::has ::= function --> Boolean <-- (Homogeneous, Any)
        : (has_n::(\<0, \<1, 1));

    ::MD::Unicode_Aliases::"∋" ::= alias of has;

    ::MD::not_has ::= function negates has;

    ::MD::Unicode_Aliases::"∌" ::= alias of not_has;

    ::MD::has_n::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Any, Integer_NN);

    ::MD::multiplicity::"" ::= function virtual
        --> Integer_NN <-- (Homogeneous, Any);

    ::MD::all_unique::"" ::= function virtual --> Boolean <-- (Homogeneous);

    ::MD::unique::"" ::= function virtual --> Homogeneous <-- (Homogeneous);

    ::MD::proper_subset_of ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        : (\<*args --> \not_same::() and \<*args --> \subset_of::());

    ::MD::Unicode_Aliases::"⊂" ::= alias of proper_subset_of;

    ::MD::not_proper_subset_of ::= function negates proper_subset_of;

    ::MD::Unicode_Aliases::"⊄" ::= alias of not_proper_subset_of;

    ::MD::proper_superset_of ::= function commutes proper_subset_of;

    ::MD::Unicode_Aliases::"⊃" ::= alias of proper_superset_of;

    ::MD::not_proper_superset_of ::= function negates proper_superset_of;

    ::MD::Unicode_Aliases::"⊅" ::= alias of not_proper_superset_of;

    ::MD::subset_of::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous);

    ::MD::Unicode_Aliases::"⊆" ::= alias of subset_of;

    ::MD::not_subset_of ::= function negates subset_of;

    ::MD::Unicode_Aliases::"⊈" ::= alias of not_subset_of;

    ::MD::superset_of ::= function commutes subset_of;

    ::MD::Unicode_Aliases::"⊇" ::= alias of superset_of;

    ::MD::not_superset_of ::= function negates superset_of;

    ::MD::Unicode_Aliases::"⊉" ::= alias of not_superset_of;

    ::MD::same_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

    ::MD::proper_subset_or_superset ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative
        : (not \<*args --> \same_members::() and \<*args --> \subset_or_superset::());

    ::MD::subset_or_superset ::= function
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative
        : (\<*args --> \subset_of::() or \<*args --> \superset_of::());

    ::MD::overlaps_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

    ::MD::disjoint_members::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Homogeneous)
        is commutative;

    ::MD::any::"" ::= function virtual
        --> Boolean <-- (Homogeneous, Function_Call_But_0);

    ::MD::there_exists ::= alias of any;

    ::MD::Unicode_Aliases::"∃" ::= alias of any;

    ::MD::none ::= function negates any;

    ::MD::there_does_not_exist ::= alias of none;

    ::MD::Unicode_Aliases::"∄" ::= alias of none;

    ::MD::all ::= function --> Boolean <-- (Homogeneous, Function_Call_But_0)
        : (\<0 none ((function : (not \<1 <-- (\<0,))) \<-- (:<1,)));

    ::MD::for_all ::= alias of all;

    ::MD::Unicode_Aliases::"∀" ::= alias of all;

`#########################################################################`

    ::MD::Unionable ::= interface
        composes Homogeneous
        requires_implements {to_Boolean,empty
            ,singular,only_member
            ,has_n,multiplicity
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,any
            ,insert_n,remove_n
            ,member_plus,except,intersect,union,exclusive
            ,nest,unnest,where,map,reduce,...};

    ::MD::insert ::= function --> Unionable <-- (Unionable, Any)
        : (insert_n::(\<0, \<1, 1));

    ::MD::insert_n::"" ::= function virtual
        --> Unionable <-- (Unionable, Any, Integer_NN);

    ::MD::remove ::= function --> Unionable <-- (Unionable, Any)
        : (remove_n::(\<0, \<1, 1));

    ::MD::remove_n::"" ::= function virtual
        --> Unionable <-- (Unionable, Any, Integer_NN);

    ::MD::member_plus::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable)
        is associative;

    ::MD::Unicode_Aliases::"⊎" ::= alias of member_plus;

    ::MD::except::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable);

    ::MD::Unicode_Aliases::"∖" ::= alias of except;

    ::MD::intersect::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable)
        is {associative,idempotent};

    ::MD::Unicode_Aliases::"∩" ::= alias of intersect;

    ::MD::union::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable)
        is idempotent;

    ::MD::Unicode_Aliases::"∪" ::= alias of union;

    ::MD::exclusive::"" ::= function virtual
        --> Unionable <-- (Unionable, Unionable);

    ::MD::symm_diff ::= alias of exclusive;

    ::MD::Unicode_Aliases::"∆" ::= alias of exclusive;

    ::MD::nest::"" ::= function virtual --> Unionable <-- (Unionable)
        requires (...);

    ::MD::group ::= alias of nest;

    ::MD::unnest::"" ::= function virtual --> Unionable <-- (Unionable)
        requires (...);

    ::MD::ungroup ::= alias of unnest;

    ::MD::where::"" ::= function virtual
        --> Unionable <-- (Unionable, Function_Call_But_0);

    ::MD::Unicode_Aliases::"σ" ::= alias of where;

    ::MD::filtering ::= function commutes where;

    ::MD::map::"" ::= function virtual
        --> Unionable <-- (Unionable, Function_Call_But_0);

    ::MD::reduce::"" ::= function virtual
        --> Any <-- (Unionable, Function_Call_But_0_1);

`#########################################################################`

    ::MD::Discrete ::= interface
        composes Unionable and_provides_its_default
        requires_implements {to_Boolean,empty
            ,singular,only_member
            ,has_n,multiplicity
            ,all_unique,unique
            ,subset_of,same_members,overlaps_members,disjoint_members
            ,any
            ,insert_n,remove_n
            ,member_plus,except,intersect,union,exclusive
            ,nest,unnest,where,map,reduce,...
            ,to_Set,to_Bag,count,unique_count,order_using};

    ::MD::to_Set::"" ::= function virtual --> Set <-- (Discrete);

    ::MD::"?|" ::= alias of to_Set;

    ::MD::to_Bag::"" ::= function virtual --> Bag <-- (Discrete);

    ::MD::"+|" ::= alias of to_Bag;

    ::MD::count::"" ::= function virtual --> Integer_NN <-- (Discrete);

    ::MD::cardinality ::= alias of count;
    ::MD::"#"         ::= alias of count;

    ::MD::unique_count::"" ::= function virtual --> Integer_NN <-- (Discrete);

    ::MD::order ::= function --> Positional <-- (Discrete)
        : (\<0 order_using \in_order::());

    ::MD::order_using::"" ::= function virtual
        --> Positional <-- (Discrete, Function_Call_But_0_1);

`#########################################################################`

    ::MD::Positional ::= interface
        composes {Stringy, Discrete and_provides_its_default, Accessible}
        requires_implements {in_order,to_Boolean,empty
            ,substring_of,overlaps_string,disjoint_string
            ,catenate,replicate
            ,has_n,multiplicity
            ,all_unique,unique
            ,any
            ,insert_n,remove_n
            ,except,intersect,union,exclusive
            ,nest,unnest,where,map,reduce,...
            ,to_Set,to_Bag,count,order_using
            ,at
            ,to_Array
            ,first_possible_index,slice_n,index_succ_all_matches,...};

    ::MD::Excuse::No_Such_Index ::= constant composes Excuse;

    ::MD::singular::Positional ::= function --> Boolean <-- (Positional)
        implements 2::""
        : ((\<0->unique_count) = 1);

    ::MD::only_member::Positional ::= function --> Any <-- (Positional)
        implements 2::""
        requires (\<*args --> \singular::())
        : (\<*args --> \first::());

    ::MD::subset_of::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        : ((\<0->to_Bag) subset_of (\<1->to_Bag));

    ::MD::same_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\<0->to_Bag) same_members (\<1->to_Bag));

    ::MD::overlaps_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\<0->to_Bag) overlaps_members (\<1->to_Bag));

    ::MD::disjoint_members::Positional ::= function
        --> Boolean <-- (Positional, Positional)
        implements 2::""
        is commutative
        : ((\<0->to_Bag) disjoint_members (\<1->to_Bag));

    ::MD::member_plus::Positional ::= function
        --> Positional <-- (Positional, Positional)
        implements 2::""
        is associative
        : (\<*args --> \catenate::());

    ::MD::unique_count::Positional ::= function --> Integer_NN <-- (Positional)
        implements 2::""
        : (\<0->to_Set->count);

    ::MD::has_any_at::Positional ::= function
        --> Boolean <-- (Positional, Integer)
        implements 2::""
        : (\<1 >= first_possible_index::(\<0)
            and \<1 < first_unused_index::(\<0));

    ::MD::has_mapping_at::Positional ::= function
        --> Boolean <-- (Positional, (Integer, Any))
        implements 2::""
        : (if \<0 .? \>>0 then \<0.\>>0 = \>>1 else False);

    ::MD::mapping_at::Positional ::= function
        --> (Integer, Any) <-- (Positional, Integer)
        implements 2::""
        requires (\<0 .? \<1)
        : ((\<1, \<0.\<1));

    ::MD::maybe_at::Positional ::= function
        --> Any <-- (Positional, Integer)
        implements 2::""
        : (if \<0 .? \<1 then \<0.\<1 else Excuse::No_Such_Index());

    ::MD::replace_at::Positional ::= function
        --> Positional <-- (Positional, (Integer, Any))
        implements 2::""
        requires (\<0 .? \>>0)
    : (
        src ::= \<0;
        ri ::= \>>0;
        repl_member ::= \>>1;
        fi ::= first_index src;
        li ::= last_index src;
        emp ::= empty src;
        <-- (if ri > fi then slice_range::(src, fi, --ri) else emp)
            insert repl_member
            catenate (if ri < li then slice_range::(src, ++ri, li) else emp);
    );

    ::MD::shiftless_insert_at::Positional ::= function
        --> Positional <-- (Positional, (Integer, Any))
        implements 2::""
        requires (\>>0 = first_unused_index::(\<0))
        : (\<0 insert \>>1);

    ::MD::shiftless_remove_at::Positional ::= function
        --> Positional <-- (Positional, Integer)
        implements 2::""
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 = --first_unused_index::(\<0))
        : (nonlast \<0);

    ::MD::replace_or_insert_at::Positional ::= function
        --> Positional <-- (Positional, (Integer, Any))
        implements 2::""
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 <= first_unused_index::(\<0))
        : (if \<0 .? \>>0 then \<0 .:= \>>0 else \<0 .+ \>>0);

    ::MD::shiftless_maybe_remove_at::Positional ::= function
        --> Positional <-- (Positional, Integer)
        implements 2::""
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 >= --first_unused_index::(\<0))
        : (if \<1 = --first_unused_index::(\<0) then nonlast \<0 else \<0);

    ::MD::to_Array::"" ::= function virtual --> Array <-- (Positional);

    ::MD::"~|" ::= alias of to_Array;

    ::MD::squish ::= function --> Positional <-- (Positional)
        : (\<0 map (function : (( group : \<0, member : False )))
            ->nest map (function : (\<<group)));

    ::MD::first_possible_index::"" ::= function virtual
        --> Integer <-- (Positional);

    ::MD::first_unused_index ::= function --> Integer <-- (Positional)
        : (first_possible_index::(\<0) + #\<0);

    ::MD::first_index ::= function --> Integer <-- (Positional)
        requires (?\<0)
        : (first_possible_index::(\<0));

    ::MD::last_index ::= function --> Integer <-- (Positional)
        requires (?\<0)
        : (--first_unused_index::(\<0));

    ::MD::slice_n::"" ::= function virtual
        --> Positional <-- (Positional, Integer, NN_Integer)
        requires (\<1 >= first_possible_index::(\<0)
            and \<1 + \<2 <= first_unused_index::(\<0));

    ::MD::slice_range ::= function
        --> Positional <-- (Positional, Integer, Integer)
        requires (?\<0 and \<1 >= first_possible_index::(\<0)
            and \<2 < first_unused_index::(\<0))
        : (slice_n::(\<0, \<1, \<2 - \<1 + 1));

    ::MD::first ::= function --> Any <-- (Positional)
        requires (?\<0)
        : (\<0 . first_index::(\<0));

    ::MD::nonfirst ::= function --> Positional <-- (Positional)
        requires (?\<0)
        : (slice_range::(\<0, ++first_index::(\<0), last_index::(\<0)));

    ::MD::last ::= function --> Any <-- (Positional)
        requires (?\<0)
        : (\<0 . last_index::(\<0));

    ::MD::nonlast ::= function --> Positional <-- (Positional)
        requires (?\<0)
        : (slice_range::(\<0, first_index::(\<0), --last_index::(\<0)));

    ::MD::index_succ_all_matches::"" ::= function virtual
        --> Integer <-- (Positional, Positional)
        is commutative;

`#########################################################################`

    ::MD::Array ::= selection where (\<*args -->^ FDN__is_a_Array)
        default ([])
        composes Positional and_provides_its_default;

    ::MD::String::"" ::= selection of Array where (\<0 all \Integer::());

    ::MD::empty_Array ::= constant ([]);

    ::MD::Unicode_Aliases::"~∅" ::= alias of empty_Array;

    ::MD::in_order::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
    : (
        i ::= (\<*args --> \index_succ_all_matches::());
      <--
        if not \<0 .? i then
            e1 ::= True
        else if not \<1 .? i then
            False
        else
            e2 ::= (\<0.i in_order \<1.i);

        e1 ::?= 'This is the case where LHS is a leading subsequence of or is equal to RHS.';
        e2 ::?= 'This will succeed iff in_order() is defined for the member type.';
    );

    ::MD::to_Boolean::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (\<0 != []);

    ::MD::empty::Array ::= function --> Array <-- (Array)
        implements 2::""
        : ([]);

    ::MD::substring_of::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_substring_of);

    ::MD::overlaps_string::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Array_overlaps_string);

    ::MD::disjoint_string::Array ::= function --> Boolean <-- (Array, Array)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Array_disjoint_string);

    ::MD::catenate::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is associative identity ([])
        repeater replicate::Array
        : (\<*args -->^ FDN__Array_catenate);

    ::MD::replicate::Array ::= function --> Array <-- (Array, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_replicate);

    ::MD::has_n::Array ::= function --> Boolean <-- (Array, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_has_n);

    ::MD::multiplicity::Array ::= function --> Integer_NN <-- (Array, Any)
        implements 2::""
        : (\<*args -->^ FDN__Array_multiplicity);

    ::MD::all_unique::Array ::= function --> Boolean <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_all_unique);

    ::MD::unique::Array ::= function --> Array <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_unique);

    ::MD::any::Array ::= function --> Boolean <-- (Array, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Array_any);

    ::MD::insert_n::Array ::= function --> Array <-- (Array, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_insert_n);

    ::MD::remove_n::Array ::= function --> Array <-- (Array, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Array_remove_n);

    ::MD::except::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_except);

    ::MD::intersect::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is {associative,idempotent}
        : (\<*args -->^ FDN__Array_intersect);

    ::MD::union::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        is idempotent identity ([])
        : (\<*args -->^ FDN__Array_union);

    ::MD::exclusive::Array ::= function --> Array <-- (Array, Array)
        implements 2::""
        identity ([])
        : (\<*args -->^ FDN__Array_exclusive);

    ::MD::nest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Array_nest);

    ::MD::unnest::Array ::= function --> Array <-- (Array)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Array_unnest);

    ::MD::where::Array ::= function --> Array <-- (Array, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Array_where);

    ::MD::map::Array ::= function --> Array <-- (Array, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Array_map);

    ::MD::reduce::Array ::= function --> Any <-- (Array, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Array_reduce);

    ::MD::to_Set::Array ::= function --> Set <-- (Array)
        implements 2::""
        : (\<0->to_Bag->to_Set);

    ::MD::to_Bag::Array ::= function --> Bag <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_to_Bag);

    ::MD::count::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        : (\<*args -->^ FDN__Array_count);

    ::MD::order_using::Array ::= function --> Array <-- (Array, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Array_order_using);

    ::MD::at::Array ::= function --> Any <-- (Array, Integer_NN)
        implements 2::""
        requires (\<0 .? \<1)
        : (\<*args -->^ FDN__Array_at);

    ::MD::to_Array::Array ::= function --> Array <-- (Array)
        implements 2::""
        : (\<0);

    ::MD::first_possible_index::Array ::= function --> Integer_NN <-- (Array)
        implements 2::""
        : (0);

    ::MD::slice_n::Array ::= function
        --> Array <-- (Array, NN_Integer, NN_Integer)
        implements 2::""
        requires (\<1 + \<2 <= #\<0)
        : (\<*args -->^ FDN__Array_slice_n);

    ::MD::index_succ_all_matches::Array ::= function
        --> Integer_NN <-- (Array, Array)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Array_index_succ_all_matches);

`#########################################################################`

    ::MD::Setty ::= interface;

`#########################################################################`

    ::MD::Set ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Set, \1::_Asset() ))
            default ({})
            composes {Discrete, Setty and_provides_its_default};

        _Asset ::= selection of Bag
            where (all_unique \<0);
    };

    ::MD::empty_Set ::= constant ({});

    ::MD::Unicode_Aliases::"?∅" ::= alias of empty_Set;

    ::MD::to_Boolean::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (\<0 != {});

    ::MD::empty::Set ::= function --> Set <-- (Set)
        implements 2::""
        : ({});

    ::MD::singular::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (\<0->unwrap->singular);

    ::MD::only_member::Set ::= function --> Any <-- (Set)
        implements 2::""
        requires (\<*args --> \singular::())
        : (\<0->unwrap->only_member);

    ::MD::has_n::Set ::= function --> Boolean <-- (Set, Any, Integer_NN)
        implements 2::""
        : (has_n::(\<0->unwrap, \<1, \<2));

    ::MD::multiplicity::Set ::= function --> Integer_NN <-- (Set, Any)
        implements 2::""
        : (\<0->unwrap multiplicity \<1);

    ::MD::all_unique::Set ::= function --> Boolean <-- (Set)
        implements 2::""
        : (True);

    ::MD::unique::Set ::= function --> Set <-- (Set)
        implements 2::""
        : (\<0);

    ::MD::subset_of::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        : ((\<0->unwrap) subset_of (\<1->unwrap));

    ::MD::same_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : (\<*args --> \same::());

    ::MD::overlaps_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : ((\<0->unwrap) overlaps_members (\<1->unwrap));

    ::MD::disjoint_members::Set ::= function --> Boolean <-- (Set, Set)
        implements 2::""
        is commutative
        : ((\<0->unwrap) disjoint_members (\<1->unwrap));

    ::MD::any::Set ::= function --> Boolean <-- (Set, Function_Call_But_0)
        implements 2::""
        : (\<0->unwrap any \<1);

    ::MD::insert_n::Set ::= function --> Set <-- (Set, Any, Integer_NN)
        implements 2::""
        : (\<0 has \<1 or \<2 = 0 ?? \<0
            !! \Set wrap insert_n::(\<0->unwrap, \<1, 1));

    ::MD::remove_n::Set ::= function --> Set <-- (Set, Any, Integer_NN)
        implements 2::""
        : (\Set wrap remove_n::(\<0->unwrap, \<1, \<2));

    ::MD::member_plus::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent} identity ({})
        : (\<*args --> \union::());

    ::MD::except::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        : (\Set wrap ((\<0->unwrap) except (\<1->unwrap)));

    ::MD::intersect::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent}
        : (\Set wrap ((\<0->unwrap) intersect (\<1->unwrap)));

    ::MD::union::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative,idempotent} identity ({})
        : (\Set wrap ((\<0->unwrap) union (\<1->unwrap)));

    ::MD::exclusive::Set ::= function --> Set <-- (Set, Set)
        implements 2::""
        is {associative,commutative} identity ({})
        : (\Set wrap ((\<0->unwrap) exclusive (\<1->unwrap)));

    ::MD::nest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\<0->unwrap->nest));

    ::MD::unnest::Set ::= function --> Set <-- (Set)
        implements 2::""
        requires (...)
        : (\Set wrap (\<0->unwrap->unnest));

    ::MD::where::Set ::= function --> Set <-- (Set, Function_Call_But_0)
        implements 2::""
        : (\Set wrap (\<0->unwrap where \<1));

    ::MD::map::Set ::= function --> Set <-- (Set, Function_Call_But_0)
        implements 2::""
        : (\Set wrap (\<0->unwrap map \<1));

    ::MD::reduce::Set ::= function --> Any <-- (Set, Function_Call_But_0_1)
        implements 2::""
        : (\Set wrap (\<0->unwrap reduce \<1));

    ::MD::to_Set::Set ::= function --> Set <-- (Set)
        implements 2::""
        : (\<0);

    ::MD::to_Bag::Set ::= function --> Bag <-- (Set)
        implements 2::""
        : (\<0->unwrap);

    ::MD::count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (\<0->unwrap->count);

    ::MD::unique_count::Set ::= function --> Integer_NN <-- (Set)
        implements 2::""
        : (\<0->count);

    ::MD::order_using::Set ::= function --> Array <-- (Set, Function_Call_But_0_1)
        implements 2::""
        : (\Set wrap (\<0->unwrap order_using \<1));

`#########################################################################`

    ::MD::Bag ::= selection where (\<*args -->^ FDN__is_a_Bag)
        default (\+{})
        composes Discrete;

    ::MD::empty_Bag ::= constant (\+{});

    ::MD::Unicode_Aliases::"+∅" ::= alias of empty_Bag;

    ::MD::to_Boolean::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\<0 != \+{});

    ::MD::empty::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\+{});

    ::MD::singular::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_singular);

    ::MD::only_member::Bag ::= function --> Any <-- (Bag)
        implements 2::""
        requires (\<*args --> \singular::())
        : (\<*args -->^ FDN__Bag_only_member);

    ::MD::has_n::Bag ::= function --> Boolean <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Bag_has_n);

    ::MD::multiplicity::Bag ::= function --> Integer_NN <-- (Bag, Any)
        implements 2::""
        : (\<*args -->^ FDN__Bag_multiplicity);

    ::MD::all_unique::Bag ::= function --> Boolean <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_all_unique);

    ::MD::unique::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_unique);

    ::MD::subset_of::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_subset_of);

    ::MD::same_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (\<*args --> \same::());

    ::MD::overlaps_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Bag_overlaps_members);

    ::MD::disjoint_members::Bag ::= function --> Boolean <-- (Bag, Bag)
        implements 2::""
        is commutative
        : (\<*args -->^ FDN__Bag_disjoint_members);

    ::MD::any::Bag ::= function --> Boolean <-- (Bag, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Bag_any);

    ::MD::insert_n::Bag ::= function --> Bag <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Bag_insert_n);

    ::MD::remove_n::Bag ::= function --> Bag <-- (Bag, Any, Integer_NN)
        implements 2::""
        : (\<*args -->^ FDN__Bag_remove_n);

    ::MD::member_plus::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative} identity (\+{})
        : (\<*args -->^ FDN__Bag_member_plus);

    ::MD::except::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_except);

    ::MD::intersect::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative,idempotent}
        : (\<*args -->^ FDN__Bag_intersect);

    ::MD::union::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative,idempotent} identity (\+{})
        : (\<*args -->^ FDN__Bag_union);

    ::MD::exclusive::Bag ::= function --> Bag <-- (Bag, Bag)
        implements 2::""
        is {associative,commutative} identity (\+{})
        : (\<*args -->^ FDN__Bag_exclusive);

    ::MD::nest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Bag_nest);

    ::MD::unnest::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Bag_unnest);

    ::MD::where::Bag ::= function --> Bag <-- (Bag, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Bag_where);

    ::MD::map::Bag ::= function --> Bag <-- (Bag, Function_Call_But_0)
        implements 2::""
        : (\<*args -->^ FDN__Bag_map);

    ::MD::reduce::Bag ::= function --> Any <-- (Bag, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Bag_reduce);

    ::MD::to_Set::Bag ::= function --> Set <-- (Bag)
        implements 2::""
        : (\Set wrap (\<0->unique));

    ::MD::to_Bag::Bag ::= function --> Bag <-- (Bag)
        implements 2::""
        : (\<0);

    ::MD::count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_count);

    ::MD::unique_count::Bag ::= function --> Integer_NN <-- (Bag)
        implements 2::""
        : (\<*args -->^ FDN__Bag_unique_count);

    ::MD::order_using::Bag ::= function --> Array <-- (Bag, Function_Call_But_0_1)
        implements 2::""
        : (\<*args -->^ FDN__Bag_order_using);

`#########################################################################`

    ::MD::Attributive ::= interface
        requires_implements {has_any_attrs,nullary
            ,is_unary,degree,heading,rename
            ,can_project_matching,on,update,extend
            ,has_attrs,has_just_attrs};

    ::MD::Excuse::No_Such_Attr_Name ::= constant composes Excuse;

    ::MD::has_any_attrs::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::"?@" ::= alias of has_any_attrs;

    ::MD::is_nullary ::= function negates has_any_attrs;

    ::MD::"!?@" ::= alias of is_nullary;

    ::MD::nullary::"" ::= function virtual --> Attributive <-- (Attributive);

    ::MD::is_unary::"" ::= function virtual --> Boolean <-- (Attributive);

    ::MD::degree::"" ::= function virtual --> Integer_NN <-- (Attributive);

    ::MD::"#@" ::= alias of degree;

    ::MD::heading::"" ::= function virtual --> Heading <-- (Attributive);

    ::MD::"@" ::= alias of heading;

    ::MD::subheading_of ::= function
        --> Boolean <-- (Attributive, Attributive)
        : ((@\<0, @\<1) -->^ FDN__Tuple_subheading_of);

    ::MD::Unicode_Aliases::"⊆@" ::= alias of subheading_of;

    ::MD::superheading_of ::= function commutes subheading_of;

    ::MD::has_subheading ::= alias of superheading_of;
    ::MD::"@?"           ::= alias of superheading_of;

    ::MD::Unicode_Aliases::"⊇@" ::= alias of superheading_of;

    ::MD::same_heading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (@\<0 = @\<1);

    ::MD::"=@" ::= alias of same_heading;

    ::MD::proper_subheading_or_superheading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (@\<0 != @\<1 and \<*args --> \subheading_or_superheading::());

    ::MD::subheading_or_superheading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : (\<*args --> \subheading_of::() or \<*args --> \superheading_of::());

    ::MD::overlaps_heading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : ((@\<0, @\<1) -->^ FDN__Tuple_overlaps_heading);

    ::MD::disjoint_heading ::= function
        --> Boolean <-- (Attributive, Attributive)
        is commutative
        : ((@\<0, @\<1) -->^ FDN__Tuple_disjoint_heading);

    ::MD::except_heading ::= function
        --> Heading <-- (Attributive, Attributive)
        : ((@\<0, @\<1) -->^ FDN__Tuple_except_heading);

    ::MD::Unicode_Aliases::"∖@" ::= alias of except_heading;

    ::MD::intersect_heading ::= function
        --> Heading <-- (Attributive, Attributive)
        is {associative,commutative,idempotent}
        : ((@\<0, @\<1) -->^ FDN__Tuple_intersect_heading);

    ::MD::Unicode_Aliases::"∩@" ::= alias of intersect_heading;

    ::MD::union_heading ::= function
        --> Heading <-- (Attributive, Attributive)
        is {associative,commutative,idempotent} identity (())
        : ((@\<0, @\<1) -->^ FDN__Tuple_union_heading);

    ::MD::Unicode_Aliases::"∪@" ::= alias of union_heading;

    ::MD::exclusive ::= function
        --> Heading <-- (Attributive, Attributive)
        is {associative,commutative} identity (())
        : ((@\<0, @\<1) -->^ FDN__Tuple_exclusive_heading);

    ::MD::symm_diff_heading ::= alias of exclusive_heading;

    ::MD::Unicode_Aliases::"∆@" ::= alias of exclusive_heading;

    ::MD::rename::"" ::= function virtual
        --> Attributive <-- (Attributive, Renaming)
        requires (...);

    ::MD::"@:=" ::= alias of rename;

    ::MD::Unicode_Aliases::"ρ" ::= alias of rename;

    ::MD::renaming ::= function commutes rename;

    ::MD::can_project_matching::"" ::= function virtual
        --> Boolean <-- (Attributive, Structural);

    ::MD::"%=?" ::= alias of can_project_matching;

    ::MD::on::"" ::= function virtual
        --> Attributive <-- (Attributive, Heading)
        requires (\<0 @? \<1);

    ::MD::project ::= alias of on;
    ::MD::"%="    ::= alias of on;

    ::MD::Unicode_Aliases::"π" ::= alias of on;

    ::MD::from ::= function commutes on;

    ::MD::maybe_on ::= function --> Attributive <-- (Attributive, Heading)
        : (\<0 on (\<0 intersect_heading \<1));

    ::MD::"%!" ::= alias of maybe_on;

    ::MD::update::"" ::= function virtual
        --> Attributive <-- (Attributive, Structural)
        requires (\<0 @? \<1);

    ::MD::"%:=" ::= alias of update;

    ::MD::extend::"" ::= function virtual
        --> Attributive <-- (Attributive, Structural)
        requires (\<0 disjoint_heading \<1);

    ::MD::"%+" ::= alias of extend;

    ::MD::but ::= function --> Attributive <-- (Attributive, Heading)
        requires (\<0 @? \<1)
        : (\<0 on (\<0 except_heading \<1));

    ::MD::project_all_but ::= alias of but;
    ::MD::"%-"            ::= alias of but;

    ::MD::update_or_extend ::= function
        --> Attributive <-- (Attributive, Structural)
        : (\<0 on (\<0 except_heading \<1) extend \<1);

    ::MD::"%=+" ::= alias of update_or_extend;

    ::MD::maybe_but ::= function --> Attributive <-- (Attributive, Heading)
        : (\<0 but (\<0 intersect_heading \<1));

    ::MD::"%?-" ::= alias of maybe_but;

    ::MD::has_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

    ::MD::has_just_attrs::"" ::= function virtual
        --> Boolean <-- (Attributive, Signature);

`#########################################################################`

    ::MD::Structural ::= interface
        composes {Attributive and_provides_its_default,
            Accessible and_provides_its_default}
        requires_implements {has_any_attrs,nullary
            ,is_unary,degree,heading,rename
            ,on,update,extend
            ,has_attrs,has_just_attrs
            ,at
            ,to_Tuple};

    ::MD::can_project_matching::Structural ::= function
        --> Boolean <-- (Structural, Structural)
        implements 2::""
        : (if \<0 @? \<1 then \<0 %= @\<1 = \<1 else False);

    ::MD::has_any_at::Structure ::= function
        --> Boolean <-- (Structure, Attr_Name)
        implements 2::""
        : (\<0 @? \<1);

    ::MD::has_mapping_at::Structural ::= function
        --> Boolean <-- (Structural, (Attr_Name, Any))
        implements 2::""
        : (if \<0 .? \>>0 then \<0.\>>0 = \>>1 else False);

    ::MD::mapping_at::Structural ::= function
        --> (Attr_Name, Any) <-- (Structural, Attr_Name)
        implements 2::""
        requires (\<0 .? \<1)
        : ((\<1, \<0.\<1));

    ::MD::maybe_at::Structural ::= function
        --> Any <-- (Structural, Attr_Name)
        implements 2::""
        : (if \<0 .? \<1 then \<0.\<1 else Excuse::No_Such_Attr_Name());

    ::MD::replace_at::Structure ::= function
        --> Structure <-- (Structure, (Attr_Name, Any))
        implements 2::""
        requires (\<0 .? \>>0)
    : (\<0 update \<1 --> \D1::());

    ::MD::shiftless_insert_at::Structure ::= function
        --> Structure <-- (Structure, (Attr_Name, Any))
        implements 2::""
        requires (not \<0 .? \>>0)
        : (\<0 extend \<1 --> \D1::());

    ::MD::shiftless_remove_at::Structure ::= function
        --> Structure <-- (Structure, Attr_Name)
        implements 2::""
        requires (\<0 .? \<1)
        : (\<0 but \<1);

    ::MD::replace_or_insert_at::Structural ::= function
        --> Structural <-- (Structural, (Attr_Name, Any))
        implements 2::""
        : (\<0 update_or_extend \<1 --> \D1::());

    ::MD::shiftless_maybe_remove_at::Structural ::= function
        --> Structural <-- (Structural, Attr_Name)
        implements 2::""
        : (\<0 maybe_but \<1);

    ::MD::to_Tuple::"" ::= function virtual --> Tuple <-- (Structural);

    ::MD::"%" ::= alias of to_Tuple;

`#########################################################################`

    ::MD::Tuple::"" ::= selection where (\<*args -->^ FDN__is_a_Tuple)
        default (())
        composes Structural and_provides_its_default;

    ::MD::Tuple_D0 ::= constant (());

    ::MD::D0 ::= alias of Tuple_D0;

    ::MD::Tuple_D1 ::= selection of Tuple
        where (is_unary \<0)
        default ((False));

    ::MD::D1 ::= function --> Tuple_D1 <-- (Attr_Name, Any)
        : (\<*args -->^ FDN__Tuple_D1_select);

    ::MD::has_any_attrs::Tuple ::= function --> Boolean <-- (Tuple)
        implements 2::""
        : (\<0 != ());

    ::MD::nullary::Tuple ::= function --> Tuple <-- (Tuple)
        implements 2::""
        : (());

    ::MD::is_unary::Tuple ::= function --> Boolean <-- (Tuple)
        implements 2::""
        : (degree::(\<0) = 1);

    ::MD::degree::Tuple ::= function --> Integer_NN <-- (Tuple)
        implements 2::""
        : (\<*args -->^ FDN__Tuple_degree);

    ::MD::heading::Tuple ::= function --> Heading <-- (Tuple)
        implements 2::""
        : (\<*args -->^ FDN__Tuple_heading);

    ::MD::rename::Tuple ::= function --> Tuple <-- (Tuple, Renaming)
        implements 2::""
        requires (...)
        : (\<*args -->^ FDN__Tuple_rename);

    ::MD::on::Tuple ::= function --> Tuple <-- (Tuple, Heading)
        implements 2::""
        requires (\<0 @? \<1)
        : (\<*args -->^ FDN__Tuple_on);

    ::MD::update::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 2::""
        requires (\<0 @? \<1)
        : (\<*args -->^ FDN__Tuple_update);

    ::MD::extend::Tuple ::= function --> Tuple <-- (Tuple, Tuple)
        implements 2::""
        requires (\<0 disjoint_heading \<1)
        is {associative,commutative} identity (())
        : (\<*args -->^ FDN__Tuple_extend);

    ::MD::has_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

    ::MD::has_just_attrs::Tuple ::= function --> Boolean <-- (Tuple, Signature)
        implements 2::""
        : (...);

    ::MD::at::Tuple ::= function --> Any <-- (Tuple, Attr_Name)
        implements 2::""
        requires (\<0 .? \<1)
        : (\<*args -->^ FDN__Tuple_at);

    ::MD::to_Tuple::Tuple ::= function --> Tuple <-- (Tuple)
        implements 2::""
        : (\<0);

    ::MD::any_attrs ::= function --> Boolean <-- (Tuple, Function_Call_But_0)
        : (\<*args -->^ FDN__Tuple_any_attrs);

    ::MD::none_of_attrs ::= function negates any_attrs;

    ::MD::all_attrs ::= function --> Boolean <-- (Tuple, Function_Call_But_0)
        : (\<0 none_of_attrs ((function : (not \<1 <-- (\<0,))) \<-- (:<1,)));

    ::MD::attrs_where ::= function --> Tuple <-- (Tuple, Function_Call_But_0)
        : (\<*args -->^ FDN__Tuple_attrs_where);

    ::MD::attrs_map ::= function --> Tuple <-- (Tuple, Function_Call_But_0)
        : (\<*args -->^ FDN__Tuple_attrs_map);

    ::MD::attrs_reduce ::= function --> Any <-- (Tuple, Function_Call_But_0_1)
        : (\<*args -->^ FDN__Tuple_attrs_reduce);

`#########################################################################`

    ::MD::Relational ::= interface
        composes {Unionable, Attributive}
        requires_implements {...};

`#########################################################################`

    ::MD::Tuple_Array ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Tuple_Array, \1::_Asset() ))
            default (~%@())
            composes {Relational, Positional};

        _Asset ::= selection of Tuple where
        (
            if \<0 has_just_attrs ( heading : \Heading::(), body : \Array::() ) then
                if \<<body all \Tuple::() then
                    \<<body all (function : (\has_just_attrs::() \<-- \<<heading))
                else
                    False
            else
                False
        );
    };

    ::MD::Tuple_Array_D0C0 ::= constant (~%@());

    ::MD::Tuple_Array_D0C1 ::= constant (~%[()]);

`#########################################################################`

    ::MD::Relation ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Relation, \1::_Asset() ))
            default (?%@())
            composes {Relational and_provides_its_default, Discrete, Setty};

        _Asset ::= selection of Tuple_Bag
            where (all_unique \<0);
    };

    ::MD::Relation_D0C0 ::= constant (?%@());

    ::MD::D0C0 ::= alias of Relation_D0C0;

    ::MD::Relation_D0C1 ::= constant (?%{()});

    ::MD::D0C1 ::= alias of Relation_D0C1;

`#########################################################################`

    ::MD::Tuple_Bag ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Tuple_Bag, \1::_Asset() ))
            default (+%@())
            composes {Relational, Discrete};

        _Asset ::= selection of Tuple where
        (
            if \<0 has_just_attrs ( heading : \Heading::(), body : \Bag::() ) then
                if \<<body all \Tuple::() then
                    \<<body all (function : (\has_just_attrs::() \<-- \<<heading))
                else
                    False
            else
                False
        );
    };

    ::MD::Tuple_Bag_D0C0 ::= constant (+%@());

    ::MD::Tuple_Bag_D0C1 ::= constant (+%{()});

`#########################################################################`

    ::MD::Intervalish ::= interface
        composes Homogeneous
        requires_implements {...};

`#########################################################################`

    ::MD::Interval ::= selection of Capsule
        where (has_wrapped::( \<0, \Interval, \Tuple::Interval() ))
        default ((-∞)..(+∞))
        composes {Intervalish, Setty};

    ::MD::Tuple::Interval ::= selection of Tuple
        where (...);

`#########################################################################`

    ::MD::Unionable_Intervalish ::= interface
        composes {Intervalish, Unionable}
        requires_implements {...};

`#########################################################################`

    ::MD::Interval_Set ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Interval_Set, \1::_Asset() ))
            default (...)
            composes {Unionable_Intervalish, Setty};

        _Asset ::= selection of Interval_Bag
            where (all_unique \<0);
    };

`#########################################################################`

    ::MD::Interval_Bag ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Interval_Bag, \1::_Asset() ))
            default (...)
            composes Unionable_Intervalish;

        _Asset ::= selection of Tuple_Bag where
        (
            ...
        );
    };

`#########################################################################`

    ::MD::Quantitative ::= interface
        composes Numerical
        requires_implements {...};

`#########################################################################`

    ::MD::Quantity ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Quantity, \1::_Asset() ))
            default (...)
            composes Quantitative;

        _Asset ::= selection of Relation where
        (
            ...
        );
    };

`#########################################################################`

    ::MD::Capsule::"" ::= selection where (\<*args -->^ FDN__is_a_Capsule)
        default (False wrap False);

    ::MD::Capsule::wrap ::= function --> Capsule <-- (Any, Any)
        : (\<*args -->^ FDN__Capsule_wrap);

    ::MD::Capsule::wrapper ::= function --> Any <-- (Capsule)
        : (\<*args -->^ FDN__Capsule_wrapper);

    ::MD::Capsule::unwrap ::= function --> Any <-- (Capsule)
        : (\<*args -->^ FDN__Capsule_unwrap);

    ::MD::Capsule::has_wrapped ::= function
        --> Boolean <-- (Capsule, Any, Function_Call_But_0)
        : ((wrapper \<0) = \<1 and (unwrap \<0,) --> \<2);

`#########################################################################`

    ::MD::External::"" ::= selection where (\<*args -->^ FDN__is_a_External)
        default (() -->^ FDN__default_External);

    ::MD::External::call_function ::= function --> Any <-- (Any)
        : (FDN__External_call_function ^<-- \<*args);

`#########################################################################`

    ::MD::Source_Code::Package_List ::= selection of Array
        where (\<0 all (selection of {Package, Decoration}));

    ::MD::Source_Code::Package ::= binder
    {
        "" ::= selection of Capsule
            where (has_wrapped::( \<0, \Package, \1::_Asset() ))
            default (\Package wrap 1::_Asset());

        _Asset ::= selection of Tuple where
        (
            if
                \<0 has_just_attrs (
                    identity : (selection of Pkg_Decl_Map where (is_unary \<0)),
                    foundation : ...,
                    uses : \Pkg_Decl_Map::(),
                    entry : ...,
                    floating : ...,
                    materials : ...,
                    annotation : ...,
                    decoration : ...,
                )
            then
                \<<uses disjoint_heading \<<identity
            else
                False
        );
    };

    ::MD::Source_Code::Pkg_Decl_Map ::= selection of Tuple
        where (\<0 all_attrs (function : (Pkg_Canon_Name \<<asset)));

    ::MD::Source_Code::Heading ::= selection of Tuple
        where (\<0 all_attrs (function : (\<<asset = True)));

    ::MD::Source_Code::Attr_Name ::= selection of Heading
        where (is_unary \<0);

    ::MD::Source_Code::Key_Asset_Pair ::= selection of Tuple
        where (@\<0 = \@(key,asset));

`#########################################################################`

    ::MD::Source_Code::Annotation::"" ::= interface;

`#########################################################################`

    ::MD::Source_Code::Decoration::"" ::= interface;

`#########################################################################`

};

`#########################################################################`
`#########################################################################`
