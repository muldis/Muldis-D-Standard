Muldis_D Plain_Text 'http://muldis.com' '0.201.0.-9'
meta script 'Unicode 9.0 UTF-8'

`#########################################################################`
`#########################################################################`

(\Package : (
    identity : (
        package_base_name : [\Core],
        authority : 'http://muldis.com',
        version_number : '0.201.0.-9',
    ),
    foundation : (
        authority : 'http://muldis.com',
        version_number : '0.201.0.-9',
    ),
    floating : {\@package, \@package::Source_Code},
    materials : (

`#########################################################################`

        Any : (\Selection : ( default : False )),

        None : (\Selection : ( of : {} )),

        same : (\Function : (
            returns : \@Boolean,
            matches : (\@Any, \@Any),
            is_commutative : True,
            evaluates : \(args --> \foundation::same::()),
        )),

        "=" : (\Alias : ( of : \@same )),

        not_same : (\Function : (
            negates : \@same,
            is_commutative : True,
        )),

        "!=" : (\Alias : ( of : \@not_same )),

        Unicode_Aliases::"≠" : (\Alias : ( of : \@not_same )),

        is_a : (\Function : (
            returns : \@Boolean,
            matches : (\@Any, \@Signature),
            evaluates : \((args:.\0,) --> Signature_to_Function_Call_But_0::(args:.\1)),
        )),

        not_is_a : (\Function : ( negates : \@is_a )),

`#########################################################################`

        Excuse::"" : (\Interface : ()),

        Excuse::No_Reason : (\Constant : ( composes : \@Excuse and_provides_its_default )),

        or_else : (\Function : (
            returns : \@Any,
            matches : (\@Any, \@Any),
            is_associative : True,
            is_idempotent : True,
            evaluates : \(if Excuse args:.\0 then args:.\1 else args:.\0),
        )),

        coalesce : (\Alias : ( of : \@or_else )),

        and_then : (\Function : (
            returns : \@Any,
            matches : (\@Any, \@Any),
            is_associative : True,
            is_idempotent : True,
            evaluates : \(if Excuse args:.\0 then args:.\0 else args:.\1),
        )),

`#########################################################################`

        Orderable::"" : (\Interface : (
            requires_implements : in_order,
        )),

        Excuse::Before_All_Others : (\Constant : ( composes : {\@Excuse, \@Orderable} )),

        Excuse::After_All_Others : (\Constant : ( composes : {\@Excuse, \@Orderable} )),

        in_order::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Orderable, \@Orderable),
        )),

        in_order::Before_All_Others_L : (\Function : (
            returns : \@Boolean,
            matches : (\@Excuse::Before_All_Others, \@Orderable),
            implements : \@folder::"",
            evaluates : \(True),
        )),

        in_order::Before_All_Others_R : (\Function : (
            returns : \@Boolean,
            matches : (\@Orderable, \@Excuse::Before_All_Others),
            implements : \@folder::"",
            evaluates : \(args:.\0 = args:.\1),
        )),

        in_order::After_All_Others_L : (\Function : (
            returns : \@Boolean,
            matches : (\@Excuse::After_All_Others, \@Orderable),
            implements : \@folder::"",
            evaluates : \(args:.\0 = args:.\1),
        )),

        in_order::After_All_Others_R : (\Function : (
            returns : \@Boolean,
            matches : (\@Orderable, \@Excuse::After_All_Others),
            implements : \@folder::"",
            evaluates : \(True),
        )),

        before : (\Function : ( commutes : \@after )),

        "<" : (\Alias : ( of : \@before )),

        after : (\Function : ( negates : \@before_or_same )),

        ">" : (\Alias : ( of : \@after )),

        before_or_same : (\Alias : ( of : \@in_order )),

        "<=" : (\Alias : ( of : \@before_or_same )),

        Unicode_Aliases::"≤" : (\Alias : ( of : \@before_or_same )),

        after_or_same : (\Function : ( commutes : \@before_or_same )),

        ">=" : (\Alias : ( of : \@after_or_same )),

        Unicode_Aliases::"≥" : (\Alias : ( of : \@after_or_same )),

        min : (\Function : (
            returns : \@Orderable,
            matches : (\@Orderable, \@Orderable),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : \(Excuse::After_All_Others()),
            evaluates : \(if args:.\0 in_order args:.\1 then args:.\0 else args:.\1),
        )),

        max : (\Function : (
            returns : \@Orderable,
            matches : (\@Orderable, \@Orderable),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : \(Excuse::Before_All_Others()),
            evaluates : \(if args:.\0 in_order args:.\1 then args:.\1 else args:.\0),
        )),

        minmax : (\Function : (
            returns : (\@Orderable, \@Orderable),
            matches : (\@Orderable, \@Orderable),
            is_commutative : True,
            evaluates : \(if args:.\0 in_order args:.\1 then args else (args:.\1, args:.\0)),
        )),

`#########################################################################`

        Successable : (\Interface : (
            requires_implements : {asset,nth_succ},
        )),

        asset::"" : (\Function : ( virtual : True, returns : \@Any, matches : (\@Successable) )),

        succ : (\Function : (
            returns : {\@Successable, \@Excuse::After_All_Others},
            matches : (\@Successable),
            evaluates : \(args:.\0 nth_succ 1),
        )),

        nth_succ::"" : (\Function : (
            virtual : True,
            returns : {\@Successable, \@Excuse::After_All_Others},
            matches : (\@Successable, \@Integer::NN),
        )),

`#########################################################################`

        Bicessable : (\Interface : (
            composes : {\@Orderable and_provides_its_default,
                \@Successable and_provides_its_default},
            requires_implements : {in_order,asset,nth_pred,nth_succ},
        )),

        pred : (\Function : (
            returns : {\@Bicessable, \@Excuse::Before_All_Others},
            matches : (\@Bicessable),
            evaluates : \(args:.\0 nth_pred 1),
        )),

        nth_pred::"" : (\Function : (
            virtual : True,
            returns : {\@Bicessable, \@Excuse::Before_All_Others},
            matches : (\@Bicessable, \@Integer::NN),
        )),

`#########################################################################`

        Boolable : (\Interface : ( requires_implements : to_Boolean )),

        to_Boolean::"" : (\Function : ( virtual : True, returns : \@Boolean, matches : (\@Boolable) )),

        so  : (\Alias : ( of : \@to_Boolean )),
        "?" : (\Alias : ( of : \@to_Boolean )),

        not_so : (\Function : ( negates : \@to_Boolean )),

        "!?" : (\Alias : ( of : \@not_so )),

`#########################################################################`

        Boolean : (\Selection : (
            where : \(args --> \foundation::is_a_Boolean::()),
            default : False,
            composes : {\@Bicessable, \@Boolable and_provides_its_default},
        )),

        False : (\Constant : ( value : False )),

        Unicode_Aliases::"⊥" : (\Alias : ( of : \@False )),

        True : (\Constant : ( value : True )),

        Unicode_Aliases::"⊤" : (\Alias : ( of : \@True )),

        in_order::Boolean : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            implements : \@folder::"",
            evaluates : \(!args:.\0 or args:.\1),
        )),

        asset::Boolean : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        nth_pred::Boolean : (\Function : (
            returns : {\@False, \@Excuse::Before_All_Others},
            matches : (\@Boolean, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\1 = 0 then args:.\0 else if args:.\1 = 1 and args:.\0 then False else Excuse::Before_All_Others()),
        )),

        nth_succ::Boolean : (\Function : (
            returns : {\@True, \@Excuse::After_All_Others},
            matches : (\@Boolean, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\1 = 0 then args:.\0 else if args:.\1 = 1 and !args:.\0 then True else Excuse::After_All_Others()),
        )),

        to_Boolean::Boolean : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        not : (\Function : ( negates : \@to_Boolean::Boolean )),

        "!" : (\Alias : ( of : \@not )),

        Unicode_Aliases::"¬" : (\Alias : ( of : \@not )),

        and : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : True,
            evaluates : \(if args:.\0 then args:.\1 else False),
        )),

        Unicode_Aliases::"∧" : (\Alias : ( of : \@and )),

        nand : (\Function : (
            negates : \@and,
            is_commutative : True,
        )),

        not_and : (\Alias : ( of : \@nand )),

        Unicode_Aliases::"⊼" : (\Alias : ( of : \@nand )),
        Unicode_Aliases::"↑" : (\Alias : ( of : \@nand )),

        or : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : False,
            evaluates : \(if args:.\0 then True else args:.\1),
        )),

        Unicode_Aliases::"∨" : (\Alias : ( of : \@or )),

        nor : (\Function : (
            negates : \@or,
            is_commutative : True,
        )),

        not_or : (\Alias : ( of : \@nor )),

        Unicode_Aliases::"⊽" : (\Alias : ( of : \@nor )),
        Unicode_Aliases::"↓" : (\Alias : ( of : \@nor )),

        xnor : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            is_associative : True,
            is_commutative : True,
            identity : True,
            evaluates : \(args:.\0 = args:.\1),
        )),

        iff : (\Alias : ( of : \@xnor )),

        Unicode_Aliases::"↔" : (\Alias : ( of : \@xnor )),

        xor : (\Function : (
            negates : \@xnor,
            is_associative : True,
            is_commutative : True,
            identity : False,
        )),

        Unicode_Aliases::"⊻" : (\Alias : ( of : \@xor )),
        Unicode_Aliases::"↮" : (\Alias : ( of : \@xor )),

        imp : (\Function : (
            returns : \@Boolean,
            matches : (\@Boolean, \@Boolean),
            evaluates : \(if args:.\0 then args:.\1 else True),
        )),

        implies : (\Alias : ( of : \@imp )),

        Unicode_Aliases::"→" : (\Alias : ( of : \@imp )),

        nimp : (\Function : ( negates : \@imp )),

        not_implies : (\Alias : ( of : \@nimp )),

        Unicode_Aliases::"↛" : (\Alias : ( of : \@nimp )),

        if : (\Function : ( commutes : \@imp )),

        Unicode_Aliases::"←" : (\Alias : ( of : \@if )),

        nif : (\Function : ( commutes : \@nimp )),

        not_if : (\Alias : ( of : \@nif )),

        Unicode_Aliases::"↚" : (\Alias : ( of : \@nif )),

`#########################################################################`

        Round_Meth::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \@material, \folder::Attr_Name::() )),
            default : (\@material : \To_Zero),
        )),

        Round_Meth::Attr_Name : (\Selection : (
            of : \@Attr_Name,
            where : \(args:.\0 ⊆@ \@(Down,Up,To_Zero,To_Inf
                ,Half_Down,Half_Up,Half_To_Zero,Half_To_Inf
                ,Half_Even,Half_Odd)
            ),
            default : \To_Zero,
        )),

        RM : (\Function : (
            returns : \@Round_Meth,
            matches : (\@Round_Meth::Attr_Name),
            evaluates : \((\@Round_Meth : args:.\0)),
        )),

`#########################################################################`

        Numerical : (\Interface : (
            composes : \@Boolable,
            requires_implements : {to_Boolean
                ,zero,opposite,reciprocal,modulus
                ,plus,minus,times,multiple_of
                ,fractional_divided_by,integral_divided_by
                ,integral_power,integral_nn_power},
        )),

        Excuse::Div_By_Zero : (\Constant : ( composes : \@Excuse )),

        Excuse::Zero_To_The_Zero : (\Constant : ( composes : \@Excuse )),

        to_Boolean::Numerical : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Numerical),
            implements : \@folder::"",
        )),

        is_zero : (\Function : ( negates : \@to_Boolean::Numerical )),

        zero::"" : (\Function : ( virtual : True, returns : \@Numerical, matches : (\@Numerical) )),

        opposite::"" : (\Function : ( virtual : True, returns : \@Numerical, matches : (\@Numerical) )),

        additive_inverse : (\Alias : ( of : \@opposite )),

        reciprocal::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical),
        )),

        multiplicative_inverse : (\Alias : ( of : \@reciprocal )),

        modulus::"" : (\Function : ( virtual : True, returns : \@Numerical, matches : (\@Numerical) )),

        abs : (\Alias : ( of : \@modulus )),

        plus::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
            is_associative : True,
            is_commutative : True,
            repeater : times,
        )),

        "+" : (\Alias : ( of : \@plus )),

        minus::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
        )),

        "-" : (\Function : (
            returns : \@Numerical,
            matches : {(Numerical), (Numerical, Numerical)},
            evaluates : \(args --> (if degree::(args) = 1 then \opposite::() else \minus::())),
        )),

        Unicode_Aliases::"−" : (\Alias : ( of : "-" )),

        modulus_minus : (\Function : (
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
            is_commutative : True,
            evaluates : \(modulus args:.\0 - args:.\1),
        )),

        abs_minus : (\Alias : ( of : \@modulus_minus )),
        "|-|"     : (\Alias : ( of : \@modulus_minus )),

        Unicode_Aliases::"|−|" : (\Alias : ( of : \@modulus_minus )),

        times::"" : (\Function : (
            virtual : True,
            returns : \@Numerical,
            matches : (\@Numerical, \@Numerical),
            is_associative : True,
            is_commutative : True,
            repeater : integral_nn_power,
        )),

        "*" : (\Alias : ( of : \@times )),

        Unicode_Aliases::"×" : (\Alias : ( of : \@times )),

        multiple_of::"" : (\Function : (
            virtual : True,
            returns : {\@Boolean, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical),
        )),

        nearest_multiple_of : (\Function : (
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
            evaluates : \(if is_zero args:.\1 then Excuse::Div_By_Zero()
                else guard args:.\1 * (args:.\0 div args:.\1)),
        )),

        round : (\Alias : ( of : \@nearest_multiple_of )),

        fractional_divided_by::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical),
        )),

        "/" : (\Alias : ( of : \@fractional_divided_by )),

        Unicode_Aliases::"÷" : (\Alias : ( of : \@fractional_divided_by )),
        Unicode_Aliases::"∕" : (\Alias : ( of : \@fractional_divided_by )),

        integral_divided_by::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
        )),

        div : (\Alias : ( of : \@integral_divided_by )),

        modulo : (\Function : (
            returns : {\@Numerical, \@Excuse::Div_By_Zero},
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
            evaluates : \(if is_zero args:.\1 then Excuse::Div_By_Zero()
                else guard args:.\0 - (args:.\0 nearest_multiple_of args:.\1)),
        )),

        mod : (\Alias : ( of : \@modulo )),

        divided_by_and_modulo::"" : (\Function : (
            returns : ({Numerical, Excuse::Div_By_Zero}, {Numerical, Excuse::Div_By_Zero}),
            matches : (\@Numerical, \@Numerical, \@Round_Meth),
            evaluates : \((args:.\0 div args:.\1, args:.\0 mod args:.\1)),
        )),

        integral_power::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Zero_To_The_Zero},
            matches : (\@Numerical, \@Integral),
        )),

        "**" : (\Alias : ( of : \@integral_power )),

        integral_nn_power::"" : (\Function : (
            virtual : True,
            returns : {\@Numerical, \@Excuse::Zero_To_The_Zero},
            matches : (\@Numerical, \@Integral::NN),
        )),

        power : (\Alias : ( of : \@integral_nn_power )),

`#########################################################################`

        Integral::"" : (\Interface : (
            composes : {\@Bicessable and_provides_its_default,
                \@Numerical and_provides_its_default},
            requires_implements : {in_order,asset,nth_pred,nth_succ
                ,to_Boolean
                ,zero,opposite,reciprocal,modulus
                ,plus,minus,times,multiple_of
                ,fractional_divided_by,integral_divided_by
                ,integral_power,integral_nn_power
                ,to_Integer,factorial},
        )),

        Integral::NN : (\Selection : (
            of : \@Integral,
            where : \(args:.\0 >= zero::(args:.\0)),
        )),

        Integral::P : (\Selection : (
            of : \@Integral::NN,
            where : \(args:.\0 > zero::(args:.\0)),
            default : \(succ::(Integral::())),
        )),

        "--" : (\Function : (
            returns : {\@Integral, \@Excuse::Before_All_Others},
            matches : (\@Integral),
            evaluates : \(pred args:.\0),
        )),

        "++" : (\Function : (
            returns : {\@Integral, \@Excuse::After_All_Others},
            matches : (\@Integral),
            evaluates : \(succ args:.\0),
        )),

        to_Integer::"" : (\Function : ( virtual : True, returns : \@Integer, matches : (\@Integral) )),

        factorial::"" : (\Function : ( virtual : True, returns : \@Integral::P, matches : (\@Integral::NN) )),

        gcd : (\Function : (
            returns : \@Integral::P,
            matches : (\@Integral::NN, \@Integral::NN),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : \((if is_zero args:.\1 then args:.\0 else guard material::(args:.\1, mod::(args:.\0, args:.\1, RM::(\To_Zero))))
                ::?= 'Calculate using the Euclidean algorithm.'),
        )),

        greatest_common_divisor : (\Alias : ( of : \@gcd )),

        lcm : (\Function : (
            returns : \@Integral::NN,
            matches : (\@Integral::NN, \@Integral::NN),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : \(if is_zero args:.\0 or is_zero args:.\1 then zero args:.\0
                else guard div::(args:.\0 * args:.\1, args:.\0 gcd args:.\1, RM::(\To_Zero))),
        )),

        least_common_multiple : (\Alias : ( of : \@lcm )),

        coprime : (\Function : (
            returns : \@Boolean,
            matches : (\@Integral, \@Integral),
            evaluates : \((abs::(args:.\0) gcd abs::(args:.\1)) = succ::(zero args:.\0)),
        )),

`#########################################################################`

        Integer::"" : (\Selection : (
            where : \(args --> \foundation::is_a_Integer::()),
            default : 0,
            composes : \@Integral and_provides_its_default,
        )),

        Integer::NN : (\Selection : ( of : \@Integer, where : \(args:.\0 >= 0) )),

        Integer::P : (\Selection : ( of : \@Integer::NN, where : \(args:.\0 > 0), default : 1 )),

        in_order::Integer : (\Function : (
            returns : \@Boolean,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Integer_in_order::()),
        )),

        asset::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        nth_pred::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer::NN),
            implements : \@folder::Integral,
            evaluates : \(args:.\0 - args:.\1),
        )),

        nth_succ::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer::NN),
            implements : \@folder::Integral,
            repeater : plus::Integer,
            evaluates : \(args:.\0 + args:.\1),
        )),

        to_Boolean::Integer : (\Function : (
            returns : \@Boolean,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : \(args:.\0 != 0),
        )),

        zero::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : \(0),
        )),

        opposite::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Integer_opposite::()),
        )),

        reciprocal::Integer : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : \(1 / args:.\0),
        )),

        modulus::Integer : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Integer_modulus::()),
        )),

        plus::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 0,
            repeater : times::Integer,
            evaluates : \(args --> \foundation::Integer_plus::()),
        )),

        minus::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Integer_minus::()),
        )),

        times::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 1,
            repeater : integral_nn_power::Integer,
            evaluates : \(args --> \foundation::Integer_times::()),
        )),

        multiple_of::Integer : (\Function : (
            returns : {\@Boolean, \@Excuse::Div_By_Zero},
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : \(if args:.\1 = 0 then Excuse::Div_By_Zero()
                else guard args --> \foundation::Integer_multiple_of::()),
        )),

        fractional_divided_by::Integer : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : \(
                n ::= args:.\0;
                d ::= args:.\1;

                returns if d = 0 then Excuse::Div_By_Zero() else guard q;

                q ::= (\Fraction : (
                    numerator   : div::((if d > 0 then n else -n), gcd, RM::(\To_Zero)),
                    denominator : div::((if d > 0 then d else -d), gcd, RM::(\To_Zero)),
                ));

                gcd ::= gcd::(abs::(n), abs::(d));
            ),
        )),

        integral_divided_by::Integer : (\Function : (
            returns : {\@Integer, \@Excuse::Div_By_Zero},
            matches : (\@Integer, \@Integer, \@Round_Meth),
            implements : \@folder::"",
            evaluates : \(
                dividend   ::= args:.\0;
                divisor    ::= args:.\1;
                round_meth ::= args:.\2;

                returns if divisor = 0 then Excuse::Div_By_Zero() else guard e1;

                e1 ::?= 'This is the case where we are dividing by a non-zero.';

                e1 ::=   if dividend = 0       then 0
                    else if divisor  = 1       then dividend
                    else if dividend = divisor then 1
                    else if divisor  = -1      then -dividend
                    else                            e2
                ;

                e2 ::?= 'This is the case where the divisor and dividend do not'
                    ' equal each other and neither of them is a zero or a one.';

                e2 ::= (
                    real_q_is_neg ::= dividend < 0 xor divisor < 0;
                    rtz_quotient  ::= \foundation::Integer_divided_by_rtz::()
                        <-- (dividend, divisor);
                    rtz_remainder ::= dividend - (divisor * rtz_quotient);

                    returns if rtz_remainder = 0 then rtz_quotient else e3;
                );

                e3 ::?= 'This is the case where the divisor does not divide the'
                    ' dividend evenly and the real number division result would'
                    ' have a fractional part, so we decide how to round that.';

                e3 ::= (
                    rti_quotient ::= rtz_quotient + (if real_q_is_neg then -1 else 1);
                    rdn_quotient ::= rtz_quotient + (if real_q_is_neg then -1 else 0);
                    rup_quotient ::= rtz_quotient + (if real_q_is_neg then  0 else 1);

                    returns given round_meth
                        when RM::(\Down)    then rdn_quotient
                        when RM::(\Up)      then rup_quotient
                        when RM::(\To_Zero) then rtz_quotient
                        when RM::(\To_Inf)  then rti_quotient
                        default
                                 if (2 * abs::(rtz_remainder)) < abs::(divisor) then rtz_quotient
                            else if (2 * abs::(rtz_remainder)) > abs::(divisor) then rti_quotient
                            else e4
                    ;
                );

                e4 ::?= 'This is the case where real division remainder is'
                    ' exactly one-half so we decide how to round that.';

                e4 ::= (
                    q ::= \foundation::Integer_divided_by_rtz::() <-- (abs::(rtz_quotient),2)
                    r ::= abs::(rtz_quotient) - (2 * q);
                    rtz_quotient_is_even ::= r = 0;

                    returns given round_meth
                        when RM::(\Half_Down)    then rdn_quotient
                        when RM::(\Half_Up)      then rup_quotient
                        when RM::(\Half_To_Zero) then rtz_quotient
                        when RM::(\Half_To_Inf)  then rti_quotient
                        when RM::(\Half_Even)    then
                            (if rtz_quotient_is_even then rtz_quotient else rti_quotient)
                        when RM::(\Half_Odd)     then
                            (if rtz_quotient_is_even then rti_quotient else rtz_quotient)
                        default fail  `oops, an unhandled case`
                    ;
                );
            ),
        )),

        integral_power::Integer : (\Function : (
            returns : {\@Fraction, \@Excuse::Zero_To_The_Zero},
            matches : (\@Integer, \@Integer),
            implements : \@folder::"",
            evaluates : \(if args:.\0 = 0 and args:.\1 = 0 then Excuse::Zero_To_The_Zero()
                else guard args:.\0 / 1 ** args:.\1),
        )),

        integral_nn_power::Integer : (\Function : (
            returns : {\@Integer, \@Excuse::Zero_To_The_Zero},
            matches : (\@Integer, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\0 = 0 and args:.\1 = 0 then Excuse::Zero_To_The_Zero()
                else guard args --> \foundation::Integer_nn_power::()),
        )),

        to_Integer::Integer : (\Function : (
            returns : \@Integer,
            matches : (\@Integer),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        factorial::Integer : (\Function : (
            returns : \@Integer::P,
            matches : (\@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Integer_factorial::()),
        )),

`#########################################################################`

        Fractional::"" : (\Interface : (
            composes : {\@Orderable and_provides_its_default,
                \@Numerical and_provides_its_default},
            requires_implements : {in_order
                ,to_Boolean
                ,zero,opposite,reciprocal,modulus
                ,plus,minus,times,multiple_of
                ,fractional_divided_by,integral_divided_by
                ,integral_power,integral_nn_power
                ,to_Fraction,numerator,denominator},
        )),

        Fractional::NN : (\Selection : (
            of : \@Fractional,
            where : \(args:.\0 >= zero::(args:.\0)),
        )),

        to_Fraction::"" : (\Function : ( virtual : True, returns : \@Fraction, matches : (\@Fractional) )),

        numerator::"" : (\Function : ( virtual : True, returns : \@Integral, matches : (\@Fractional) )),

        denominator::"" : (\Function : ( virtual : True, returns : \@Integral::P, matches : (\@Fractional) )),

`#########################################################################`

        Fraction::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Fraction, \(
                if
                    args:.\0 is_a (
                        numerator : \Integer::(),
                        denominator : \Integer::P::(),
                    )
                then guard
                    args:.\0.\numerator coprime args:.\0.\denominator
                else
                    False
            ) )),
            default : 0.0,
            composes : \@Fractional and_provides_its_default,
        )),

        Fraction::NN : (\Selection : ( of : \@Fraction, where : \(args:.\0 >= 0.0) )),

        in_order::Fraction : (\Function : (
            returns : \@Boolean,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            evaluates : \(
                <-- if(denominator args:.\0) = (denominator args:.\1)
                    then in_order::(numerator args:.\0, numerator args:.\1)
                 else
                  (
                    common_d ::= lcm::(denominator args:.\0, denominator args:.\1);
                    returns in_order::(
                        (numerator args:.\0) * div::(common_d, denominator args:.\0, RM::(\To_Zero)),
                        (numerator args:.\1) * div::(common_d, denominator args:.\1, RM::(\To_Zero)),
                    );
                  )
            ),
        )),

        to_Boolean::Fraction : (\Function : (
            returns : \@Boolean,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : \(args:.\0 != 0.0),
        )),

        zero::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : \(0.0),
        )),

        opposite::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : \(-(numerator args:.\0) / (denominator args:.\0)),
        )),

        reciprocal::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : \(if args:.\0 = 0.0 then Excuse::Div_By_Zero()
                else guard (denominator args:.\0) / (numerator args:.\0)),
        )),

        modulus::Fraction : (\Function : (
            returns : \@Fraction::NN,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : \(abs::(numerator args:.\0) / (denominator args:.\0)),
        )),

        plus::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 0.0,
            repeater : times::Fraction_Integer,
            evaluates : \(
                <-- if (denominator args:.\0) = (denominator args:.\1)
                    then (numerator args:.\0) + (numerator args:.\1) / (denominator args:.\0)
                 else
                  (
                    common_d ::= lcm::(denominator args:.\0, denominator args:.\1);
                    returns ((numerator args:.\0) * div::(common_d, denominator args:.\0, RM::(\To_Zero)))
                        + ((numerator args:.\1) * div::(common_d, denominator args:.\1, RM::(\To_Zero)))
                        / common_d;
                  )
            ),
        )),

        minus::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            evaluates : \(args:.\0 + -args:.\1),
        )),

        times::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : 1.0,
            repeater : integral_nn_power::Fraction,
            evaluates : \(((numerator args:.\0) * (numerator args:.\1))
                / ((denominator args:.\0) * (denominator args:.\1))),
        )),

        times::Fraction_Integer : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction, \@Integer),
            implements : \@folder::"",
            evaluates : \(((numerator args:.\0) * args:.\1) / (denominator args:.\0)),
        )),

        multiple_of::Fraction : (\Function : (
            returns : {\@Boolean, \@Excuse::Div_By_Zero},
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            evaluates : \(if args:.\1 = 0.0 then Excuse::Div_By_Zero()
                else guard (args:.\0 mod args:.\1) = 0.0),
        )),

        fractional_divided_by::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Fraction, \@Fraction),
            implements : \@folder::"",
            evaluates : \(if args:.\1 = 0.0 then Excuse::Div_By_Zero()
                else guard args:.\0 * reciprocal::(args:.\1)),
        )),

        integral_divided_by::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Div_By_Zero},
            matches : (\@Fraction, \@Fraction, \@Round_Meth),
            implements : \@folder::"",
            evaluates : \(
                d ::= lcm::(denominator args:.\0, denominator args:.\1);
                n0 ::= (numerator args:.\0) * div::(d, denominator args:.\0, RM::(\To_Zero));
                n1 ::= (numerator args:.\1) * div::(d, denominator args:.\1, RM::(\To_Zero));
                returns if args:.\1 = 0.0 then Excuse::Div_By_Zero()
                    else guard div::(n0 * d, n1 * d, args:.\2) / 1;
            ),
        )),

        integral_power::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Zero_To_The_Zero},
            matches : (\@Fraction, \@Integer),
            implements : \@folder::"",
            evaluates : \(\integral_nn_power::()
                <-- (if args:.\1 >= 0 then args else (reciprocal::(args:.\0), -args:.\1))),
        )),

        integral_nn_power::Fraction : (\Function : (
            returns : {\@Fraction, \@Excuse::Zero_To_The_Zero},
            matches : (\@Fraction, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\0 = 0.0 and args:.\1 = 0 then Excuse::Zero_To_The_Zero()
                else guard ((numerator args:.\0) ** args:.\1) / ((denominator args:.\0) ** args:.\1)),
        )),

        to_Fraction::Fraction : (\Function : (
            returns : \@Fraction,
            matches : (\@Fraction),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        numerator::Fraction : (\Function : (
            returns : \@Integer,
            matches : (\@Fraction),
            evaluates : \(args:.\0:>.\numerator),
        )),

        denominator::Fraction : (\Function : (
            returns : \@Integer::P,
            matches : (\@Fraction),
            evaluates : \(args:.\0:>.\denominator),
        )),

`#########################################################################`

        Emptyable : (\Interface : (
            composes : \@Boolable,
            requires_implements : {to_Boolean,empty},
        )),

        Excuse::No_Empty_Value : (\Constant : ( composes : \@Excuse )),

        to_Boolean::Emptyable : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Emptyable),
            implements : \@folder::"",
        )),

        has_any_members : (\Alias : ( of : \@to_Boolean::Emptyable )),

        is_empty : (\Function : ( negates : \@to_Boolean::Emptyable )),

        Unicode_Aliases::"∅?" : (\Alias : ( of : \@is_empty )),

        empty::"" : (\Function : (
            virtual : True,
            returns : {\@Emptyable, \@Excuse::No_Empty_Value},
            matches : (\@Emptyable),
        )),

        Unicode_Aliases::"∅" : (\Alias : ( of : \@empty )),

`#########################################################################`

        Stringy : (\Interface : (
            composes : {\@Orderable, \@Emptyable and_provides_its_default},
            requires_implements : {in_order,to_Boolean,empty
                ,substring_of,overlaps_string,disjoint_string
                ,catenate,replicate},
        )),

        substring_of::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Stringy, \@Stringy),
        )),

        superstring_of : (\Function : ( commutes : \@substring_of )),

        proper_substring_or_superstring : (\Function : (
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
            evaluates : \(args:.\0 != args:.\1 and (args:.\0 substring_or_superstring args:.\1)),
        )),

        substring_or_superstring : (\Function : (
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
            evaluates : \((args:.\0 substring_of args:.\1) or (args:.\0 superstring_of args:.\1)),
        )),

        overlaps_string::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
        )),

        disjoint_string::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@String, \@String),
            is_commutative : True,
        )),

        catenate::"" : (\Function : (
            virtual : True,
            returns : \@Stringy,
            matches : (\@Stringy, \@Stringy),
            is_associative : True,
            repeater : replicate,
        )),

        "~" : (\Alias : ( of : \@catenate )),

        replicate::"" : (\Function : (
            virtual : True,
            returns : \@Stringy,
            matches : (\@Stringy, \@Integer::NN),
        )),

        "~#" : (\Alias : ( of : \@replicate )),

`#########################################################################`

        Bits : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Bits, \String::Bits() )),
            default : \~?'',
            composes : {\@Stringy and_provides_its_default},
        )),

        String::Bits : (\Selection : (
            of : \@String,
            where : \(args:.\0 all \in::( 1: 0..1 )),
        )),

        in_order::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            evaluates : \((Bits_to_String_Bits args:.\0) in_order (Bits_to_String_Bits args:.\1)),
        )),

        to_Boolean::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits),
            implements : \@folder::"",
            evaluates : \(args:.\0 != \~?''),
        )),

        empty::Bits : (\Function : (
            returns : \@Bits,
            matches : (\@Bits),
            implements : \@folder::"",
            evaluates : \(\~?''),
        )),

        substring_of::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            evaluates : \((Bits_to_String_Bits args:.\0) substring_of (Bits_to_String_Bits args:.\1)),
        )),

        overlaps_string::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((Bits_to_String_Bits args:.\0)
                overlaps_string (Bits_to_String_Bits args:.\1)),
        )),

        disjoint_string::Bits : (\Function : (
            returns : \@Boolean,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((Bits_to_String_Bits args:.\0)
                disjoint_string (Bits_to_String_Bits args:.\1)),
        )),

        catenate::Bits : (\Function : (
            returns : \@Bits,
            matches : (\@Bits, \@Bits),
            implements : \@folder::"",
            is_associative : True,
            identity : \~?'',
            repeater : replicate::Bits,
            evaluates : \(Bits_from_String_Bits::((Bits_to_String_Bits args:.\0)
                ~ (Bits_to_String_Bits args:.\1))),
        )),

        replicate::Bits : (\Function : (
            returns : \@Bits,
            matches : (\@Bits, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(Bits_from_String_Bits::((Bits_to_String_Bits args:.\0) ~# args:.\1)),
        )),

        Bits_from_String_Bits : (\Function : (
            returns : \@Bits,
            matches : (\@String::Bits),
            evaluates : \((\Bits : args:.\0)),
        )),

        Bits_to_String_Bits : (\Function : (
            returns : \@String::Bits,
            matches : (\@Bits),
            evaluates : \(args:.\0:>),
        )),

`#########################################################################`

        Blob : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Blob, \String::Octets() )),
            default : \~+'',
            composes : \@Stringy,
        )),

        String::Octets : (\Selection : (
            of : \@String,
            where : \(args:.\0 all \in::( 1: 0..255 )),
        )),

        in_order::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            evaluates : \((Blob_to_Octets args:.\0) in_order (Blob_to_Octets args:.\1)),
        )),

        to_Boolean::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob),
            implements : \@folder::"",
            evaluates : \(args:.\0 != \~+''),
        )),

        empty::Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Blob),
            implements : \@folder::"",
            evaluates : \(\~+''),
        )),

        substring_of::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            evaluates : \((Blob_to_Octets args:.\0) substring_of (Blob_to_Octets args:.\1)),
        )),

        overlaps_string::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((Blob_to_Octets args:.\0) overlaps_string (Blob_to_Octets args:.\1)),
        )),

        disjoint_string::Blob : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((Blob_to_Octets args:.\0) disjoint_string (Blob_to_Octets args:.\1)),
        )),

        catenate::Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Blob, \@Blob),
            implements : \@folder::"",
            is_associative : True,
            identity : \~+'',
            repeater : replicate::Blob,
            evaluates : \(Blob_from_Octets::((Blob_to_Octets args:.\0) ~ (Blob_to_Octets args:.\1))),
        )),

        replicate::Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Blob, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(Blob_from_Octets::((Blob_to_Octets args:.\0) ~# args:.\1)),
        )),

        Blob_from_Octets : (\Function : (
            returns : \@Blob,
            matches : (\@String::Octets),
            evaluates : \((\Blob : args:.\0)),
        )),

        Blob_to_Octets : (\Function : (
            returns : \@String::Octets,
            matches : (\@Blob),
            evaluates : \(args:.\0:>),
        )),

`#########################################################################`

        Textual : (\Interface : (
            composes : \@Stringy,
            requires_implements : {in_order,to_Boolean,empty
                ,substring_of,overlaps_string,disjoint_string
                ,catenate,replicate
                ,to_Text},
        )),

        to_Text::"" : (\Function : ( virtual : True, returns : \@Text, matches : (\@Textual) )),

`#########################################################################`

        Text::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Text, \String::Maximal_Chars() )),
            default : '',
            composes : {\@Textual and_provides_its_default},
        )),

        String::Maximal_Chars : (\Alias : ( of : \@String )),

        Text::Unicode : (\Selection : (
            of : \@Text,
            where : \(String::Unicode_Codes::(Text_from_Maximal_Chars args:.\0)),
        )),

        String::Unicode_Codes : (\Selection : (
            of : \@String::Maximal_Chars,
            where : \(args:.\0 all \in::( 1: ?..{0..0xD7FF,0xE000..0x10FFFF} )),
        )),

        Text::ASCII : (\Selection : (
            of : \@Text::Unicode,
            where : \(String::ASCII_Chars::(Text_from_Unicode_Codes args:.\0)),
        )),

        String::ASCII_Chars : (\Selection : (
            of : \@String::Unicode_Codes,
            where : \(args:.\0 all \in::( 1: 0..127 )),
        )),

        in_order::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            evaluates : \((Text_to_Maximal_Chars args:.\0) in_order (Text_to_Maximal_Chars args:.\1)),
        )),

        to_Boolean::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text),
            implements : \@folder::"",
            evaluates : \(args:.\0 != ''),
        )),

        empty::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text),
            implements : \@folder::"",
            evaluates : \(''),
        )),

        substring_of::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            evaluates : \((Text_to_Maximal_Chars args:.\0)
                substring_of (Text_to_Maximal_Chars args:.\1)),
        )),

        overlaps_string::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((Text_to_Maximal_Chars args:.\0)
                overlaps_string (Text_to_Maximal_Chars args:.\1)),
        )),

        disjoint_string::Text : (\Function : (
            returns : \@Boolean,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((Text_to_Maximal_Chars args:.\0)
                disjoint_string (Text_to_Maximal_Chars args:.\1)),
        )),

        catenate::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text, \@Text),
            implements : \@folder::"",
            is_associative : True,
            identity : '',
            repeater : replicate::Text,
            evaluates : \(Text_from_Maximal_Chars::((Text_to_Maximal_Chars args:.\0)
                ~ (Text_to_Maximal_Chars args:.\1))),
        )),

        replicate::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(Text_from_Maximal_Chars::((Text_to_Maximal_Chars args:.\0) ~# args:.\1)),
        )),

        to_Text::Text : (\Function : (
            returns : \@Text,
            matches : (\@Text),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        Text_from_Maximal_Chars : (\Function : (
            returns : \@Text,
            matches : (\@String::Maximal_Chars),
            evaluates : \((\Text : args:.\0)),
        )),

        Text_to_Maximal_Chars : (\Function : (
            returns : \@String::Maximal_Chars,
            matches : (\@Text),
            evaluates : \(args:.\0:>),
        )),

        Text_from_Unicode_Codes : (\Function : (
            returns : \@Text::Unicode,
            matches : (\@String::Unicode_Codes),
            evaluates : \(Text_from_Maximal_Chars args:.\0),
        )),

        Text_to_Unicode_Codes : (\Function : (
            returns : \@String::Unicode_Codes,
            matches : (\@Text::Unicode),
            evaluates : \(Text_to_Maximal_Chars args:.\0),
        )),

        Text_from_ASCII_Chars : (\Function : (
            returns : \@Text::ASCII,
            matches : (\@String::ASCII_Chars),
            evaluates : \(Text_from_Unicode_Codes args:.\0),
        )),

        Text_to_ASCII_Chars : (\Function : (
            returns : \@String::ASCII_Chars,
            matches : (\@Text::ASCII),
            evaluates : \(Text_to_Unicode_Codes args:.\0),
        )),

        Blob_is_UTF_8 : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob),
            evaluates : \(...),
        )),

        Text_from_UTF_8_Blob : (\Function : (
            returns : {\@Text::Unicode, \@Excuse::Unicode::..., ...},
            matches : (\@Blob),
            evaluates : \(...),
        )),

        Text_from_UTF_8_Blob_with_repl_Text : (\Function : (
            returns : \@Text::Unicode,
            matches : (\@Blob, \@Text::Unicode),
            evaluates : \(...),
        )),

        Text_from_UTF_8_Blob_with_repl_char : (\Function : (
            returns : \@Text::Unicode,
            matches : (\@Blob),
            evaluates : \(Text_from_UTF_8_Blob_with_repl_Text::(args:.\0,'\\c<0xFFFD>')),
        )),

        Text_to_UTF_8_Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Text::Unicode),
            evaluates : \(...),
        )),

        Blob_is_ASCII : (\Function : (
            returns : \@Boolean,
            matches : (\@Blob),
            evaluates : \(String::ASCII_Chars(Blob_to_Octets args:.\0)),
        )),

        Text_from_ASCII_Blob : (\Function : (
            returns : {\@Text::ASCII, \@Excuse::ASCII::High_Bit_Not_Zero},
            matches : (\@Blob),
            evaluates : \(
                octets ::= Blob_to_Octets args:.\0;
                returns if String::ASCII_Chars(octets)
                    then guard Text_from_ASCII_Chars octets
                    else Excuse::ASCII::High_Bit_Not_Zero();
            ),
        )),

        Text_from_ASCII_Blob_with_repl_Text : (\Function : (
            returns : \@Text::ASCII,
            matches : (\@Blob, \@Text::ASCII),
            evaluates : \(
                src_octets ::= Blob_to_Octets args:.\0;
                repl_chars ::= Text_to_ASCII_Chars args:.\1;
                result_chars ::=
                    given #repl_chars
                        when 0 then
                            src_octets where \in::( 1: 0..127 )
                        when 1 then guard
                            src_octets
                                map \(if args:.\0 in 0..127 then args:.\0 else args:.\1)
                                    \<-- (1 : repl_chars.0,)
                        default
                            src_octets
                                map \(if args:.\0 in 0..127 then [args:.\0] else args:.\1)
                                    \<-- (1 : repl_chars,)
                                reduce \catenate::()
                    ;
                returns Text_from_ASCII_Chars result_chars;
            ),
        )),

        Text_to_ASCII_Blob : (\Function : (
            returns : \@Blob,
            matches : (\@Text::ASCII),
            evaluates : \(Blob_from_Octets::(Text_to_ASCII_Chars args:.\0)),
        )),

`#########################################################################`

        Accessible : (\Interface : (
            requires_implements : {has_any_at,has_mapping_at
                ,mapping_at,at,maybe_at
                ,replace_at,shiftless_insert_at,shiftless_remove_at
                ,replace_or_insert_at,shiftless_maybe_remove_at},
        )),

        has_any_at::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Accessible, \@Any),
        )),

        ".?" : (\Alias : ( of : \@has_any_at )),

        not_has_any_at : (\Function : ( negates : \@has_any_at )),

        ".!?" : (\Alias : ( of : \@not_has_any_at )),

        has_mapping_at::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (Accessible, (Any, Any)),
        )),

        ".:?" : (\Alias : ( of : \@has_mapping_at )),

        mapping_at::"" : (\Function : (
            virtual : True,
            returns : (\@Any, \@Any),
            matches : (\@Accessible, \@Any),
            accepts : \(args:.\0 .? args:.\1),
        )),

        ".:" : (\Alias : ( of : \@mapping_at )),

        at::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Accessible, \@Any),
            accepts : \(args:.\0 .? args:.\1),
        )),

        "." : (\Alias : ( of : \@at )),

        maybe_at::"" : (\Function : ( virtual : True, returns : \@Any, matches : (\@Accessible, \@Any) )),

        ".!" : (\Alias : ( of : \@maybe_at )),

        replace_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (Accessible, (Any, Any)),
            accepts : \(args:.\0 .? (args:.\1.\0)),
        )),

        ".:=" : (\Alias : ( of : \@replace_at )),

        shiftless_insert_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (Accessible, (Any, Any)),
            accepts : \(not args:.\0 .? (args:.\1.\0)),
        )),

        ".+" : (\Alias : ( of : \@shiftless_insert_at )),

        shiftless_remove_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (\@Accessible, \@Any),
            accepts : \(args:.\0 .? args:.\1),
        )),

        ".-" : (\Alias : ( of : \@shiftless_remove_at )),

        replace_or_insert_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (Accessible, (Any, Any)),
        )),

        ".=+" : (\Alias : ( of : \@replace_or_insert_at )),

        shiftless_maybe_remove_at::"" : (\Function : (
            virtual : True,
            returns : \@Accessible,
            matches : (\@Accessible, \@Any),
        )),

        ".?-" : (\Alias : ( of : \@shiftless_maybe_remove_at )),

`#########################################################################`

        Homogeneous : (\Interface : (
            composes : \@Emptyable,
            requires_implements : {to_Boolean,empty
                ,singular,only_member
                ,has_n,multiplicity
                ,all_unique,unique
                ,subset_of,same_members,overlaps_members,disjoint_members
                ,any},
        )),

        singular::"" : (\Function : ( virtual : True, returns : \@Boolean, matches : (\@Homogeneous) )),

        only_member::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Homogeneous),
            accepts : \(singular args:.\0),
        )),

        in : (\Function : ( commutes : \@has )),

        Unicode_Aliases::"∈" : (\Alias : ( of : \@in )),

        not_in : (\Function : ( commutes : \@not_has )),

        Unicode_Aliases::"∉" : (\Alias : ( of : \@not_in )),

        has : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Any),
            evaluates : \(has_n::(args:.\0, args:.\1, 1)),
        )),

        Unicode_Aliases::"∋" : (\Alias : ( of : \@has )),

        not_has : (\Function : ( negates : \@has )),

        Unicode_Aliases::"∌" : (\Alias : ( of : \@not_has )),

        has_n::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Any, \@Integer::NN),
        )),

        multiplicity::"" : (\Function : (
            virtual : True,
            returns : \@Integer::NN,
            matches : (\@Homogeneous, \@Any),
        )),

        all_unique::"" : (\Function : ( virtual : True, returns : \@Boolean, matches : (\@Homogeneous) )),

        unique::"" : (\Function : ( virtual : True, returns : \@Homogeneous, matches : (\@Homogeneous) )),

        proper_subset_of : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            evaluates : \(args:.\0 != args:.\1 and (args:.\0 subset_of args:.\1)),
        )),

        Unicode_Aliases::"⊂" : (\Alias : ( of : \@proper_subset_of )),

        not_proper_subset_of : (\Function : ( negates : \@proper_subset_of )),

        Unicode_Aliases::"⊄" : (\Alias : ( of : \@not_proper_subset_of )),

        proper_superset_of : (\Function : ( commutes : \@proper_subset_of )),

        Unicode_Aliases::"⊃" : (\Alias : ( of : \@proper_superset_of )),

        not_proper_superset_of : (\Function : ( negates : \@proper_superset_of )),

        Unicode_Aliases::"⊅" : (\Alias : ( of : \@not_proper_superset_of )),

        subset_of::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
        )),

        Unicode_Aliases::"⊆" : (\Alias : ( of : \@subset_of )),

        not_subset_of : (\Function : ( negates : \@subset_of )),

        Unicode_Aliases::"⊈" : (\Alias : ( of : \@not_subset_of )),

        superset_of : (\Function : ( commutes : \@subset_of )),

        Unicode_Aliases::"⊇" : (\Alias : ( of : \@superset_of )),

        not_superset_of : (\Function : ( negates : \@superset_of )),

        Unicode_Aliases::"⊉" : (\Alias : ( of : \@not_superset_of )),

        same_members::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
        )),

        proper_subset_or_superset : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
            evaluates : \(not (args:.\0 same_members args:.\1) and (args:.\0 subset_or_superset args:.\1)),
        )),

        subset_or_superset : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
            evaluates : \((args:.\0 subset_of args:.\1) or (args:.\0 superset_of args:.\1)),
        )),

        overlaps_members::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
        )),

        disjoint_members::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Homogeneous),
            is_commutative : True,
        )),

        any::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Signature),
        )),

        there_exists : (\Alias : ( of : \@any )),

        Unicode_Aliases::"∃" : (\Alias : ( of : \@any )),

        none : (\Function : ( negates : \@any )),

        there_does_not_exist : (\Alias : ( of : \@none )),

        Unicode_Aliases::"∄" : (\Alias : ( of : \@none )),

        all : (\Function : (
            returns : \@Boolean,
            matches : (\@Homogeneous, \@Signature),
            evaluates : \(args:.\0 none \not_is_a::( 1: args:.\1 )),
        )),

        for_all : (\Alias : ( of : \@all )),

        Unicode_Aliases::"∀" : (\Alias : ( of : \@all )),

        not_all : (\Function : ( negates : \@all )),

`#########################################################################`

        Unionable : (\Interface : (
            composes : \@Homogeneous,
            requires_implements : {to_Boolean,empty
                ,singular,only_member
                ,has_n,multiplicity
                ,all_unique,unique
                ,subset_of,same_members,overlaps_members,disjoint_members
                ,any
                ,insert_n,remove_n
                ,member_plus,except,intersect,union,exclusive
                ,nest,unnest,where,map,reduce,...},
        )),

        insert : (\Function : (
            returns : \@Unionable,
            matches : (\@Unionable, \@Any),
            evaluates : \(insert_n::(args:.\0, args:.\1, 1)),
        )),

        insert_n::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Any, \@Integer::NN),
        )),

        remove : (\Function : (
            returns : \@Unionable,
            matches : (\@Unionable, \@Any),
            evaluates : \(remove_n::(args:.\0, args:.\1, 1)),
        )),

        remove_n::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Any, \@Integer::NN),
        )),

        member_plus::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
            is_associative : True,
        )),

        Unicode_Aliases::"⊎" : (\Alias : ( of : \@member_plus )),

        except::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
        )),

        Unicode_Aliases::"∖" : (\Alias : ( of : \@except )),

        intersect::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
            is_associative : True,
            is_idempotent : True,
        )),

        Unicode_Aliases::"∩" : (\Alias : ( of : \@intersect )),

        union::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
            is_idempotent : True,
        )),

        Unicode_Aliases::"∪" : (\Alias : ( of : \@union )),

        exclusive::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Unionable),
        )),

        symm_diff : (\Alias : ( of : \@exclusive )),

        Unicode_Aliases::"∆" : (\Alias : ( of : \@exclusive )),

        nest::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable),
            accepts : \(...),
        )),

        group : (\Alias : ( of : \@nest )),

        unnest::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable),
            accepts : \(...),
        )),

        ungroup : (\Alias : ( of : \@unnest )),

        where::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Signature),
        )),

        Unicode_Aliases::"σ" : (\Alias : ( of : \@where )),

        filtering : (\Function : ( commutes : \@where )),

        map::"" : (\Function : (
            virtual : True,
            returns : \@Unionable,
            matches : (\@Unionable, \@Function_Call_But_0),
        )),

        reduce::"" : (\Function : (
            virtual : True,
            returns : \@Any,
            matches : (\@Unionable, \@Function_Call_But_0_1),
        )),

`#########################################################################`

        Discrete : (\Interface : (
            composes : \@Unionable and_provides_its_default,
            requires_implements : {to_Boolean,empty
                ,singular,only_member
                ,has_n,multiplicity
                ,all_unique,unique
                ,subset_of,same_members,overlaps_members,disjoint_members
                ,any
                ,insert_n,remove_n
                ,member_plus,except,intersect,union,exclusive
                ,nest,unnest,where,map,reduce,...
                ,to_Set,to_Bag,count,unique_count,order_using},
        )),

        to_Set::"" : (\Function : ( virtual : True, returns : \@Set, matches : (\@Discrete) )),

        "?|" : (\Alias : ( of : \@to_Set )),

        to_Bag::"" : (\Function : ( virtual : True, returns : \@Bag, matches : (\@Discrete) )),

        "+|" : (\Alias : ( of : \@to_Bag )),

        count::"" : (\Function : ( virtual : True, returns : \@Integer::NN, matches : (\@Discrete) )),

        cardinality : (\Alias : ( of : \@count )),
        "#"         : (\Alias : ( of : \@count )),

        unique_count::"" : (\Function : ( virtual : True, returns : \@Integer::NN, matches : (\@Discrete) )),

        order : (\Function : (
            returns : \@Positional,
            matches : (\@Discrete),
            evaluates : \(args:.\0 order_using \in_order::()),
        )),

        order_using::"" : (\Function : (
            virtual : True,
            returns : \@Positional,
            matches : (\@Discrete, \@Function_Call_But_0_1),
        )),

`#########################################################################`

        Positional : (\Interface : (
            composes : {\@Stringy, \@Discrete and_provides_its_default, \@Accessible},
            requires_implements : {in_order,to_Boolean,empty
                ,substring_of,overlaps_string,disjoint_string
                ,catenate,replicate
                ,has_n,multiplicity
                ,all_unique,unique
                ,any
                ,insert_n,remove_n
                ,except,intersect,union,exclusive
                ,nest,unnest,where,map,reduce,...
                ,to_Set,to_Bag,count,order_using
                ,at
                ,to_Array
                ,first_possible_ord_pos,slice_n,ord_pos_succ_all_matches,...},
        )),

        Excuse::No_Such_Ord_Pos : (\Constant : ( composes : \@Excuse )),

        singular::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional),
            implements : \@folder::"",
            evaluates : \((unique_count args:.\0) = 1),
        )),

        only_member::Positional : (\Function : (
            returns : \@Any,
            matches : (\@Positional),
            implements : \@folder::"",
            accepts : \(singular args:.\0),
            evaluates : \(first args:.\0),
        )),

        subset_of::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            evaluates : \((to_Bag args:.\0) subset_of (to_Bag args:.\1)),
        )),

        same_members::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((to_Bag args:.\0) same_members (to_Bag args:.\1)),
        )),

        overlaps_members::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((to_Bag args:.\0) overlaps_members (to_Bag args:.\1)),
        )),

        disjoint_members::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \((to_Bag args:.\0) disjoint_members (to_Bag args:.\1)),
        )),

        member_plus::Positional : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Positional),
            implements : \@folder::"",
            is_associative : True,
            evaluates : \(args:.\0 ~ args:.\1),
        )),

        unique_count::Positional : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Positional),
            implements : \@folder::"",
            evaluates : \(count::(to_Set args:.\0)),
        )),

        has_any_at::Positional : (\Function : (
            returns : \@Boolean,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            evaluates : \(args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 < first_unused_ord_pos::(args:.\0)),
        )),

        has_mapping_at::Positional : (\Function : (
            returns : \@Boolean,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            evaluates : \(if args:.\0 .? (args:.\1.\0) then guard args:.\0.(args:.\1.\0) = (args:.\1.\1) else False),
        )),

        mapping_at::Positional : (\Function : (
            returns : (\@Integer, \@Any),
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            accepts : \(args:.\0 .? args:.\1),
            evaluates : \((args:.\1, args:.\0.args:.\1)),
        )),

        maybe_at::Positional : (\Function : (
            returns : \@Any,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            evaluates : \(if args:.\0 .? args:.\1 then guard args:.\0.args:.\1 else Excuse::No_Such_Ord_Pos()),
        )),

        replace_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            accepts : \(args:.\0 .? (args:.\1.\0)),
            evaluates : \(
                src ::= args:.\0;
                rop ::= args:.\1.\0;
                repl_member ::= args:.\1.\1;
                fop ::= first_ord_pos src;
                lop ::= last_ord_pos src;
                emp ::= empty src;
                returns (if rop > fop then guard slice_range::(src, fop, --rop) else emp)
                    insert repl_member
                    catenate (if rop < lop then guard slice_range::(src, ++rop, lop) else emp);
            ),
        )),

        shiftless_insert_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            accepts : \(args:.\1.\0 = first_unused_ord_pos::(args:.\0)),
            evaluates : \(args:.\0 insert args:.\1.\1),
        )),

        shiftless_remove_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            accepts : \(args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 = --first_unused_ord_pos::(args:.\0)),
            evaluates : \(nonlast args:.\0),
        )),

        replace_or_insert_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (Positional, (Integer, Any)),
            implements : \@folder::"",
            accepts : \(args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 <= first_unused_ord_pos::(args:.\0)),
            evaluates : \(if args:.\0 .? (args:.\1.\0) then guard args:.\0 .:= (args:.\1.\0) else guard args:.\0 .+ (args:.\1.\0)),
        )),

        shiftless_maybe_remove_at::Positional : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Integer),
            implements : \@folder::"",
            accepts : \(args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 >= --first_unused_ord_pos::(args:.\0)),
            evaluates : \(if args:.\1 = --first_unused_ord_pos::(args:.\0) then guard nonlast args:.\0 else args:.\0),
        )),

        to_Array::"" : (\Function : ( virtual : True, returns : \@Array, matches : (\@Positional) )),

        "~|" : (\Alias : ( of : \@to_Array )),

        squish : (\Function : (
            returns : \@Positional,
            matches : (\@Positional),
            evaluates : \(args:.\0 map \(( group : args:.\0, member : False ))
                pipe nest map \(args:.\0.\group)),
        )),

        first_possible_ord_pos::"" : (\Function : (
            virtual : True,
            returns : \@Integer,
            matches : (\@Positional),
        )),

        first_unused_ord_pos : (\Function : (
            returns : \@Integer,
            matches : (\@Positional),
            evaluates : \(first_possible_ord_pos::(args:.\0) + #args:.\0),
        )),

        first_ord_pos : (\Function : (
            returns : \@Integer,
            matches : (\@Positional),
            accepts : \(so args:.\0),
            evaluates : \(first_possible_ord_pos::(args:.\0)),
        )),

        last_ord_pos : (\Function : (
            returns : \@Integer,
            matches : (\@Positional),
            accepts : \(so args:.\0),
            evaluates : \(--first_unused_ord_pos::(args:.\0)),
        )),

        slice_n::"" : (\Function : (
            virtual : True,
            returns : \@Positional,
            matches : (\@Positional, \@Integer, \@NN_Integer),
            accepts : \(args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 + args:.\2 <= first_unused_ord_pos::(args:.\0)),
        )),

        slice_range : (\Function : (
            returns : \@Positional,
            matches : (\@Positional, \@Integer, \@Integer),
            accepts : \(so args:.\0 and args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\2 < first_unused_ord_pos::(args:.\0)),
            evaluates : \(slice_n::(args:.\0, args:.\1, args:.\2 - args:.\1 + 1)),
        )),

        first : (\Function : (
            returns : \@Any,
            matches : (\@Positional),
            accepts : \(so args:.\0),
            evaluates : \(args:.\0 . first_ord_pos::(args:.\0)),
        )),

        nonfirst : (\Function : (
            returns : \@Positional,
            matches : (\@Positional),
            accepts : \(so args:.\0),
            evaluates : \(slice_range::(args:.\0, ++first_ord_pos::(args:.\0), last_ord_pos::(args:.\0))),
        )),

        last : (\Function : (
            returns : \@Any,
            matches : (\@Positional),
            accepts : \(so args:.\0),
            evaluates : \(args:.\0 . last_ord_pos::(args:.\0)),
        )),

        nonlast : (\Function : (
            returns : \@Positional,
            matches : (\@Positional),
            accepts : \(so args:.\0),
            evaluates : \(slice_range::(args:.\0, first_ord_pos::(args:.\0), --last_ord_pos::(args:.\0))),
        )),

        ord_pos_succ_all_matches::"" : (\Function : (
            virtual : True,
            returns : \@Integer,
            matches : (\@Positional, \@Positional),
            is_commutative : True,
        )),

`#########################################################################`

        Array::"" : (\Selection : (
            where : \(args --> \foundation::is_a_Array::()),
            default : [],
            composes : \@Positional and_provides_its_default,
        )),

        String::"" : (\Selection : ( of : \@Array, where : \(args:.\0 all \Integer::()) )),

        Array::Empty : (\Constant : ( value : [] )),

        Unicode_Aliases::"~∅" : (\Alias : ( of : \@Array::Empty )),

        in_order::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            evaluates : \(
                i ::= args:.\0 ord_pos_succ_all_matches args:.\1;
              returns
                if not args:.\0 .? i then
                    e1 ::= True
                else if not args:.\1 .? i then
                    False
                else guard
                    e2 ::= args:.\0.i in_order args:.\1.i;

                e1 ::?= 'This is the case where LHS is a leading subsequence of or is equal to RHS.';
                e2 ::?= 'This will succeed iff in_order() is defined for the member type.';
            ),
        )),

        to_Boolean::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(args:.\0 != []),
        )),

        empty::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \([]),
        )),

        substring_of::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_substring_of::()),
        )),

        overlaps_string::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args --> \foundation::Array_overlaps_string::()),
        )),

        disjoint_string::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args --> \foundation::Array_disjoint_string::()),
        )),

        catenate::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_associative : True,
            identity : [],
            repeater : replicate::Array,
            evaluates : \(args --> \foundation::Array_catenate::()),
        )),

        replicate::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_replicate::()),
        )),

        has_n::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_has_n::()),
        )),

        multiplicity::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array, \@Any),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_multiplicity::()),
        )),

        all_unique::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_all_unique::()),
        )),

        unique::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_unique::()),
        )),

        any::Array : (\Function : (
            returns : \@Boolean,
            matches : (\@Array, \@Signature),
            implements : \@folder::"",
            evaluates : \((args:.\0, Signature_to_Function_Call_But_0::(args:.\1)) --> \foundation::Array_any::()),
        )),

        insert_n::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_insert_n::()),
        )),

        remove_n::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_remove_n::()),
        )),

        except::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_except::()),
        )),

        intersect::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_associative : True,
            is_idempotent : True,
            evaluates : \(args --> \foundation::Array_intersect::()),
        )),

        union::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_idempotent : True,
            identity : [],
            evaluates : \(args --> \foundation::Array_union::()),
        )),

        exclusive::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            identity : [],
            evaluates : \(args --> \foundation::Array_exclusive::()),
        )),

        nest::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(args --> \foundation::Array_nest::()),
        )),

        unnest::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(args --> \foundation::Array_unnest::()),
        )),

        where::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Signature),
            implements : \@folder::"",
            evaluates : \((args:.\0, Signature_to_Function_Call_But_0::(args:.\1))
                --> \foundation::Array_where::()),
        )),

        map::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_map::()),
        )),

        reduce::Array : (\Function : (
            returns : \@Any,
            matches : (\@Array, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_reduce::()),
        )),

        to_Set::Array : (\Function : (
            returns : \@Set,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(to_Set::(to_Bag args:.\0)),
        )),

        to_Bag::Array : (\Function : (
            returns : \@Bag,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_to_Bag::()),
        )),

        count::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_count::()),
        )),

        order_using::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Array_order_using::()),
        )),

        at::Array : (\Function : (
            returns : \@Any,
            matches : (\@Array, \@Integer::NN),
            implements : \@folder::"",
            accepts : \(args:.\0 .? args:.\1),
            evaluates : \(args --> \foundation::Array_at::()),
        )),

        to_Array::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        first_possible_ord_pos::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array),
            implements : \@folder::"",
            evaluates : \(0),
        )),

        slice_n::Array : (\Function : (
            returns : \@Array,
            matches : (\@Array, \@NN_Integer, \@NN_Integer),
            implements : \@folder::"",
            accepts : \(args:.\1 + args:.\2 <= #args:.\0),
            evaluates : \(args --> \foundation::Array_slice_n::()),
        )),

        ord_pos_succ_all_matches::Array : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Array, \@Array),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args --> \foundation::Array_ord_pos_succ_all_matches::()),
        )),

`#########################################################################`

        Setty : (\Interface : ()),

`#########################################################################`

        Set::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Set,
                \(if Bag args:.\0 then guard all_unique args:.\0 else False) )),
            default : {},
            composes : {\@Discrete, \@Setty and_provides_its_default},
        )),

        Set::Empty : (\Constant : ( value : {} )),

        Unicode_Aliases::"?∅" : (\Alias : ( of : \@Set::Empty )),

        to_Boolean::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(args:.\0 != {}),
        )),

        empty::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \({}),
        )),

        singular::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(singular args:.\0:>),
        )),

        only_member::Set : (\Function : (
            returns : \@Any,
            matches : (\@Set),
            implements : \@folder::"",
            accepts : \(singular args:.\0),
            evaluates : \(only_member args:.\0:>),
        )),

        has_n::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(has_n::(args:.\0:>, args:.\1, args:.\2)),
        )),

        multiplicity::Set : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Set, \@Any),
            implements : \@folder::"",
            evaluates : \(args:.\0:> multiplicity args:.\1),
        )),

        all_unique::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(True),
        )),

        unique::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        subset_of::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            evaluates : \(args:.\0:> subset_of args:.\1:>),
        )),

        same_members::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args:.\0 = args:.\1),
        )),

        overlaps_members::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args:.\0:> overlaps_members args:.\1:>),
        )),

        disjoint_members::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args:.\0:> disjoint_members args:.\1:>),
        )),

        any::Set : (\Function : (
            returns : \@Boolean,
            matches : (\@Set, \@Signature),
            implements : \@folder::"",
            evaluates : \(args:.\0:> any args:.\1),
        )),

        insert_n::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\0 has args:.\1 or args:.\2 = 0 then args:.\0
                else (\Set : insert_n::(args:.\0:>, args:.\1, 1))),
        )),

        remove_n::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \((\Set : remove_n::(args:.\0:>, args:.\1, args:.\2))),
        )),

        member_plus::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {},
            evaluates : \(args:.\0 union args:.\1),
        )),

        except::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            evaluates : \((\Set : (args:.\0:> except args:.\1:>))),
        )),

        intersect::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : \((\Set : (args:.\0:> intersect args:.\1:>))),
        )),

        union::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {},
            evaluates : \((\Set : (args:.\0:> union args:.\1:>))),
        )),

        exclusive::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Set),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : {},
            evaluates : \((\Set : (args:.\0:> exclusive args:.\1:>))),
        )),

        nest::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \((\Set : (nest args:.\0:>))),
        )),

        unnest::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \((\Set : (unnest args:.\0:>))),
        )),

        where::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Signature),
            implements : \@folder::"",
            evaluates : \((\Set : (args:.\0:> where args:.\1))),
        )),

        map::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : \((\Set : (args:.\0:> map args:.\1))),
        )),

        reduce::Set : (\Function : (
            returns : \@Any,
            matches : (\@Set, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : \((\Set : (args:.\0:> reduce args:.\1))),
        )),

        to_Set::Set : (\Function : (
            returns : \@Set,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        to_Bag::Set : (\Function : (
            returns : \@Bag,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(args:.\0:>),
        )),

        count::Set : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(count args:.\0:>),
        )),

        unique_count::Set : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Set),
            implements : \@folder::"",
            evaluates : \(count args:.\0),
        )),

        order_using::Set : (\Function : (
            returns : \@Array,
            matches : (\@Set, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : \((\Set : (args:.\0:> order_using args:.\1))),
        )),

`#########################################################################`

        Bag::"" : (\Selection : (
            where : \(args --> \foundation::is_a_Bag::()),
            default : {0:0},
            composes : \@Discrete,
        )),

        Bag::Empty : (\Constant : ( value : {0:0} )),

        Unicode_Aliases::"+∅" : (\Alias : ( of : \@Bag::Empty )),

        to_Boolean::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \(args:.\0 != {0:0}),
        )),

        empty::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \({0:0}),
        )),

        singular::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_singular::()),
        )),

        only_member::Bag : (\Function : (
            returns : \@Any,
            matches : (\@Bag),
            implements : \@folder::"",
            accepts : \(singular args:.\0),
            evaluates : \(args --> \foundation::Bag_only_member::()),
        )),

        has_n::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_has_n::()),
        )),

        multiplicity::Bag : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Bag, \@Any),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_multiplicity::()),
        )),

        all_unique::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_all_unique::()),
        )),

        unique::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_unique::()),
        )),

        subset_of::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_subset_of::()),
        )),

        same_members::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args:.\0 = args:.\1),
        )),

        overlaps_members::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args --> \foundation::Bag_overlaps_members::()),
        )),

        disjoint_members::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(args --> \foundation::Bag_disjoint_members::()),
        )),

        any::Bag : (\Function : (
            returns : \@Boolean,
            matches : (\@Bag, \@Signature),
            implements : \@folder::"",
            evaluates : \((args:.\0, Signature_to_Function_Call_But_0::(args:.\1)) --> \foundation::Bag_any::()),
        )),

        insert_n::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_insert_n::()),
        )),

        remove_n::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Any, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_remove_n::()),
        )),

        member_plus::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : {0:0},
            evaluates : \(args --> \foundation::Bag_member_plus::()),
        )),

        except::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_except::()),
        )),

        intersect::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : \(args --> \foundation::Bag_intersect::()),
        )),

        union::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {0:0},
            evaluates : \(args --> \foundation::Bag_union::()),
        )),

        exclusive::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Bag),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            identity : {0:0},
            evaluates : \(args --> \foundation::Bag_exclusive::()),
        )),

        nest::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(args --> \foundation::Bag_nest::()),
        )),

        unnest::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(args --> \foundation::Bag_unnest::()),
        )),

        where::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Signature),
            implements : \@folder::"",
            evaluates : \((args:.\0, Signature_to_Function_Call_But_0::(args:.\1)) --> \foundation::Bag_where::()),
        )),

        map::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_map::()),
        )),

        reduce::Bag : (\Function : (
            returns : \@Any,
            matches : (\@Bag, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_reduce::()),
        )),

        to_Set::Bag : (\Function : (
            returns : \@Set,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \((\Set : (unique args:.\0))),
        )),

        to_Bag::Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        count::Bag : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_count::()),
        )),

        unique_count::Bag : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Bag),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_unique_count::()),
        )),

        order_using::Bag : (\Function : (
            returns : \@Array,
            matches : (\@Bag, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Bag_order_using::()),
        )),

`#########################################################################`

        Attributive : (\Interface : (
            requires_implements : {has_any_attrs,nullary
                ,is_unary,degree,heading,rename
                ,can_project_matching,on,update,extend},
        )),

        Excuse::No_Such_Attr_Name : (\Constant : ( composes : \@Excuse )),

        Excuse::Not_Same_Heading : (\Constant : ( composes : \@Excuse )),

        has_any_attrs::"" : (\Function : ( virtual : True, returns : \@Boolean, matches : (\@Attributive) )),

        "?@" : (\Alias : ( of : \@has_any_attrs )),

        is_nullary : (\Function : ( negates : \@has_any_attrs )),

        "!?@" : (\Alias : ( of : \@is_nullary )),

        nullary::"" : (\Function : ( virtual : True, returns : \@Attributive, matches : (\@Attributive) )),

        is_unary::"" : (\Function : ( virtual : True, returns : \@Boolean, matches : (\@Attributive) )),

        degree::"" : (\Function : ( virtual : True, returns : \@Integer::NN, matches : (\@Attributive) )),

        "#@" : (\Alias : ( of : \@degree )),

        heading::"" : (\Function : ( virtual : True, returns : \@Heading, matches : (\@Attributive) )),

        "@" : (\Alias : ( of : \@heading )),

        subheading_of : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            evaluates : \((@args:.\0, @args:.\1) --> \foundation::Tuple_subheading_of::()),
        )),

        Unicode_Aliases::"⊆@" : (\Alias : ( of : \@subheading_of )),

        superheading_of : (\Function : ( commutes : \@subheading_of )),

        has_subheading : (\Alias : ( of : \@superheading_of )),
        "@?"           : (\Alias : ( of : \@superheading_of )),

        Unicode_Aliases::"⊇@" : (\Alias : ( of : \@superheading_of )),

        same_heading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : \(@args:.\0 = @args:.\1),
        )),

        "=@" : (\Alias : ( of : \@same_heading )),

        proper_subheading_or_superheading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : \(@args:.\0 != @args:.\1 and (args:.\0 subheading_or_superheading args:.\1)),
        )),

        subheading_or_superheading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : \((args:.\0 subheading_of args:.\1) or (args:.\0 superheading_of args:.\1)),
        )),

        overlaps_heading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : \((@args:.\0, @args:.\1) --> \foundation::Tuple_overlaps_heading::()),
        )),

        disjoint_heading : (\Function : (
            returns : \@Boolean,
            matches : (\@Attributive, \@Attributive),
            is_commutative : True,
            evaluates : \((@args:.\0, @args:.\1) --> \foundation::Tuple_disjoint_heading::()),
        )),

        except_heading : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            evaluates : \((@args:.\0, @args:.\1) --> \foundation::Tuple_except_heading::()),
        )),

        Unicode_Aliases::"∖@" : (\Alias : ( of : \@except_heading )),

        intersect_heading : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : \((@args:.\0, @args:.\1) --> \foundation::Tuple_intersect_heading::()),
        )),

        Unicode_Aliases::"∩@" : (\Alias : ( of : \@intersect_heading )),

        union_heading : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : (),
            evaluates : \((@args:.\0, @args:.\1) --> \foundation::Tuple_union_heading::()),
        )),

        Unicode_Aliases::"∪@" : (\Alias : ( of : \@union_heading )),

        exclusive : (\Function : (
            returns : \@Heading,
            matches : (\@Attributive, \@Attributive),
            is_associative : True,
            is_commutative : True,
            identity : (),
            evaluates : \((@args:.\0, @args:.\1) --> \foundation::Tuple_exclusive_heading::()),
        )),

        symm_diff_heading : (\Alias : ( of : \@exclusive_heading )),

        Unicode_Aliases::"∆@" : (\Alias : ( of : \@exclusive_heading )),

        rename::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Renaming),
            accepts : \(...),
        )),

        "@:=" : (\Alias : ( of : \@rename )),

        Unicode_Aliases::"ρ" : (\Alias : ( of : \@rename )),

        renaming : (\Function : ( commutes : \@rename )),

        can_project_matching::"" : (\Function : (
            virtual : True,
            returns : \@Boolean,
            matches : (\@Attributive, \@Structural),
        )),

        "%=?" : (\Alias : ( of : \@can_project_matching )),

        on::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            accepts : \(args:.\0 @? args:.\1),
        )),

        project : (\Alias : ( of : \@on )),
        "%="    : (\Alias : ( of : \@on )),

        Unicode_Aliases::"π" : (\Alias : ( of : \@on )),

        from : (\Function : ( commutes : \@on )),

        maybe_on : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            evaluates : \(args:.\0 on (args:.\0 intersect_heading args:.\1)),
        )),

        "%!" : (\Alias : ( of : \@maybe_on )),

        update::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Structural),
            accepts : \(args:.\0 @? args:.\1),
        )),

        "%:=" : (\Alias : ( of : \@update )),

        extend::"" : (\Function : (
            virtual : True,
            returns : \@Attributive,
            matches : (\@Attributive, \@Structural),
            accepts : \(args:.\0 disjoint_heading args:.\1),
        )),

        "%+" : (\Alias : ( of : \@extend )),

        but : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            accepts : \(args:.\0 @? args:.\1),
            evaluates : \(args:.\0 on (args:.\0 except_heading args:.\1)),
        )),

        project_all_but : (\Alias : ( of : \@but )),
        "%-"            : (\Alias : ( of : \@but )),

        update_or_extend : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Structural),
            evaluates : \(args:.\0 on (args:.\0 except_heading args:.\1) extend args:.\1),
        )),

        "%=+" : (\Alias : ( of : \@update_or_extend )),

        maybe_but : (\Function : (
            returns : \@Attributive,
            matches : (\@Attributive, \@Heading),
            evaluates : \(args:.\0 but (args:.\0 intersect_heading args:.\1)),
        )),

        "%?-" : (\Alias : ( of : \@maybe_but )),

`#########################################################################`

        Structural : (\Interface : (
            composes : {\@Attributive and_provides_its_default,
                \@Accessible and_provides_its_default},
            requires_implements : {has_any_attrs,nullary
                ,is_unary,degree,heading,rename
                ,on,update,extend
                ,at
                ,to_Tuple},
        )),

        can_project_matching::Structural : (\Function : (
            returns : \@Boolean,
            matches : (\@Structural, \@Structural),
            implements : \@folder::"",
            evaluates : \(if args:.\0 @? args:.\1 then guard args:.\0 %= @args:.\1 = args:.\1 else False),
        )),

        has_any_at::Structure : (\Function : (
            returns : \@Boolean,
            matches : (\@Structure, \@Attr_Name),
            implements : \@folder::"",
            evaluates : \(args:.\0 @? args:.\1),
        )),

        has_mapping_at::Structural : (\Function : (
            returns : \@Boolean,
            matches : (Structural, (Attr_Name, Any)),
            implements : \@folder::"",
            evaluates : \(if args:.\0 .? (args:.\1.\0) then guard args:.\0.(args:.\1.\0) = (args:.\1.\1) else False),
        )),

        mapping_at::Structural : (\Function : (
            returns : (\@Attr_Name, \@Any),
            matches : (\@Structural, \@Attr_Name),
            implements : \@folder::"",
            accepts : \(args:.\0 .? args:.\1),
            evaluates : \((args:.\1, args:.\0.args:.\1)),
        )),

        maybe_at::Structural : (\Function : (
            returns : \@Any,
            matches : (\@Structural, \@Attr_Name),
            implements : \@folder::"",
            evaluates : \(if args:.\0 .? args:.\1 then guard args:.\0.args:.\1 else Excuse::No_Such_Attr_Name()),
        )),

        replace_at::Structure : (\Function : (
            returns : \@Structure,
            matches : (Structure, (Attr_Name, Any)),
            implements : \@folder::"",
            accepts : \(args:.\0 .? (args:.\1.\0)),
            evaluates : \(args:.\0 update D1::(args:.\1)),
        )),

        shiftless_insert_at::Structure : (\Function : (
            returns : \@Structure,
            matches : (Structure, (Attr_Name, Any)),
            implements : \@folder::"",
            accepts : \(not args:.\0 .? (args:.\1.\0)),
            evaluates : \(args:.\0 extend D1::(args:.\1)),
        )),

        shiftless_remove_at::Structure : (\Function : (
            returns : \@Structure,
            matches : (\@Structure, \@Attr_Name),
            implements : \@folder::"",
            accepts : \(args:.\0 .? args:.\1),
            evaluates : \(args:.\0 but args:.\1),
        )),

        replace_or_insert_at::Structural : (\Function : (
            returns : \@Structural,
            matches : (Structural, (Attr_Name, Any)),
            implements : \@folder::"",
            evaluates : \(args:.\0 update_or_extend D1::(args:.\1)),
        )),

        shiftless_maybe_remove_at::Structural : (\Function : (
            returns : \@Structural,
            matches : (\@Structural, \@Attr_Name),
            implements : \@folder::"",
            evaluates : \(args:.\0 maybe_but args:.\1),
        )),

        to_Tuple::"" : (\Function : ( virtual : True, returns : \@Tuple, matches : (\@Structural) )),

        "%" : (\Alias : ( of : \@to_Tuple )),

`#########################################################################`

        Tuple::"" : (\Selection : (
            where : \(args --> \foundation::is_a_Tuple::()),
            default : (),
            composes : \@Structural and_provides_its_default,
        )),

        Tuple::D0 : (\Constant : ( value : () )),

        Tuple::D1 : (\Selection : (
            of : \@Tuple,
            where : \(is_unary args:.\0),
            default : (False,),
        )),

        D1 : (\Function : (
            returns : \@Tuple::D1,
            matches : (\@Attr_Name, \@Any),
            evaluates : \(args --> \foundation::Tuple_D1_select::()),
        )),

        has_any_attrs::Tuple : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : \(args:.\0 != ()),
        )),

        nullary::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : \(()),
        )),

        is_unary::Tuple : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : \(degree::(args:.\0) = 1),
        )),

        degree::Tuple : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Tuple_degree::()),
        )),

        heading::Tuple : (\Function : (
            returns : \@Heading,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : \(args --> \foundation::Tuple_heading::()),
        )),

        rename::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Renaming),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(args --> \foundation::Tuple_rename::()),
        )),

        on::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Heading),
            implements : \@folder::"",
            accepts : \(args:.\0 @? args:.\1),
            evaluates : \(args --> \foundation::Tuple_on::()),
        )),

        update::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Tuple),
            implements : \@folder::"",
            accepts : \(args:.\0 @? args:.\1),
            evaluates : \(args --> \foundation::Tuple_update::()),
        )),

        extend::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Tuple),
            implements : \@folder::"",
            accepts : \(args:.\0 disjoint_heading args:.\1),
            is_associative : True,
            is_commutative : True,
            identity : (),
            evaluates : \(args --> \foundation::Tuple_extend::()),
        )),

        at::Tuple : (\Function : (
            returns : \@Any,
            matches : (\@Tuple, \@Attr_Name),
            implements : \@folder::"",
            accepts : \(args:.\0 .? args:.\1),
            evaluates : \(args:.\0 :. (args:.\1)),
        )),

        to_Tuple::Tuple : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple),
            implements : \@folder::"",
            evaluates : \(args:.\0),
        )),

        any_attrs : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple, \@Signature),
            evaluates : \((args:.\0, Signature_to_Function_Call_But_0::(args:.\1))
                --> \foundation::Tuple_any_attrs::()),
        )),

        none_of_attrs : (\Function : ( negates : \@any_attrs )),

        all_attrs : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple, \@Signature),
            evaluates : \(args:.\0 none_of_attrs \not_is_a::( 1: args:.\1 )),
        )),

        not_all_attrs : (\Function : ( negates : \@all_attrs )),

        all_attr_assets : (\Function : (
            returns : \@Boolean,
            matches : (\@Tuple, \@Signature),
            evaluates : \(args:.\0 all_attrs \(args:.\1 <-- (args:.\0.\asset,))
                \<-- (1 : Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        attrs_where : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Signature),
            evaluates : \((args:.\0, Signature_to_Function_Call_But_0::(args:.\1))
                --> \foundation::Tuple_attrs_where::()),
        )),

        attrs_map : (\Function : (
            returns : \@Tuple,
            matches : (\@Tuple, \@Function_Call_But_0),
            evaluates : \(args --> \foundation::Tuple_attrs_map::()),
        )),

        attrs_reduce : (\Function : (
            returns : \@Any,
            matches : (\@Tuple, \@Function_Call_But_0_1),
            evaluates : \(args --> \foundation::Tuple_attrs_reduce::()),
        )),

`#########################################################################`

        Relational : (\Interface : (
            composes : {\@Unionable, \@Attributive},
            requires_implements : {heading,body,select_Relational},
        )),

        to_Boolean::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(? |args:.\0),
        )),

        empty::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(select_Relational::( like: args:.\0, heading: @args:.\0, body: empty |args:.\0 )),
        )),

        singular::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(singular |args:.\0),
        )),

        only_member::Relational : (\Function : (
            returns : \@Structural,
            matches : (\@Relational),
            implements : \@folder::"",
            accepts : \(singular args:.\0),
            evaluates : \(only_member |args:.\0),
        )),

        has_n::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Structural, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\0 =@ args:.\1 then guard has_n::(|args:.\0, args:.\1, args:.\2)
                else Excuse::Not_Same_Heading),
        )),

        multiplicity::Relational : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            evaluates : \(|args:.\0 multiplicity args:.\1),
        )),

        all_unique::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(all_unique |args:.\0),
        )),

        unique::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(select_Relational::( like: args:.\0, heading: @args:.\0, body: unique |args:.\0 )),
        )),

        subset_of::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            evaluates : \(if args:.\0 =@ args:.\1 then guard |args:.\0 subset_of |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        same_members::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(if args:.\0 =@ args:.\1 then guard |args:.\0 same_members |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        overlaps_members::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(if args:.\0 =@ args:.\1 then guard |args:.\0 overlaps_members |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        disjoint_members::Relational : (\Function : (
            returns : {\@Boolean, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_commutative : True,
            evaluates : \(if args:.\0 =@ args:.\1 then guard |args:.\0 disjoint_members |args:.\1
                else Excuse::Not_Same_Heading),
        )),

        any::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational, \@Signature),
            implements : \@folder::"",
            evaluates : \(|args:.\0 any args:.\1),
        )),

        insert_n::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Structural, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: insert_n::(|args:.\0, args:.\1, args:.\2) )
                else Excuse::Not_Same_Heading),
        )),

        remove_n::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Structural, \@Integer::NN),
            implements : \@folder::"",
            evaluates : \(if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: remove_n::(|args:.\0, args:.\1, args:.\2) )
                else Excuse::Not_Same_Heading),
        )),

        member_plus::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_associative : True,
            evaluates : \(if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 member_plus |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        except::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            evaluates : \(if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 except |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        intersect::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_associative : True,
            is_idempotent : True,
            evaluates : \(if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 intersect |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        union::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_idempotent : True,
            evaluates : \(if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 union |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        exclusive::Relational : (\Function : (
            returns : {\@Relational, \@Excuse::Not_Same_Heading},
            matches : (\@Relational, \@Relational),
            implements : \@folder::"",
            is_associative : True,
            is_commutative : True,
            evaluates : \(if args:.\0 =@ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: @args:.\0, body: |args:.\0 exclusive |args:.\1 )
                else Excuse::Not_Same_Heading),
        )),

        nest::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(...),
        )),

        unnest::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(...),
        )),

        where::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Signature),
            implements : \@folder::"",
            evaluates : \(select_Relational::( like: args:.\0, heading: @args:.\0, body: |args:.\0 where args:.\1 )),
        )),

        map::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Function_Call_But_0),
            implements : \@folder::"",
            evaluates : \(...),
        )),

        reduce::Relational : (\Function : (
            returns : \@Any,
            matches : (\@Relational, \@Function_Call_But_0_1),
            implements : \@folder::"",
            evaluates : \(|args:.\0 reduce args:.\1),
        )),

        has_any_attrs::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(@args:.\0 != ()),
        )),

        nullary::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(args:.\0 on ()),
        )),

        is_unary::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(is_unary @args:.\0),
        )),

        degree::Relational : (\Function : (
            returns : \@Integer::NN,
            matches : (\@Relational),
            implements : \@folder::"",
            evaluates : \(degree @args:.\0),
        )),

        rename::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Renaming),
            implements : \@folder::"",
            accepts : \(...),
            evaluates : \(select_Relational::( like: args:.\0, heading: @args:.\0 rename args:.\1,
                body: |args:.\0 map \rename::( 1: args:.\1 ) )),
        )),

        can_project_matching::Relational : (\Function : (
            returns : \@Boolean,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            evaluates : \(if args:.\0 @? args:.\1
                then guard |args:.\0 all \(args:.\0 %= @args:.\1 = args:.\1) \<-- (1 : args:.\1,)
                else False),
        )),

        on::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Heading),
            implements : \@folder::"",
            accepts : \(args:.\0 @? args:.\1),
            evaluates : \(select_Relational::( like: args:.\0, heading: @args:.\0 on args:.\1,
                body: |args:.\0 map \on::( 1: args:.\1 ) )),
        )),

        update::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            accepts : \(args:.\0 @? args:.\1),
            evaluates : \(select_Relational::( like: args:.\0, heading: @args:.\0,
                body: |args:.\0 map \update::( 1: args:.\1 ) )),
        )),

        extend::Relational : (\Function : (
            returns : \@Relational,
            matches : (\@Relational, \@Structural),
            implements : \@folder::"",
            accepts : \(args:.\0 disjoint_heading args:.\1),
            evaluates : \(select_Relational::( like: args:.\0, heading: @args:.\0 extend args:.\1,
                body: |args:.\0 map \extend::( 1: args:.\1 ) )),
        )),

        body::"" : (\Function : ( virtual : True, returns : \@Unionable, matches : (\@Relational) )),

        "|" : (\Alias : ( of : \@body )),

        select_Relational::"" : (\Function : (
            virtual : True,
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Relational, heading : \@Heading, body : \@Unionable),
        )),

`#########################################################################`

        Tuple_Array::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Tuple_Array, \(
                if args:.\0 is_a ( heading : \Heading::(), body : \Array::() ) then guard
                    if args:.\0.\body all \Tuple::() then guard
                        args:.\0.\body all \(@args:.\0 = args:.\1) \<-- (args:.\0.\heading)
                    else
                        False
                else
                    False
            ) )),
            default : \(~%@()),
            composes : {\@Relational, \@Positional},
        )),

        Tuple_Array::D0C0 : (\Constant : ( value : ~%@() )),

        Tuple_Array::D0C1 : (\Constant : ( value : ~%[()] )),

        heading::Tuple_Array : (\Function : (
            returns : \@Heading,
            matches : (\@Tuple_Array),
            implements : \@folder::"",
            evaluates : \(args:.\0:>.\heading),
        )),

        body::Tuple_Array : (\Function : (
            returns : \@Array,
            matches : (\@Tuple_Array),
            implements : \@folder::"",
            evaluates : \(args:.\0:>.\body),
        )),

        select_Relational::Tuple_Array : (\Function : (
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Tuple_Array, heading : \@Heading, body : \@Array),
            implements : \@folder::"",
            evaluates : \((\Tuple_Array : (args %= \@(heading,body)))),
        )),

`#########################################################################`

        Relation::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Relation, \(
                if args:.\0 is_a ( heading : \Heading::(), body : \Set::() ) then guard
                    if args:.\0.\body all \Tuple::() then guard
                        args:.\0.\body all \(@args:.\0 = args:.\1) \<-- (args:.\0.\heading)
                    else
                        False
                else
                    False
            ) )),
            default : \(?%@()),
            composes : {\@Relational and_provides_its_default, \@Discrete, \@Setty},
        )),

        Relation::D0C0 : (\Constant : ( value : ?%@() )),

        Relation::D0C1 : (\Constant : ( value : ?%{()} )),

        heading::Relation : (\Function : (
            returns : \@Heading,
            matches : (\@Relation),
            implements : \@folder::"",
            evaluates : \(args:.\0:>.\heading),
        )),

        body::Relation : (\Function : (
            returns : \@Set,
            matches : (\@Relation),
            implements : \@folder::"",
            evaluates : \(args:.\0:>.\body),
        )),

        select_Relational::Relation : (\Function : (
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Relation, heading : \@Heading, body : \@Set),
            implements : \@folder::"",
            evaluates : \((\Relation : (args %= \@(heading,body)))),
        )),

`#########################################################################`

        Tuple_Bag::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Tuple_Bag, \(
                if args:.\0 is_a ( heading : \Heading::(), body : \Bag::() ) then guard
                    if args:.\0.\body all \Tuple::() then guard
                        args:.\0.\body all \(@args:.\0 = args:.\1) \<-- (args:.\0.\heading)
                    else
                        False
                else
                    False
            ) )),
            default : \(+%@()),
            composes : {\@Relational, \@Discrete},
        )),

        Tuple_Bag::D0C0 : (\Constant : ( value : +%@() )),

        Tuple_Bag::D0C1 : (\Constant : ( value : +%{()} )),

        heading::Tuple_Bag : (\Function : (
            returns : \@Heading,
            matches : (\@Tuple_Bag),
            implements : \@folder::"",
            evaluates : \(args:.\0:>.\heading),
        )),

        body::Tuple_Bag : (\Function : (
            returns : \@Bag,
            matches : (\@Tuple_Bag),
            implements : \@folder::"",
            evaluates : \(args:.\0:>.\body),
        )),

        select_Relational::Tuple_Bag : (\Function : (
            returns : {\@Relational, \@Excuse::...},
            matches : (like : \@Tuple_Bag, heading : \@Heading, body : \@Bag),
            implements : \@folder::"",
            evaluates : \((\Tuple_Bag : (args %= \@(heading,body)))),
        )),

`#########################################################################`

        Intervalish : (\Interface : (
            composes : \@Homogeneous,
            requires_implements : {...},
        )),

`#########################################################################`

        Interval::"" : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Interval, \Interval::Attrs() )),
            default : \(Excuse::Before_All_Others()..Excuse::After_All_Others()),
            composes : {\@Intervalish, \@Setty},
        )),

        Interval::Attrs : (\Selection : (
            of : \@Tuple,
            where : \(...),
        )),

`#########################################################################`

        Unionable_Intervalish : (\Interface : (
            composes : {\@Intervalish, \@Unionable},
            requires_implements : {...},
        )),

`#########################################################################`

        Interval_Set : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Interval_Set,
                \(if Interval_Bag args:.\0 then guard all_unique args:.\0 else False) )),
            default : ...,
            composes : {\@Unionable_Intervalish, \@Setty},
        )),

`#########################################################################`

        Interval_Bag : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Interval_Bag, \(
                if Tuple_Bag args:.\0 then guard ... else False
            ) )),
            default : ...,
            composes : \@Unionable_Intervalish,
        )),

`#########################################################################`

        Quantitative : (\Interface : (
            composes : \@Numerical,
            requires_implements : {...},
        )),

`#########################################################################`

        Quantity : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Quantity, \(
                if Relation args:.\0 then guard ... else False
            ) )),
            default : ...,
            composes : \@Quantitative,
        )),

`#########################################################################`

        Capsule : (\Selection : (
            where : \(args --> \foundation::is_a_Capsule::()),
            default : (False : False),
        )),

        Capsule_subtype : (\Function : (
            returns : \@Boolean,
            matches : (\@Any, \@Any, \@Signature),
            evaluates : \(
                if Capsule args:.\0 then guard
                    args:.\0:< = args:.\1 and
                        (args:.\0:>,) --> Signature_to_Function_Call_But_0::(args:.\2)
                else
                    False
            ),
        )),

`#########################################################################`

        Reference::"" : (\Selection : (
            where : \(args --> \foundation::is_a_Reference::()),
            default : () --> \foundation::default_Reference::(),
        )),

`#########################################################################`

        External::"" : (\Selection : (
            where : \(args --> \foundation::is_a_External::()),
            default : () --> \foundation::default_External::(),
        )),

        External::call_function : (\Function : (
            returns : \@Any,
            matches : (\@Any),
            evaluates : \(\foundation::External_call_function::() <-- args),
        )),

`#########################################################################`

        Source_Code::Package : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Package, \(
                args:.\0 is_a (
                    identity : \Package::Identity::(),
                    foundation : \Package::Foundation::(),
                    uses : \Package::Uses_Map::(),
                    entry : \Package::Entry_Point::(),
                    floating : \Package::Floating::(),
                    materials : \Package::Folder::(),
                )
            ) )),
            default : ...,
        )),

        Source_Code::Package::Identity : (\Selection : (
            of : \@Tuple,
            where : \(
                args:.\0 is_a (
                    package_base_name : \Package::Base_Name::(),
                    authority : \Package::Canon_Authority::(),
                    version_number : \Package::Canon_Version_Number::(),
                )
            ),
        )),

        Source_Code::Package::Foundation : (\Selection : (
            of : \@Tuple,
            where : \(
                args:.\0 is_a (
                    authority : \Package::Canon_Authority::(),
                    version_number : \Package::Canon_Version_Number::(),
                )
            ),
        )),

        Source_Code::Package::Base_Name : (\Selection : (
            of : \@Attr_Name_List,
            where : \(so args:.\0 and args:.\0 ∌ \""),
        )),

        Source_Code::Package::Canon_Authority : (\Selection : (
            of : \@Text,
            where : \(so args:.\0),
        )),

        Source_Code::Package::Canon_Version_Number : (\Selection : (
            of : \@Text,
            where : \(so args:.\0),
        )),

        Source_Code::Package::Uses_Map : (\Selection : (
            of : \@Tuple,
            where : \(args:.\0 .!? \"" and args:.\0 all_attr_assets \Package::Uses_Item::()),
        )),

        Source_Code::Package::Uses_Item : (\Selection : (
            of : \@Tuple,
            where : \(
                args:.\0 is_a (
                    package_base_name : \Package::Base_Name::(),
                    authority : \Package::Canon_Authority::(),
                    version_number : \Package::Canon_Version_Number::(),
                )
            ),
        )),

        Source_Code::Package::Entry_Point : (\Selection : ( of : \@Absolute_Name )),

        Source_Code::Package::Floating : (\Selection : (
            of : \@Set,
            where : \(args:.\0 all \Absolute_Name::()),
        )),

        Source_Code::Package::Folder : (\Selection : (
            of : \@Tuple,
            where : \(args:.\0 all_attr_assets {\Package::Folder::(), \Material::()}),
        )),

        Source_Code::Material : (\Selection : (
            union : {\@Alias, \@Constant, \@Selection, \@Interface, \@Function, \@Procedure},
            default : ...,
        )),

        Source_Code::Alias : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Alias, \Identity_Identifier::() )),
            default : \((\Alias : Identity_Identifier::())),
        )),

        Source_Code::Constant : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Constant, \(
                args:.\0 is_a (
                    folded : \Boolean::(),
                    composes : ...,
                    value : \Function_Body::(),  `Defaults to \@0 if omitted.`
                )
            ) )),
            default : ...,
        )),

        Source_Code::Selection : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Selection, \(
                args:.\0 is_a (
                    of : ...,
                    where : \Function_Body::(),
                    default : \Function_Body::(),
                    composes : ...,
                )
            ) )),
            default : ...,
        )),

        Source_Code::Interface : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Interface, \(
                args:.\0 is_a (
                    composes : ...,
                    requires_implements : ...,
                )
            ) )),
            default : ...,
        )),

        Source_Code::Function : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Function, \(
                args:.\0 is_a (
                    virtual : \Boolean::(),
                    commutes : \Identity_Identifier::(),
                    negates : \Identity_Identifier::(),
                    returns : \Signature::(),
                    matches : \Signature::Tuple(),
                    implements : ...,
                    overrides : ...,
                    accepts : \Function_Body::(),
                    intends : \Function_Body::(),
                    is_associative : \Boolean::(),
                    is_commutative : \Boolean::(),
                    is_idempotent : \Boolean::(),
                    identity : \Function_Body::(),
                    repeater : ...,
                    evaluates : \Function_Body::(),
                )
            ) )),
            default : ...,
        )),

        Source_Code::Function_Body : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Function_Body, \(
                args:.\0 is_a (
                    root_expr : \Expression::(),
                    named_exprs : \Named_Expr_List::(),
                )
            ) )),
            default : ...,
        )),

        Source_Code::Procedure : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Procedure, \(
                args:.\0 is_a (
                    virtual : \Boolean::(),
                    matches : \Signature::Tuple(),
                    updates : \Heading::(),  `TODO: Or keyword "source".`
                    implements : ...,
                    overrides : ...,
                    accepts : \Function_Body::(),
                    intends : \Function_Body::(),
                    vars : \Signature::Tuple(),
                    performs : \Procedure_Body::(),
                )
            ) )),
            default : ...,
        )),

        Source_Code::Procedure_Body : (\Selection : (
            of : \@Capsule,
            where : \(Capsule_subtype::( args:.\0, \Procedure_Body, \(
                args:.\0 is_a (
                    root_stmt : \Statement::(),
                    named_stmts : \Named_Stmt_List::(),
                    named_exprs : \Named_Expr_List::(),
                )
            ) )),
            default : ...,
        )),

        Source_Code::Signature::"" : (\Selection : (
            union : {\@Function_Call_But_0, \@folder::Set, \@folder::Tuple},
            default : \Any::(),
        )),

        Source_Code::Signature::Set : (\Selection : (
            of : \@Set,
            where : \(args:.\0 all \Signature::()),
        )),

        Source_Code::Signature::Tuple : (\Selection : (
            of : \@Tuple,
            where : \(args:.\0 all_attr_assets \Signature::()),
        )),

        Source_Code::Heading : (\Selection : (
            of : \@Tuple,
            where : \(args:.\0 all_attr_assets \False::()),
        )),

        Source_Code::Attr_Name : (\Selection : (
            of : \@Heading,
            where : \(is_unary args:.\0),
        )),

        Source_Code::Attr_Name_List : (\Selection : (
            of : \@Array,
            where : \(args:.\0 all \Attr_Name::()),
        )),

        Source_Code::Local_Name : (\Selection : (
            of : \@Attr_Name_List,
            where : \(
                if so args:.\0 then guard
                    given args:.\0.0
                        when \foundation then #args:.\0 = 2
                        when \used       then #args:.\0 ≥ 2  `elem 2 is pkg local alias`
                        when \package    then #args:.\0 ≥ 1
                        when \folder     then #args:.\0 ≥ 1
                        when \material   then #args:.\0 = 1
                        when \floating   then #args:.\0 ≥ 2
                        default False
                else
                    False
            ),
        )),

        Source_Code::Absolute_Name : (\Selection : (
            of : \@Local_Name,
            where : \(args:.\0.0 ⊆@ \@(foundation,used,package)),
        )),

        Source_Code::Named_Expr_List : (\Selection : (
            of : \@Tuple,
            where : \(args:.\0 .!? \"" and args:.\0 all_attr_assets \Expression::()),
        )),

        Source_Code::Expression : (\Selection : (
            union : {\@Expr_Name_Expr, \@Naming_Expr, \@Annotating_Expr
                , ...
                , \@delimiting_expr, \@source_expr
                , \@opaque_literal_expr, \@collection_selector_expr
                , \@invocation_expr, \@conditional_expr, \@fail_expr, ...},
            default : ...,
        )),

        Source_Code::Named_Stmt_List : (\Selection : (
            of : \@Tuple,
            where : \(args:.\0 .!? \"" and args:.\0 all_attr_assets \Statement::()),
        )),

        Source_Code::Statement : (\Selection : (
            union : {...},
            default : ...,
        )),

        Source_Code::Key_Asset_Pair : (\Selection : (
            of : \@Tuple,
            where : \(@args:.\0 = \@(key,asset)),
        )),

        Source_Code::Signature_to_Function_Call_But_0 : (\Function : (
            returns : \@Function_Call_But_0,
            matches : (\@Signature),
            evaluates : \(
                if Function_Call_But_0 args:.\0 then
                    args:.\0
                else if Signature::Set args:.\0 then guard
                    \(args:.\1 any \(args:.\1 is_a args:.\0) \<-- (1 : args:.\0))
                        \<-- (1 : args:.\0)
                else if Signature::Tuple args:.\0 then guard
                    \(
                        if Tuple args:.\0 then guard
                            if args:.\0 =@ args:.\1 then guard
                                args:.\0 all_attrs
                                    \(args:.\0:.\asset is_a args:.\1:.(args:.\0:.\name)) \<-- ( 1: args:.\1, )
                            else
                                False
                        else
                            False
                    ) \<-- (1 : args:.\0)
                else
                    fail  `We should never get here.`
            ),
        )),

`#########################################################################`

        Source_Code::Annotation::"" : (\Interface : ()),

`#########################################################################`

        Source_Code::Decoration::"" : (\Interface : ()),

`#########################################################################`

    ),
))

`#########################################################################`
`#########################################################################`
