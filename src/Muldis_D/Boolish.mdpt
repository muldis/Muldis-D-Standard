Muldis_D:Plain_Text:ASCII:"http://muldis.com":"0.200";

package_segment Muldis_D:"http://muldis.com":"0.200":Boolish;

/*************************************************************************/

MD.Boolish ::= type abstract composes Ordinal;

MD.Boolean ::= type of Universal where \*^[isa_Boolean,topic] default false
    composes Boolish;

MD.Bool ::= synonym of Boolean;

MD.Boolean.False ::= type of Boolean where !topic default false;
MD.Boolean.True  ::= type of Boolean where topic default true;

/*************************************************************************/

MD.Boolean."<=>" ::= function --> Order <-- (Boolean, Boolean)
    implements Ordered."<=>"
: (
       .0 = .1 ?? $=>Same
    !! .1      ?? $=>Less
    !!            $=>More
);

MD.Boolean.order ::= synonym of "<=>";

/*************************************************************************/

MD.Boolean."--" ::= function --> type union {False,"-Inf"} <-- (Boolean)
    implements Ordinal."--" : (.0 ?? false !! $=>"-Inf");

MD.Boolean.pred ::= synonym of "--";
MD.Boolean.dec  ::= synonym of "--";

MD.Boolean."++" ::= function --> type union {True,"+Inf"} <-- (Boolean)
    implements Ordinal."++" : (!.0 ?? true !! $=>"+Inf");

MD.Boolean.succ ::= synonym of "++";
MD.Boolean.inc  ::= synonym of "++";

/*************************************************************************/

/* Note that "false" is a keyword; this constant is a shim over it. */

MD.Boolean.false ::= constant false
    implements Boolish."false";

MD.Boolean.contradiction ::= synonym of false;

/* Note that "true" is a keyword; this constant is a shim over it. */

MD.Boolean.true ::= constant true
    implements Boolish."true";

MD.Boolean.tautology ::= synonym of true;

/*************************************************************************/

MD.Boolean.so ::= function --> Boolean <-- (Boolean)
    implements Boolish.so : .0;

MD.Boolean."?"         ::= synonym of so;
MD.Boolean.proposition ::= synonym of so;

/* Note that "not"|"!" is a meta-keyword; this function is a shim over it. */

MD.Boolean.not ::= function --> Boolean <-- (Boolean)
    implements Boolish.not : !.0;

MD.Boolean."!"      ::= synonym of not;
MD.Boolean.negation ::= synonym of not;

/*************************************************************************/

MD.Boolean.and ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.and
    is {commutative,associative,idempotent} identity true
    : (.0 ?? .1 !! false);

MD.Boolean.all         ::= synonym of and;
MD.Boolean.every       ::= synonym of and;
MD.Boolean.conjunction ::= synonym of and;

MD.Boolean.nand ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.nand
    is {commutative}
    : (.0 !and .1);

MD.Boolean.not_and            ::= synonym of nand;
MD.Boolean.not_both           ::= synonym of nand;
MD.Boolean.alternative_denial ::= synonym of nand;

/*************************************************************************/

MD.Boolean.or ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.or
    is {commutative,associative,idempotent} identity false
    : (.0 ?? true !! .1);

MD.Boolean.any         ::= synonym of or;
MD.Boolean.some        ::= synonym of or;
MD.Boolean.disjunction ::= synonym of or;

MD.Boolean.nor ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.nor
    is {commutative}
    : (.0 !or .1);

MD.Boolean.not_or       ::= synonym of nor;
MD.Boolean.joint_denial ::= synonym of nor;

/*************************************************************************/

MD.Boolean.xnor ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.xnor
    is {commutative,associative} identity true
    : (.0 = .1);

MD.Boolean.iff                  ::= synonym of xnor;
MD.Boolean.biconditional        ::= synonym of xnor;
MD.Boolean.material_equivalence ::= synonym of xnor;

MD.Boolean.xor ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.xor
    is {commutative,associative} identity false
    : (.0 != .1);

MD.Boolean.exclusive_disjunction ::= synonym of xor;

/*************************************************************************/

MD.Boolean.imp ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.imp
    : (.0 ?? .1 !! true);

MD.Boolean.implies              ::= synonym of imp;
MD.Boolean.material_implication ::= synonym of imp;

MD.Boolean.nimp ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.nimp
    : (.0 !imp .1);

MD.Boolean.not_implies             ::= synonym of nimp;
MD.Boolean.material_nonimplication ::= synonym of nimp;

/*************************************************************************/

/* Note that "if" is also a keyword, but its meaning differs. */

MD.Boolean.if ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.if
    : (.1 imp .0);

MD.Boolean.converse_implication ::= synonym of if;

MD.Boolean.nif ::= function
    --> Boolean <-- (Boolean, Boolean)
    implements Boolish.nif
    : (.1 nimp .0);

MD.Boolean.not_if                  ::= synonym of nif;
MD.Boolean.converse_nonimplication ::= synonym of nif;

/*************************************************************************/
