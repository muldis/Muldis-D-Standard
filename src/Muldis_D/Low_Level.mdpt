Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package_segment Muldis_D:"http://muldis.com":0:Low_Level;

/*************************************************************************/

/* A LL_List is a generic ordered list of 0..N elements; but you don't
   access elements using numeric indexes but rather without any indexes.
   One can conceive of implementing the general case of an LL_List either
   with an array or singly-linked list, where either is copy-on-write;
   all of the fundamental operators are abstract enough to work either way.
   This is exposed in the high level type system as Universal. */

Muldis_D.Low_Level.LL_List ::= special_type default LL_EMPTY();

/*************************************************************************/

Muldis_D.Low_Level.LL_EMPTY ::= constant ...;

Muldis_D.Low_Level.LL_prepend ::= function
    (LL_List <-- 0|elem : LL_List, 1|to : LL_List) : ...;

Muldis_D.Low_Level.LL_empty ::= function (LL_Boolean <-- 0|list : LL_List)
    : ...;

Muldis_D.Low_Level.LL_first ::= function (LL_List <-- 0|list : LL_List)
    requires (LL_empty(.0) ?? LL_FALSE() !! LL_TRUE()) : ...;

Muldis_D.Low_Level.LL_nonfirst ::= function (LL_List <-- 0|list : LL_List)
    requires (LL_empty(.0) ?? LL_FALSE() !! LL_TRUE()) : ...;

/*************************************************************************/

/* A LL_Boolean is a list of exactly 0 (false) or 1 (true) elements, in the
   latter case whose sole element is the empty list.
   This is exposed in the high level type system as Boolean. */

Muldis_D.Low_Level.LL_Boolean ::= type of LL_List
    where (
           LL_empty(.0)              ?? LL_TRUE()
        !! LL_empty(LL_nonfirst(.0)) ?? LL_empty(LL_first(.0))
        !! LL_FALSE()
    )
    default LL_FALSE();

Muldis_D.Low_Level.LL_FALSE ::= LL_EMPTY;

Muldis_D.Low_Level.LL_TRUE ::= constant
    (LL_prepend( elem : LL_EMPTY(), to : LL_EMPTY()));

/*************************************************************************/

Muldis_D.Low_Level.LL_Pair ::= type of LL_List
    where (
           LL_empty(.0)                           ?? LL_FALSE()
        !! LL_empty(LL_nonfirst(.0))              ?? LL_FALSE()
        !! LL_empty(LL_nonfirst(LL_nonfirst(.0))) ?? LL_TRUE()
        !! LL_FALSE()
    )
    default LL_prepend( elem : LL_EMPTY(),
        to : LL_prepend( elem : LL_EMPTY(), to : LL_EMPTY()));

/*************************************************************************/

Muldis_D.Low_Level.LL_same ::= function
    (LL_Boolean <-- LL_List, LL_List) is_commutative
: (
       LL_empty(.0) ?? LL_empty(.1)
    !! LL_empty(.1) ?? LL_FALSE()
    !! self(LL_first(.0),LL_first(.1))
        ?? self(LL_nonfirst(.0),LL_nonfirst(.1))
    !! LL_FALSE()
);

Muldis_D.Low_Level.LL_in_order ::= function
    (LL_Boolean <-- 0|lhs : LL_List, 1|rhs : LL_List)
: (
       LL_empty(.0) ?? LL_TRUE()
    !! LL_empty(.1) ?? LL_FALSE()
    !! LL_same(LL_first(.0),LL_first(.1))
        ?? self(LL_nonfirst(.0),LL_nonfirst(.1))
    !! self(LL_first(.0),LL_first(.1))
);

Muldis_D.Low_Level.LL_elems_in_order ::= function
    (LL_Boolean <-- LL_List)
: (
       LL_empty(.0)                            ?? LL_TRUE()
    !! LL_empty(LL_nonfirst(.0))               ?? LL_TRUE()
    !! LL_in_order(LL_first(.0),LL_second(.0)) ?? self(LL_nonfirst(.0))
    !! LL_FALSE()
);

Muldis_D.Low_Level.LL_second ::= function (LL_List <-- 0|list : LL_List)
    requires (LL_empty(.0) ?? LL_FALSE() !! LL_TRUE())
    : LL_first(LL_nonfirst(.0));

Muldis_D.Low_Level.LL_last ::= function (LL_List <-- 0|list : LL_List)
    requires (LL_empty(.0) ?? LL_FALSE() !! LL_TRUE())
    : (LL_empty(LL_nonfirst(.0)) ?? LL_first(.0) !! self(LL_nonfirst(.0)));

Muldis_D.Low_Level.LL_nonlast ::= function (LL_List <-- 0|list : LL_List)
    requires (LL_empty(.0) ?? LL_FALSE() !! LL_TRUE())
    : (LL_empty(LL_nonfirst(.0)) ?? LL_EMPTY()
        !! LL_prepend( elem : LL_first(.0), to : self(LL_nonfirst(.0))));

Muldis_D.Low_Level.LL_catenate ::= function
    (LL_List <-- 0|lhs : LL_List, 1|rhs : LL_List)
    : (LL_empty(.0) ?? .1 !! LL_empty(.1) ?? .0
        !! self(LL_nonlast(.0),LL_prepend( elem : LL_last(.0), to : .1)));

/*************************************************************************/

/* A LL_Natural is a list of 0..N elements where each element is an empty
   list; the numeric value (0..N) is equal to the count of elements.
   This is not exposed in the high-level type system at all. */

Muldis_D.Low_Level.LL_Natural ::= type of LL_List
    where (LL_empty(.0) ?? LL_TRUE()
        !! LL_empty(LL_first(.0)) ?? self(LL_nonfirst(.0)) !! LL_FALSE());

Muldis_D.Low_Level.LL_ZERO ::= LL_EMPTY;

Muldis_D.Low_Level.LL_zero ::= LL_empty;

Muldis_D.Low_Level.LL_pred ::= function (LL_Natural <-- LL_Natural)
    requires (LL_zero(.0) ?? LL_FALSE() !! LL_TRUE()) : LL_nonfirst(.0);

Muldis_D.Low_Level.LL_succ ::= function (LL_Natural <-- LL_Natural)
    : (LL_prepend( elem : LL_EMPTY(), to : .0 ));

Muldis_D.Low_Level.LL_1 ::= constant LL_succ(LL_ZERO());
Muldis_D.Low_Level.LL_2 ::= constant LL_succ(LL_1());
Muldis_D.Low_Level.LL_3 ::= constant LL_succ(LL_2());
Muldis_D.Low_Level.LL_4 ::= constant LL_succ(LL_3());
Muldis_D.Low_Level.LL_5 ::= constant LL_succ(LL_4());
Muldis_D.Low_Level.LL_6 ::= constant LL_succ(LL_5());
Muldis_D.Low_Level.LL_7 ::= constant LL_succ(LL_6());
Muldis_D.Low_Level.LL_8 ::= constant LL_succ(LL_7());
Muldis_D.Low_Level.LL_9 ::= constant LL_succ(LL_8());
Muldis_D.Low_Level.LL_10 ::= constant LL_succ(LL_9());

Muldis_D.Low_Level.LL_plus ::= function
    (LL_Natural <-- 0|augend : LL_Natural, 1|addend : LL_Natural)
    is_commutative is_associative identity LL_ZERO()
    : (LL_zero(.0) ?? .1 !! LL_zero(.1) ?? .0
        !! self(LL_succ(.0),LL_pred(.1)));

Muldis_D.Low_Level.LL_minus ::= function
    (LL_Natural <-- 0|minuend : LL_Natural, 1|subtrahend : LL_Natural)
    requires (LL_in_order(.1,.0))
    : (LL_zero(.1) ?? .0 !! LL_same(.0,.1) ?? LL_ZERO()
        !! self(LL_pred(.0),LL_pred(.1)));

Muldis_D.Low_Level.LL_times ::= function
    (LL_Natural <-- 0|multiplicand : LL_Natural, 1|multiplier : LL_Natural)
    is_commutative is_associative identity LL_1()
    : (LL_same(.0,LL_1()) ?? .1 !! LL_same(.1,LL_1()) ?? .0
        !! LL_zero(.0) ?? LL_ZERO() !! LL_zero(.1) ?? LL_ZERO()
        !! LL_plus(.0,self(.0,LL_pred(.1))));

Muldis_D.Low_Level.LL_divide ::= function
    (LL_Natural <-- 0|dividend : LL_Natural, 1|divisor : LL_Natural)
    requires (LL_zero(.1) ?? LL_FALSE() !! LL_TRUE())
    : (LL_same(.1,LL_1()) ?? .0 !! LL_same(.0,.1) ?? LL_1()
        !! LL_in_order(.0,.1) ?? LL_ZERO()
        !! LL_succ(self(LL_minus(.0,.1),.1)));

/*************************************************************************/

Muldis_D.Low_Level.LL_count ::= function (LL_Natural <-- 0|list : LL_List)
    : (LL_empty(.0) ?? LL_ZERO() !! LL_succ(self(LL_nonfirst(.0))));

Muldis_D.Low_Level.LL_elem ::= function
    (LL_List <-- 0|list : LL_List, 1|index : LL_Natural)
    requires (LL_in_order(LL_succ(.1),LL_count(.0)))
    : (LL_zero(.1) ?? LL_first(.0) !! self(LL_nonfirst(.0),LL_pred(.1)));

/* Note that LL_slice() can only return a non-empty list slice. */

Muldis_D.Low_Level.LL_slice ::= function
    (LL_List <-- 0|list : LL_List, 1|first_index : LL_Natural,
        2|last_index : LL_Natural)
    requires (LL_in_order(.1,.2) ?? LL_in_order(LL_succ(.2),LL_count(.0))
        !! LL_FALSE())
: (
       LL_empty(LL_nonfirst(.0)) ?? .0
    !! LL_zero(.1) ?? LL_prepend( elem : LL_first(.0),
        to : self(LL_nonfirst(.0),.1,LL_pred(.2)))
    !! self(LL_nonfirst(.0),LL_pred(.1),LL_pred(.2))
);

Muldis_D.Low_Level.LL_every_elem_same_count ::= function
    (LL_Boolean <-- List)
: (
       LL_empty(.0)              ?? LL_TRUE()
    !! LL_empty(LL_nonfirst(.0)) ?? LL_TRUE()
    !! LL_same(LL_count(LL_first(.0)),LL_count(LL_second(.0)))
        ?? self(LL_nonfirst(.0))
    !! LL_FALSE()
);

/*************************************************************************/

Muldis_D.Low_Level.LL_Structure_Base ::= type of LL_Pair
    where (LL_first(.0) isa $LL_Natural);

Muldis_D.Low_Level.LL_Structure ::=
    LL_Integer|LL_String|LL_Array|LL_Heading|LL_Renaming|LL_Tuple
    |LL_Relation|LL_Identifier|LL_Capsule|LL_Stream|LL_External
    default LL_FALSE();

Muldis_D.Low_Level.LL_structure_kind ::= function
    (LL_List <-- 0|struct : LL_Structure_Base) : LL_first(.0);

Muldis_D.Low_Level.LL_payload ::= function
    (LL_List <-- 0|struct : LL_Structure_Base) : LL_second(.0);

/*************************************************************************/

Muldis_D.Low_Level.LL_SK_INTEGER    ::= LL_ZERO;
Muldis_D.Low_Level.LL_SK_STRING     ::= LL_1;
Muldis_D.Low_Level.LL_SK_ARRAY      ::= LL_2;
Muldis_D.Low_Level.LL_SK_HEADING    ::= LL_3;
Muldis_D.Low_Level.LL_SK_RENAMING   ::= LL_4;
Muldis_D.Low_Level.LL_SK_TUPLE      ::= LL_5;
Muldis_D.Low_Level.LL_SK_RELATION   ::= LL_6;
Muldis_D.Low_Level.LL_SK_IDENTIFIER ::= LL_7;
Muldis_D.Low_Level.LL_SK_CAPSULE    ::= LL_8;
Muldis_D.Low_Level.LL_SK_STREAM     ::= LL_9;
Muldis_D.Low_Level.LL_SK_EXTERNAL   ::= LL_10;

/*************************************************************************/

/* An LL_Integer payload is a list of exactly 2 elements where the first
   element is
   LL_FALSE if the numeric value is >= 0 and LL_TRUE if the numeric value
   is < 0; that first element can be read as "is negative (false/true)".
   The second element is a LL_Natural that defines the magnitude of the
   integer's numeric value.  Every combination of first/second elements is
   valid with the sole exception of [true,0] as we don't want 2 zero ints.
   This is exposed in the high level type system as Integer. */

Muldis_D.Low_Level.LL_Integer ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_INTEGER())
        ?? LL_payload(.0) isa $LL_Integer_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_Integer_Payload ::= type of LL_Pair where
(
    is_neg    ::= LL_first(.0);
    magnitude ::= LL_second(.0);
    if is_neg isa $LL_Boolean then
        if magnitude isa $LL_Natural then
            if LL_same(magnitude,LL_ZERO()) then
                LL_same(is_neg,LL_FALSE())
            else LL_TRUE()
        else LL_FALSE()
    else LL_FALSE();
);

Muldis_D.Low_Level.LL_integer ::= function
    (LL_Integer <-- LL_Integer_Payload)
    : \*:[LL_SK_INTEGER(),.0];

Muldis_D.Low_Level.LL_is_neg ::= function (LL_Boolean <-- LL_Integer)
    : LL_first(LL_payload(.0));

Muldis_D.Low_Level.LL_magnitude ::= function
    (LL_Natural <-- LL_Integer)
    : LL_second(LL_payload(.0));

/*************************************************************************/

Muldis_D.Low_Level.LL_String ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_STRING())
        ?? LL_payload(.0) isa $LL_String_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_String_Payload ::= type of LL_List
    where (LL_empty(.0) ?? LL_TRUE()
        !! LL_first(.0) isa $LL_Integer_Payload
        ?? self(LL_nonfirst(.0)) !! LL_FALSE());

Muldis_D.Low_Level.LL_string ::= function
    (LL_String <-- LL_String_Payload)
    : \*:[LL_SK_STRING(),.0];

Muldis_D.Low_Level.LL_List_of_String_Payloads ::= type of LL_List
    where (LL_empty(.0) ?? LL_TRUE() !! LL_first(.0) isa $LL_String_Payload
        ?? self(LL_nonfirst(.0)) !! LL_FALSE());

/*************************************************************************/

Muldis_D.Low_Level.LL_Array ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_ARRAY()));

Muldis_D.Low_Level.LL_array ::= function (LL_Array <-- LL_List)
    : \*:[LL_SK_ARRAY(),.0];

/*************************************************************************/

Muldis_D.Low_Level.LL_Heading ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_HEADING())
        ?? LL_payload(.0) isa $LL_Heading_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_Heading_Payload ::= type of LL_List_of_String_Payloads
    where (LL_elems_in_order(.0));

Muldis_D.Low_Level.LL_heading ::= function
    (LL_Heading <-- LL_Heading_Payload)
    : \*:[LL_SK_HEADING(),.0];

/*************************************************************************/

Muldis_D.Low_Level.LL_Renaming ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_RENAMING())
        ?? LL_payload(.0) isa $LL_Renaming_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_Renaming_Payload ::= type of LL_Pair where
(
    after  ::= LL_first(.0);
    before ::= LL_second(.0);
    if after isa $LL_Heading_Payload then
        if before isa $LL_List_of_String_Payloads then
            LL_same(LL_count(after),LL_count(before))
        else LL_FALSE()
    else LL_FALSE();
);

Muldis_D.Low_Level.LL_renaming ::= function (LL_Renaming <--
    LL_Renaming_Payload)
    : \*:[LL_SK_RENAMING(),.0];

Muldis_D.Low_Level.LL_renaming_after ::= function
    (LL_Heading_Payload <-- LL_Renaming) : LL_first(LL_payload(.0));

Muldis_D.Low_Level.LL_renaming_before ::= function
    (LL_List_of_String_Payloads <-- LL_Renaming)
    : LL_second(LL_payload(.0));

/*************************************************************************/

Muldis_D.Low_Level.LL_Tuple ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_TUPLE())
        ?? LL_payload(.0) isa $LL_Tuple_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_Tuple_Payload ::= type of LL_Pair where
(
    heading ::= LL_first(.0);
    body    ::= LL_second(.0);
    if heading isa $LL_Heading_Payload then
        LL_same(LL_count(heading),LL_count(body))
    else LL_FALSE();
);

Muldis_D.Low_Level.LL_tuple ::= function
    (LL_Tuple <-- LL_Tuple_Payload)
    : \*:[LL_SK_TUPLE(),.0];

Muldis_D.Low_Level.LL_tuple_heading ::= function
    (LL_Heading_Payload <-- LL_Tuple) : LL_first(LL_payload(.0));

Muldis_D.Low_Level.LL_tuple_body ::= function (LL_List <-- LL_Tuple)
    : LL_second(LL_payload(.0));

/*************************************************************************/

Muldis_D.Low_Level.LL_Relation ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_RELATION())
        ?? LL_payload(.0) isa $LL_Relation_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_Relation_Payload ::= type of LL_Pair where
(
    heading ::= LL_first(.0);
    body    ::= LL_second(.0);
    if heading isa $LL_Heading_Payload then
        if LL_empty(body) then
            LL_TRUE()
        else if LL_same(LL_count(heading),LL_count(LL_first(body))) then
            if LL_every_elem_same_count(body) then
                LL_elems_in_order(body)
            else LL_FALSE()
        else LL_FALSE()
    else LL_FALSE();
);

Muldis_D.Low_Level.LL_relation ::= function
    (LL_Relation <-- LL_Relation_Payload)
    : \*:[LL_SK_RELATION(),.0];

Muldis_D.Low_Level.LL_relation_heading ::= function
    (LL_Heading_Payload <-- LL_Relation) : LL_first(LL_payload(.0));

Muldis_D.Low_Level.LL_relation_body ::= function
    (LL_List <-- LL_Relation) : LL_second(LL_payload(.0));

/*************************************************************************/

Muldis_D.Low_Level.LL_IK_ABSOLUTE ::= LL_ZERO;
Muldis_D.Low_Level.LL_IK_RELATIVE ::= LL_1;
Muldis_D.Low_Level.LL_IK_SEARCH   ::= LL_2;

Muldis_D.Low_Level.LL_Identifier ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_IDENTIFIER())
        ?? LL_payload(.0) isa $LL_Identifier_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_Identifier_Payload ::= type of LL_List where
(
    <-- if is_quint_payload then
            if is_identifier_base then
                given identifier_kind
                when LL_IK_ABSOLUTE() then is_absolute
                when LL_IK_RELATIVE() then is_relative
                when LL_IK_SEARCH()   then is_search
                default LL_FALSE()
            else LL_FALSE()
        else LL_FALSE()
        ;

    is_quint_payload ::= LL_same(LL_count(.0),LL_5());

    identifier_kind     ::= LL_elem(.0,LL_ZERO());
    pkg_name_base       ::= LL_elem(.0,LL_1());
    pkg_name_ext        ::= LL_elem(.0,LL_2()); /* [authority, vnum] */
    path_beneath_pkg    ::= LL_elem(.0,LL_3());
    rel_starts_n_lev_up ::= LL_elem(.0,LL_4());

    is_identifier_base ::=
        if identifier_kind isa $LL_Natural then
            if pkg_name_base isa $LL_List_of_String_Payloads then
                if pkg_name_ext isa $LL_List_of_String_Payloads then
                    if path_beneath_pkg isa $LL_List_of_String_Payloads then
                        rel_starts_n_lev_up isa $LL_Natural
                    else LL_FALSE()
                else LL_FALSE()
            else LL_FALSE()
        else LL_FALSE()
        ;

    is_absolute ::=
        if LL_in_order(LL_count(pkg_name_ext),LL_2()) then
            LL_zero(rel_starts_n_lev_up)
        else LL_FALSE()
        ;

    is_relative ::=
        if LL_empty(pkg_name_base) then
            LL_empty(pkg_name_ext)
        else LL_FALSE()
        ;

    is_search ::=
        if LL_empty(pkg_name_base) then
            if LL_empty(pkg_name_ext) then
                LL_zero(rel_starts_n_lev_up)
            else LL_FALSE()
        else LL_FALSE()
        ;
);

Muldis_D.Low_Level.LL_identifier ::= function
    (LL_Identifier <-- LL_Identifier_Payload)
    : \*:[LL_SK_IDENTIFIER(),.0];

Muldis_D.Low_Level.LL_identifier_kind ::= function
    (LL_Natural <-- LL_Identifier)
    : LL_elem(LL_payload(.0),LL_ZERO());

Muldis_D.Low_Level.LL_pkg_name_base ::= function
    (LL_List_of_String_Payloads <-- LL_Identifier)
    : LL_elem(LL_payload(.0),LL_1());

Muldis_D.Low_Level.LL_pkg_name_ext ::= function
    (LL_List_of_String_Payloads <-- LL_Identifier)
    : LL_elem(LL_payload(.0),LL_2());

Muldis_D.Low_Level.LL_path_beneath_pkg ::= function
    (LL_List_of_String_Payloads <-- LL_Identifier)
    : LL_elem(LL_payload(.0),LL_3());

Muldis_D.Low_Level.LL_rel_starts_n_lev_up ::= function
    (LL_Natural <-- LL_Identifier) : LL_elem(LL_payload(.0),LL_4());

Muldis_D.Low_Level.LL_Reference ::= type of LL_Identifier where
(
    if LL_same(LL_identifier_kind(.0),LL_IK_ABSOLUTE()) then
        if LL_empty(LL_pkg_name_base(.0)) then
            LL_FALSE()
        else LL_same(LL_count(LL_pkg_name_ext(.0)),LL_2())
    else LL_FALSE()
);

Muldis_D.Low_Level.LL_every_elem_isa ::= function
    (LL_Boolean <-- 0|list : LL_List, 1|type : LL_Reference)
    : (LL_empty(.0) ?? LL_TRUE()
        !! LL_first(.0) isa .1 ?? self(LL_nonfirst(.0),.1) !! LL_FALSE());

/*************************************************************************/

Muldis_D.Low_Level.LL_Capsule ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_CAPSULE())
        ?? LL_payload(.0) isa $LL_Capsule_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_Capsule_Payload ::= type of LL_Pair
    where (LL_first(.0) isa $LL_Reference_Payload
        ?? LL_second(.0) isa $LL_Tuple_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_capsule ::= function (LL_Capsule <--
    LL_Capsule_Payload)
    : \*:[LL_SK_CAPSULE(),.0];

Muldis_D.Low_Level.LL_capsule_type ::= function
    (LL_Reference_Payload <-- LL_Capsule) : LL_first(LL_payload(.0));

Muldis_D.Low_Level.LL_capsule_attrs ::= function
    (LL_Tuple_Payload <-- LL_Capsule) : LL_second(LL_payload(.0));

/*************************************************************************/

Muldis_D.Low_Level.LL_Stream ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_STREAM())
        ?? LL_payload(.0) isa $LL_Integer_Payload !! LL_FALSE());

Muldis_D.Low_Level.LL_stream ::= function
    (LL_Stream <-- LL_Integer_Payload)
    : \*:[LL_SK_STREAM(),.0];

/*************************************************************************/

Muldis_D.Low_Level.LL_External ::= type of LL_Structure_Base
    where (LL_same(LL_structure_kind(.0),LL_SK_EXTERNAL()));

Muldis_D.Low_Level.LL_external ::= function
    (LL_External <-- LL_List) : \*:[LL_SK_EXTERNAL(),.0];

/*************************************************************************/

/* Two values are normally considered to have the same low-level type only
   if they are both values of the same one of the types {Boolean, Integer,
   String, Array, SC_Heading, SC_Renaming, Tuple, Relation, SC_Identifier,
   Capsule, Stream, External}, but as a special case, we treat each value
   that isn't of any of those types as having its own singleton type, and
   so every type system value has the same low-level type as itself. */

Muldis_D.Low_Level.LL_same_low_level_type ::= function
    (LL_Boolean <-- LL_List, LL_List) is_commutative
: (
    if .0 isa $LL_Boolean then
        .1 isa $LL_Boolean
    else if .0 isa $LL_Structure then
        if .1 isa $LL_Structure then
            LL_same(LL_structure_kind(.0),LL_structure_kind(.1))
        else LL_FALSE()
    else LL_same(.0,.1)
);
