Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package_segment Muldis_D:"http://muldis.com":0:Array;

/*************************************************************************/

/* TODO - THIS FILE IS OUT OF DATE - INTEGERS NOW STRUCTURES NOT OPAQUE. */

MD.Arrayish ::= abstract_type composes Ordered;

MD.Array ::= LL_Array composes Arrayish;

/*************************************************************************/

/* Note that this will die if any array elements need to be compared other
   than for equality but there is no "<=>" defined for their type. */

MD.Array."<=>"|order ::= function
    (Order <-- 0|lhs : Array, 1|rhs : Array)
    implements Ordered."<=>"
: (
       .0->is_empty() ?? (.1->is_empty() ?? $=>Same !! $=>Less)
    !! .1->is_empty() ?? $=>More
    !! .0->first_elem() = .1->first_elem()
        ?? self(.0->nonfirst_elems(),.1->nonfirst_elems())
    !! .0->first_elem() <=> .1->first_elem()
);

/*************************************************************************/

MD.Array.is_empty ::= function (Boolean <-- Array)
    : LL_empty(LL_payload(.0));

MD.Array.is_not_empty ::= function (Boolean <-- Array)
    : !.0->is_empty();

MD.Array.first_elem ::= function (Universal <-- Array)
    requires (.0->is_not_empty()) : LL_first(LL_payload(.0));

MD.Array.nonfirst_elems ::= function (Array <-- Array)
    requires (.0->is_not_empty()) : ...;

MD.Array."#"|count|cardinality ::= function
    (Integer.NN <-- Array) : ...;

/* Note that the ".[]" syntax is implemented using this function. */

MD.Array.elem ::= function
    (Universal <-- 0|array : Array, 1|index : Integer.NN)
    requires ... : ...;

MD.Array.every_elem_isa ::= function
    (Boolean <-- 0|array : Array, 1|type : SC_Reference)
    : LL_every_elem_isa(LL_payload(.0),.1);
