Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package_segment Muldis_D:"http://muldis.com":0:Boolean;

/*************************************************************************/

MD.Boolish ::= abstract_type composes Ordinal;

MD.Boolean ::= synonym of LL_Boolean composes Boolish;

MD.Bool ::= synonym of Boolean;

/*************************************************************************/

MD.Boolean."<=>"|order ::= function
    (Order <-- 0|lhs : Boolean, 1|rhs : Boolean)
    implements Ordered."<=>"
: (
       .0 = .1 ?? $=>Same
    !! .1      ?? $=>Less
    !!            $=>More
);

/*************************************************************************/

MD.Boolean."--"|pred|dec ::= function (Boolean|"-Inf" <-- Boolean)
    implements Ordinal."--" : (.0 ?? false !! $=>"-Inf");

MD.Boolean."++"|succ|inc ::= function (Boolean|"+Inf" <-- Boolean)
    implements Ordinal."++" : (!.0 ?? true !! $=>"+Inf");

/*************************************************************************/

/* Note that "false" is a keyword; this function implements it. */

MD.Boolean.false|contradiction ::= synonym of LL_FALSE
    implements Boolish."false";

/* Note that "true" is a keyword; this function implements it. */

MD.Boolean.true|tautology ::= synonym of LL_TRUE
    implements Boolish."true";

/*************************************************************************/

MD.Boolean.so|"?"|proposition ::= function (Boolean <-- Boolean)
    implements Boolish.so : .0;

/* Note that "not"|"!" is a meta-keyword; this function implements it. */

MD.Boolean.not|"!"|negation ::= function (Boolean <-- Boolean)
    implements Boolish.not : (.0 ?? false !! true);

/*************************************************************************/

MD.Boolean.and|all|every|conjunction ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.and
    is_commutative is_associative identity true is_idempotent
    : (.0 ?? .1 !! false);

MD.Boolean.nand|not_and|not_both|alternative_denial ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.nand
    is_commutative
    : (.0 !and .1);

/*************************************************************************/

MD.Boolean.or|any|some|disjunction ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.or
    is_commutative is_associative identity false is_idempotent
    : (.0 ?? true !! .1);

MD.Boolean.nor|not_or|joint_denial ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.nor
    is_commutative
    : (.0 !or .1);

/*************************************************************************/

MD.Boolean.xnor|iff|biconditional|material_equivalence ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.xnor
    is_commutative is_associative identity true
    : (.0 = .1);

MD.Boolean.xor|exclusive_disjunction ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.xor
    is_commutative is_associative identity false
    : (.0 != .1);

/*************************************************************************/

MD.Boolean.imp|implies|material_implication ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.imp
    : (.0 ?? .1 !! true);

MD.Boolean.nimp|not_implies|material_nonimplication ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.nimp
    : (.0 !imp .1);

/*************************************************************************/

/* Note that "if" is also a keyword, but its meaning differs. */

MD.Boolean.if|converse_implication ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.if
    : (.1 imp .0);

MD.Boolean.nif|not_if|converse_nonimplication ::= function
    (Boolean <-- Boolean, Boolean)
    implements Boolish.nif
    : (.1 nimp .0);

/*************************************************************************/
