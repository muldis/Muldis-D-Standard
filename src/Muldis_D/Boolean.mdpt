Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package_segment Muldis_D:"http://muldis.com":0:Boolean;

/*************************************************************************/

Muldis_D.Boolish ::= abstract_type composes Ordinal;

Muldis_D.Boolean ::= LL_Boolean composes Boolish;

Muldis_D.Bool ::= Boolean;

Muldis_D.Boolean.False ::= LL_False;

Muldis_D.Boolean.True ::= LL_True;

/*************************************************************************/

Muldis_D.Boolean."<=>"|order ::= function
    (Order <-- 0|lhs : Boolean, 1|rhs : Boolean)
    implements Ordered."<=>"
: (
       .0 = .1 ?? :$Order.Same
    !! .1      ?? :$Order.Less
    !!            :$Order.More
);

/*************************************************************************/

Muldis_D.Boolean.False."--"|pred|dec ::= function ("-Inf" <-- 0 : False)
    implements Ordinal."--" : (:$"-Inf");

Muldis_D.Boolean.True."--"|pred|dec ::= function (False <-- 0 : True)
    implements Ordinal."--" : (false);

Muldis_D.Boolean.False."++"|succ|inc ::= function (True <-- 0 : False)
    implements Ordinal."++" : (true);

Muldis_D.Boolean.True."++"|succ|inc ::= function ("+Inf" <-- 0 : True)
    implements Ordinal."++" : (:$"+Inf");

/*************************************************************************/

/* Note that "false" is a keyword; this function implements it. */

Muldis_D.Boolean.false|contradiction ::= LL_FALSE
    implements Boolish."false";

/* Note that "true" is a keyword; this function implements it. */

Muldis_D.Boolean.true|tautology ::= LL_TRUE
    implements Boolish."true";

/*************************************************************************/

Muldis_D.Boolean.so|"?"|proposition ::= function (Boolean <-- 0 : Boolean)
    implements Boolish.so : (.0);

/* Note that "not"|"!" is a meta-keyword; this function implements it. */

Muldis_D.Boolean.not|"!"|negation ::= function (Boolean <-- 0 : Boolean)
    implements Boolish.not : (.0 ?? false !! true);

/*************************************************************************/

Muldis_D.Boolean.and|all|every|conjunction ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.and
    is_commutative is_associative identity true is_idempotent
    : (.0 ?? .1 !! false);

Muldis_D.Boolean.nand|not_and|not_both|alternative_denial ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.nand
    is_commutative
    : (.0 !and .1);

/*************************************************************************/

Muldis_D.Boolean.or|any|some|disjunction ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.or
    is_commutative is_associative identity false is_idempotent
    : (.0 ?? true !! .1);

Muldis_D.Boolean.nor|not_or|joint_denial ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.nor
    is_commutative
    : (.0 !or .1);

/*************************************************************************/

Muldis_D.Boolean.xnor|iff|biconditional|material_equivalence ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.xnor
    is_commutative is_associative identity true
    : (.0 = .1);

Muldis_D.Boolean.xor|exclusive_disjunction ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.xor
    is_commutative is_associative identity false
    : (.0 != .1);

/*************************************************************************/

Muldis_D.Boolean.imp|implies|material_implication ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.imp
    : (.0 ?? .1 !! true);

Muldis_D.Boolean.nimp|not_implies|material_nonimplication ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.nimp
    : (.0 !imp .1);

/*************************************************************************/

/* Note that "if" is also a keyword, but its meaning differs. */

Muldis_D.Boolean.if|converse_implication ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.if
    : (.1 imp .0);

Muldis_D.Boolean.nif|not_if|converse_nonimplication ::= function
    (Boolean <-- 0 : Boolean, 1 : Boolean)
    implements Boolish.nif
    : (.1 nimp .0);

/*************************************************************************/
