Muldis_D:Plain_Text:ASCII:"http://muldis.com":"0.200";

package_segment Muldis_D:"http://muldis.com":"0.200":Rational;

/*************************************************************************/

MD.Rational ::= type abstract composes Numeric;

MD.Anormal_Ratio ::= type of Capsule
    where (
        Capsule_type(topic) = $Ratio
        and 
        has_just_attrs(topic,\%{
            numerator   : $Integer,
            denominator : $Integer.P,
        })
    )
    default 0.0
    composes {Rational,Cardinal,Ordered};

MD.Ratio ::= type of Anormal_Ratio where normal(topic) = topic;

MD.Ratio.NN ::= type of Ratio where topic >= 0.0;

MD.Ratio.P ::= type of Ratio.NN where topic > 0.0 default 1.0;

/*************************************************************************/

/* This is a common normalizing selector that can be used to implement
   various syntaxes for selecting a Ratio, such as "Int/Int". */

MD.Ratio.select_Ratio ::= function
    --> Ratio <-- (0|numerator : Integer, 1|denominator : Integer)
    requires (.1 != 0)
    : normal($Ratio => \%{ numerator : .0, denominator : .1 });

MD.Ratio.normal ::= function --> Ratio <-- (Anormal_Ratio)
: (
    an ::= .0.>numerator;
    ad ::= .0.>denominator;

    /* Normalize pair so denominator is always > 0. */
    n ::= (ad > 0 ?? an !! -an);
    d ::= (ad > 0 ?? ad !! -ad);

    /* Determine greatest common divisor of pair. */
    gcd ::= gcd(abs(n), abs(d));

    <-- $Ratio => \%{
        numerator   : div( n, gcd, round_meth : $=>To_Zero ),
        denominator : div( d, gcd, round_meth : $=>To_Zero ),
    };
);

/*************************************************************************/

MD.Ratio."<=>" ::= function --> Order <-- (Ratio, Ratio)
    implements Ordered."<=>"
: (
    if .0.>denominator = .1.>denominator then
        .0.>numerator <=> .1.>numerator
    else
      (
        common_d ::= lcm(.0.>denominator, .1.>denominator);
        <-- (.0.>numerator
                * div(common_d, .0.>denominator, round_meth : $=>To_Zero))
            <=> (.1.>numerator
                * div(common_d, .1.>denominator, round_meth : $=>To_Zero))
      )
);

MD.Ratio.order ::= synonym of "<=>";

/*************************************************************************/

MD.Ratio.monadic."-" ::= function
    --> Ratio <-- (Ratio) implements Numeric.monadic."-"
    : $Ratio => \%{ numerator : -.0.>numerator,
        denominator : .0.>denominator };

MD.Ratio.opposite         ::= synonym of monadic."-";
MD.Ratio.additive_inverse ::= synonym of monadic."-";

MD.Ratio.reciprocal ::= function
    --> Ratio <-- (Ratio) requires (.0 != 0.0) implements Numeric.reciprocal
    : select_Ratio( .0.>denominator, .0.>numerator );

MD.Ratio.multiplicative_inverse ::= synonym of reciprocal;

MD.Ratio.abs ::= function --> Ratio.NN <-- (Ratio)
    implements Numeric.abs
    : $Ratio => \%{ numerator : abs(.0.>numerator),
        denominator : .0.>denominator };

MD.Ratio.modulus ::= synonym of abs;

MD.Ratio."+" ::= function
    --> Ratio <-- (0|augend : Ratio, 1|addend : Ratio)
    implements Numeric."+" is {commutative,associative} identity 0.0
: (
    if .0.>denominator = .1.>denominator then
        select_Ratio(.0.>numerator + .1.>numerator, .0.>denominator)
    else
      (
        common_d ::= lcm(.0.>denominator, .1.>denominator);
        <-- select_Ratio(
            (.0.>numerator
                * div(common_d, .0.>denominator, round_meth : $=>To_Zero))
            + (.1.>numerator
                * div(common_d, .1.>denominator, round_meth : $=>To_Zero)),
            common_d
        );
      )
);

MD.Ratio.plus ::= synonym of "+";
MD.Ratio.add  ::= synonym of "+";
MD.Ratio.sum  ::= synonym of "+";

MD.Ratio."-" ::= function
    --> Ratio <-- (0|minuend : Ratio, 1|subtrahend : Ratio)
    implements Numeric."-" : .0 + -.1;

MD.Ratio.minus      ::= synonym of "-";
MD.Ratio.subtract   ::= synonym of "-";
MD.Ratio.diff       ::= synonym of "-";
MD.Ratio.difference ::= synonym of "-";

MD.Ratio."|-|" ::= function
    --> Ratio.NN <-- (0|minuend : Ratio, 1|subtrahend : Ratio)
    implements Numeric."|-|" : abs(.0 + -.1);

MD.Ratio.abs_diff  ::= synonym of "|-|";
MD.Ratio.abs_minus ::= synonym of "|-|";

MD.Ratio."*" ::= function
    --> Ratio <-- (0|multiplicand : Ratio, 1|multiplier : Ratio)
    implements Numeric."*" is {commutative,associative} identity 1.0
    : select_Ratio( .0.>numerator * .1.>numerator,
        .0.>denominator * .1.>denominator );

MD.Ratio.times    ::= synonym of "*";
MD.Ratio.multiply ::= synonym of "*";
MD.Ratio.product  ::= synonym of "*";

MD.Ratio."/" ::= function
    --> Ratio <-- (0|dividend : Ratio, 1|divisor : Ratio)
    requires (.1 != 0.0)
    implements Numeric."/"
    : .0 * reciprocal(.1);

MD.Ratio.frac_divide   ::= synonym of "/";
MD.Ratio.frac_quotient ::= synonym of "/";

MD.Ratio.div ::= function
    --> Ratio <-- (0|dividend : Ratio, 1|divisor : Ratio,
        round_meth : Round_Meth)
    requires (.1 != 0.0) implements Numeric.div
: (
    /* Bring 2 inputs to common denominator like with addition. */
    orig_d ::= lcm(.0.>denominator, .1.>denominator);
    orig_n0 ::= (.0.>numerator
        * div(orig_d, .0.>denominator, round_meth : $=>To_Zero));
    orig_n1 ::= (.1.>numerator
        * div(orig_d, .1.>denominator, round_meth : $=>To_Zero));

    /* Scale both inputs proportionally into whole-number range. */
    scaled_n0 ::= orig_n0 * orig_d;
    scaled_n1 ::= orig_n1 * orig_d;

    /* Use regular Integer whole_divide semantics on the numerators. */
    scaled_q ::= div(scaled_n0, scaled_n1, round_meth : .round_meth);

    /* Result still of the Ratio type even though its a whole number. */
    <-- select_Ratio( scaled_q, 1 );
);

MD.Ratio.whole_divide   ::= synonym of div;
MD.Ratio.whole_quotient ::= synonym of div;

MD.Ratio.mod ::= function
    --> Ratio <-- (0|dividend : Ratio, 1|divisor : Ratio,
        round_meth : Round_Meth)
    requires (.1 != 0.0) implements Numeric.mod
    : (.0 - (.1 * div(*topic)));

MD.Ratio.modulo    ::= synonym of mod;
MD.Ratio.remainder ::= synonym of mod;

MD.Ratio.divide_and_modulo ::= function
    --> type of Tuple where (has_attrs(topic,\%{ quotient : $Ratio,
        remainder : $Ratio })) <--
        (0|dividend : Ratio, 1|divisor : Ratio, round_meth : Round_Meth)
    requires (.1 != 0.0) implements Numeric.divide_and_modulo
    : (\%{ quotient : div(*topic), remainder : mod(*topic) });

MD.Ratio.quot_and_rem ::= synonym of divide_and_modulo;
