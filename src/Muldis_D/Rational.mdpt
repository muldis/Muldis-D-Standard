Muldis_D:Plain_Text:ASCII:"http://muldis.com":"0.200";

package_segment Muldis_D:"http://muldis.com":"0.200":Rational;

/*************************************************************************/

MD.Rational ::= abstract_type composes Numeric;

MD.Anormal_Ratio ::= type of Capsule
    where (
        Capsule_type(topic) = $Ratio
        and 
        has_just_attrs(topic,\%{
            numerator   : $Integer,
            denominator : $Integer.P,
        })
    )
    default 0.0
    composes Rational composes Cardinal composes Ordered;

MD.Ratio ::= type of Anormal_Ratio where normal(topic) = topic;

MD.Ratio.NN ::= type of Ratio where topic >= 0.0;

MD.Ratio.P ::= type of Ratio.NN where topic > 0.0 default 1.0;

/*************************************************************************/

/* This is a common normalizing selector that can be used to implement
   various syntaxes for selecting a Ratio, such as "Int/Int". */

MD.Ratio.select_Ratio ::= function
    (Ratio <-- 0|numerator : Integer, 1|denominator : Integer)
    requires (.1 != 0)
    : normal($Ratio => \%{ numerator : .0, denominator : .1 });

MD.Ratio.normal ::= function (Ratio <-- Anormal_Ratio)
: (
    an ::= .0->numerator;
    ad ::= .0->denominator;

    /* Normalize pair so denominator is always > 0. */
    n ::= (ad > 0 ?? an !! -an);
    d ::= (ad > 0 ?? ad !! -ad);

    /* Determine greatest common divisor of pair. */
    gcd ::= gcd(abs(n), abs(d));

    <-- $Ratio => \%{
        numerator   : div( n, gcd, round_meth : $=>To_Zero ),
        denominator : div( d, gcd, round_meth : $=>To_Zero ),
    };
);

/*************************************************************************/

MD.Ratio."<=>"|order ::= function
    (Order <-- 0|lhs : Ratio, 1|rhs : Ratio)
    implements Ordered."<=>"
: (
    if .0->denominator = .1->denominator then
        .0->numerator <=> .1->numerator
    else
      (
        common_d ::= lcm(.0->denominator, .1->denominator);
        <-- (.0->numerator
                * div(common_d, .0->denominator, round_meth : $=>To_Zero))
            <=> (.1->numerator
                * div(common_d, .1->denominator, round_meth : $=>To_Zero))
      )
);

/*************************************************************************/

MD.Ratio.monadic."-"|opposite|additive_inverse ::= function
    (Ratio <-- Ratio) implements Numeric.monadic."-"
    : $Ratio => \%{ numerator : -.0->numerator,
        denominator : .0->denominator };

MD.Ratio.reciprocal|multiplicative_inverse ::= function
    (Ratio <-- Ratio) requires (.0 != 0.0) implements Numeric.reciprocal
    : select_Ratio( .0->denominator, .0->numerator );

MD.Ratio.abs|modulus ::= function (Ratio.NN <-- Ratio)
    implements Numeric.abs
    : $Ratio => \%{ numerator : abs(.0->numerator),
        denominator : .0->denominator };

MD.Ratio."+"|plus|add|sum ::= function
    (Ratio <-- 0|augend : Ratio, 1|addend : Ratio)
    implements Numeric."+" is {commutative,associative} identity 0.0
: (
    if .0->denominator = .1->denominator then
        select_Ratio(.0->numerator + .1->numerator, .0->denominator)
    else
      (
        common_d ::= lcm(.0->denominator, .1->denominator);
        <-- select_Ratio(
            (.0->numerator
                * div(common_d, .0->denominator, round_meth : $=>To_Zero))
            + (.1->numerator
                * div(common_d, .1->denominator, round_meth : $=>To_Zero)),
            common_d
        );
      )
);

MD.Ratio."-"|minus|subtract|diff|difference ::= function
    (Ratio <-- 0|minuend : Ratio, 1|subtrahend : Ratio)
    implements Numeric."-" : .0 + -.1;

MD.Ratio."|-|"|abs_minus|abs_diff ::= function
    (Ratio.NN <-- 0|minuend : Ratio, 1|subtrahend : Ratio)
    implements Numeric."|-|" : abs(.0 + -.1);

MD.Ratio."*"|times|multiply|product ::= function
    (Ratio <-- 0|multiplicand : Ratio, 1|multiplier : Ratio)
    implements Numeric."*" is {commutative,associative} identity 1.0
    : select_Ratio( .0->numerator * .1->numerator,
        .0->denominator * .1->denominator );

MD.Ratio."/"|frac_divide|frac_quotient ::= function
    (Ratio <-- 0|dividend : Ratio, 1|divisor : Ratio)
    requires (.1 != 0.0)
    implements Numeric."/"
    : .0 * reciprocal(.1);

MD.Ratio.div|whole_divide|whole_quotient ::= function
    (Ratio <-- 0|dividend : Ratio, 1|divisor : Ratio,
        round_meth : Round_Meth)
    requires (.1 != 0.0) implements Numeric.div
: (
    /* Bring 2 inputs to common denominator like with addition. */
    orig_d ::= lcm(.0->denominator, .1->denominator);
    orig_n0 ::= (.0->numerator
        * div(orig_d, .0->denominator, round_meth : $=>To_Zero));
    orig_n1 ::= (.1->numerator
        * div(orig_d, .1->denominator, round_meth : $=>To_Zero));

    /* Scale both inputs proportionally into whole-number range. */
    scaled_n0 ::= orig_n0 * orig_d;
    scaled_n1 ::= orig_n1 * orig_d;

    /* Use regular Integer whole_divide semantics on the numerators. */
    scaled_q ::= div(scaled_n0, scaled_n1, round_meth : .round_meth));

    /* Result still of the Ratio type even though its a whole number. */
    <-- select_Ratio( scaled_q, 1 );
);

MD.Ratio.mod|modulo|remainder ::= function
    (Ratio <-- 0|dividend : Ratio, 1|divisor : Ratio,
        round_meth : Round_Meth)
    requires (.1 != 0.0) implements Numeric.mod
    : (.0 - (.1 * div(*topic)));

MD.Ratio.divide_and_modulo|quot_and_rem ::= function
    (type of Tuple where (has_attrs(topic,\%{ quotient : $Ratio,
        remainder : $Ratio })) <--
        0|dividend : Ratio, 1|divisor : Ratio, round_meth : Round_Meth)
    requires (.1 != 0.0) implements Numeric.divide_and_modulo
    : (\%{ quotient : div(*topic), remainder : mod(*topic) });
