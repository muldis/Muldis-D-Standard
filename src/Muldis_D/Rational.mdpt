Muldis_D:Plain_Text:"http://muldis.com":"0.200";

script ASCII;

package_segment Muldis_D:"http://muldis.com":"0.200":Rational;

/*************************************************************************/

MD.Rational ::= type abstract composes Numeric;

MD.Anormal_Ratio ::= type of Capsule
    where (
        Capsule_type(topic) = $Ratio
        and 
        has_just_attrs(topic,\%{
            numerator   : $Integer,
            denominator : $Integer.P,
        })
    )
    default 0.0
    composes {Rational and_provides_its_default,Cardinal,Ordered};

MD.Ratio."" ::= type of Anormal_Ratio where normal(topic) = topic;

MD.Ratio.NN ::= type of Ratio where topic >= 0.0;

MD.Ratio.P ::= type of Ratio.NN where topic > 0.0 default 1.0;

/*************************************************************************/

/* This is a common normalizing selector that can be used to implement
   various syntaxes for selecting a Ratio, such as "Int/Int". */

MD.Ratio.select_Ratio ::= function --> Ratio <-- (Integer, Integer)
    requires (.1 != 0)
    : normal($Ratio => \%{ numerator : .0, denominator : .1 });

MD.Ratio.named.select_Ratio ::= function
    --> Ratio <-- (numerator : Integer, denominator : Integer)
    requires (.denominator != 0)
    : select_Ratio(.numerator,.denominator);

MD.Ratio.normal ::= function --> Ratio <-- (Anormal_Ratio)
: (
    an ::= .0.>numerator;
    ad ::= .0.>denominator;

    /* Normalize pair so denominator is always > 0. */
    n ::= (ad > 0 ?? an !! -an);
    d ::= (ad > 0 ?? ad !! -ad);

    /* Determine greatest common divisor of pair. */
    gcd ::= gcd(abs(n), abs(d));

    <-- $Ratio => \%{
        numerator   : div( n, gcd, round_meth : $=>To_Zero ),
        denominator : div( d, gcd, round_meth : $=>To_Zero ),
    };
);

/*************************************************************************/

MD.Ratio."<=>" ::= function --> Order <-- (Ratio, Ratio)
    implements Ordered."<=>"
: (
    <-- .0.>denominator = .1.>denominator ?? .0.>numerator <=> .1.>numerator
     !!
      (
        common_d ::= lcm(.0.>denominator, .1.>denominator);
        <-- (.0.>numerator
                * div(common_d, .0.>denominator, round_meth : $=>To_Zero))
            <=> (.1.>numerator
                * div(common_d, .1.>denominator, round_meth : $=>To_Zero))
      )
);

MD.Ratio.order ::= synonym of "<=>";

/*************************************************************************/

MD.Ratio.monadic."-" ::= function --> Ratio <-- (Ratio)
    implements Numeric.monadic."-"
    : $Ratio => \%{ numerator : -.0.>numerator,
        denominator : .0.>denominator };

MD.Ratio.opposite         ::= synonym of monadic."-";
MD.Ratio.additive_inverse ::= synonym of monadic."-";

MD.Ratio.reciprocal ::= function --> Ratio <-- (Ratio)
    implements Numeric.reciprocal
    requires (.0 != 0.0)
    : select_Ratio( .0.>denominator, .0.>numerator );

MD.Ratio.multiplicative_inverse ::= synonym of reciprocal;

MD.Ratio.abs ::= function --> Ratio.NN <-- (Ratio)
    implements Numeric.abs
    : $Ratio => \%{ numerator : abs(.0.>numerator),
        denominator : .0.>denominator };

MD.Ratio.modulus ::= synonym of abs;

MD.Ratio."+" ::= function --> Ratio <-- (Ratio, Ratio)
    implements Numeric."+"
    is {commutative,associative} identity 0.0
: (
    <-- .0.>denominator = .1.>denominator
        ?? select_Ratio(.0.>numerator + .1.>numerator, .0.>denominator)
     !!
      (
        common_d ::= lcm(.0.>denominator, .1.>denominator);
        <-- select_Ratio(
            (.0.>numerator
                * div(common_d, .0.>denominator, round_meth : $=>To_Zero))
            + (.1.>numerator
                * div(common_d, .1.>denominator, round_meth : $=>To_Zero)),
            common_d
        );
      )
);

MD.Ratio.plus ::= synonym of "+";
MD.Ratio.add  ::= synonym of "+";

MD.Ratio.sum ::= function
    --> Ratio <-- (augend : Ratio, addend : Ratio)
    implements Numeric.sum
    : .augend + .addend];

MD.Ratio."-" ::= function --> Ratio <-- (Ratio, Ratio)
    implements Numeric."-"
    : .0 + -.1;

MD.Ratio.minus    ::= synonym of "-";
MD.Ratio.subtract ::= synonym of "-";

MD.Ratio.diff ::= function
    --> Ratio <-- (minuend : Ratio, subtrahend : Ratio)
    implements Numeric.diff
    : .minuend - .subtrahend;

MD.Ratio.difference ::= synonym of diff;

MD.Ratio."|-|" ::= function --> Ratio.NN <-- (Ratio, Ratio)
    implements Numeric."|-|"
    is {commutative}
    : abs(.0 + -.1);

MD.Ratio.abs_minus ::= synonym of "|-|";

MD.Ratio.abs_diff ::= function
    --> Ratio.NN <-- (minuend : Ratio, subtrahend : Ratio)
    implements Numeric."|-|"
    : .minuend |-| .subtrahend;

MD.Ratio."*" ::= function --> Ratio <-- (Ratio, Ratio)
    implements Numeric."*"
    is {commutative,associative} identity 1.0
    : select_Ratio( .0.>numerator * .1.>numerator,
        .0.>denominator * .1.>denominator );

MD.Ratio.times    ::= synonym of "*";
MD.Ratio.multiply ::= synonym of "*";

MD.Ratio.product ::= function
    --> Ratio <-- (multiplicand : Ratio, multiplier : Ratio)
    implements Numeric.product
    : .multiplicand * .multiplier;

MD.Ratio."/" ::= function --> Ratio <-- (Ratio, Ratio)
    implements Numeric."/"
    requires (.1 != 0.0)
    : .0 * reciprocal(.1);

MD.Ratio.frac_divide ::= synonym of "/";

MD.Ratio.frac_quotient ::= function
    --> Ratio <-- (dividend : Ratio, divisor : Ratio)
    implements Numeric."/"
    requires (.divisor != 0.0)
    : .dividend / .divisor;

MD.Ratio.div ::= function
    --> Ratio <-- (Ratio, Ratio, round_meth : Round_Meth)
    implements Numeric.div
    requires (.1 != 0.0)
: (
    /* Bring 2 inputs to common denominator like with addition. */
    orig_d ::= lcm(.0.>denominator, .1.>denominator);
    orig_n0 ::= (.0.>numerator
        * div(orig_d, .0.>denominator, round_meth : $=>To_Zero));
    orig_n1 ::= (.1.>numerator
        * div(orig_d, .1.>denominator, round_meth : $=>To_Zero));

    /* Scale both inputs proportionally into whole-number range. */
    scaled_n0 ::= orig_n0 * orig_d;
    scaled_n1 ::= orig_n1 * orig_d;

    /* Use regular Integer whole_divide semantics on the numerators. */
    scaled_q ::= div(scaled_n0, scaled_n1, round_meth : .round_meth);

    /* Result still of the Ratio type even though its a whole number. */
    <-- select_Ratio( scaled_q, 1 );
);

MD.Ratio.whole_divide ::= synonym of div;

MD.Ratio.whole_quotient ::= function
    --> Ratio <-- (dividend : Ratio, divisor : Ratio,
        round_meth : Round_Meth)
    implements Numeric.whole_quotient
    requires (.divisor != 0.0)
    : div( .dividend, .divisor, :.round_meth );

MD.Ratio.mod ::= function
    --> Ratio <-- (Ratio, Ratio, round_meth : Round_Meth)
    implements Numeric.mod
    requires (.1 != 0.0)
    : (.0 - (.1 * div(*topic)));

MD.Ratio.modulo ::= synonym of mod;

MD.Ratio.remainder ::= function
    --> Ratio <-- (dividend : Ratio, divisor : Ratio,
        round_meth : Round_Meth)
    implements Numeric.remainder
    requires (.divisor != 0.0)
    : mod( .dividend, .divisor, :.round_meth );

MD.Ratio.divide_and_modulo ::= function
    --> type of Tuple where has_attrs(topic,\%{ quotient : $Ratio,
        remainder : $Ratio })
    <-- (Ratio, Ratio, round_meth : Round_Meth)
    implements Numeric.divide_and_modulo
    requires (.1 != 0.0)
    : (\%{ quotient : div(*topic), remainder : mod(*topic) });

MD.Ratio.quot_and_rem ::= function
    --> type of Tuple where has_attrs(topic,\%{ quotient : $Ratio,
        remainder : $Ratio })
    <-- (dividend : Ratio, divisor : Ratio, round_meth : Round_Meth)
    implements Numeric.quot_and_rem
    requires (.divisor != 0.0)
    : quot_and_rem( .dividend, .divisor, :.round_meth );
