Muldis_D:Plain_Text:ASCII:"http://muldis.com":"0.200";

package_segment Muldis_D:"http://muldis.com":"0.200":Integral;

/*************************************************************************/

MD.Integral ::= type abstract composes Numeric and_provides_its_default;

MD.Integer ::= type of Universal where \*^[isa_Integer,topic] default 0 
    composes {Integral and_provides_its_default,
        Cardinal and_provides_its_default, Ordinal};

MD.Integer.Int ::= synonym of Integer;

MD.Integer.NN ::= type of Integer where topic >= 0;

MD.Integer.P ::= type of Integer.NN where topic > 0 default 1;

/*************************************************************************/

MD.Integer."<=>" ::= function --> Order <-- (Integer, Integer)
    implements Ordered."<=>"
: (
       .0 = .1                     ?? $=>Same
    !! \*^[Integer_in_order,.0,.1] ?? $=>Less
    !!                                $=>More
);

MD.Integer.order ::= synonym of "<=>";

/*************************************************************************/

MD.Integer."--" ::= function --> Integer <-- (Integer)
    implements Ordinal."--" : (.0 - 1);

MD.Integer.pred ::= synonym of "--";
MD.Integer.dec  ::= synonym of "--";

MD.Integer."++" ::= function --> Integer <-- (Integer)
    implements Ordinal."++" : (.0 + 1);

MD.Integer.succ ::= synonym of "++";
MD.Integer.inc  ::= synonym of "++";

/*************************************************************************/

MD.Integer.monadic."-" ::= function --> Integer <-- (Integer)
    implements Numeric.monadic."-"
    : \*^[Integer_opposite,.0];

MD.Integer.opposite         ::= synonym of monadic."-";
MD.Integer.additive_inverse ::= synonym of monadic."-";

MD.Integer.reciprocal ::= function --> Ratio <-- (Integer)
    implements Numeric.reciprocal
    requires (.0 != 0)
    : select_Ratio(1,.0);

MD.Integer.multiplicative_inverse ::= synonym of reciprocal;

MD.Integer.abs ::= function --> Integer.NN <-- (Integer)
    implements Numeric.abs
    : \*^[Integer_abs,.0];

MD.Integer.modulus ::= synonym of abs;

MD.Integer."+" ::= function --> Integer <-- (Integer, Integer)
    implements Numeric."+"
    is {commutative,associative} identity 0
    : \*^[Integer_plus,.0,.1];

MD.Integer.plus ::= synonym of "+";
MD.Integer.add  ::= synonym of "+";

MD.Integer.sum ::= function
    --> Integer <-- (augend : Integer, addend : Integer)
    implements Numeric.sum
    : .augend + .addend];

MD.Integer."-" ::= function --> Integer <-- (Integer, Integer)
    implements Numeric."-"
    : \*^[Integer_minus,.0,.1];

MD.Integer.minus    ::= synonym of "-";
MD.Integer.subtract ::= synonym of "-";

MD.Integer.diff ::= function
    --> Integer <-- (minuend : Integer, subtrahend : Integer)
    implements Numeric.diff
    : .minuend - .subtrahend;

MD.Integer.difference ::= synonym of diff;

MD.Integer."|-|" ::= function --> Integer.NN <-- (Integer, Integer)
    implements Numeric."|-|"
    is {commutative}
    : abs(.0 + -.1);

MD.Integer.abs_minus ::= synonym of "|-|";

MD.Integer.abs_diff ::= function
    --> Integer.NN <-- (minuend : Integer, subtrahend : Integer)
    implements Numeric."|-|"
    : .minuend |-| .subtrahend;

MD.Integer."*" ::= function --> Integer <-- (Integer, Integer)
    implements Numeric."*"
    is {commutative,associative} identity 1
    : \*^[Integer_times,.0,.1];

MD.Integer.times    ::= synonym of "*";
MD.Integer.multiply ::= synonym of "*";

MD.Integer.product ::= function
    --> Integer <-- (multiplicand : Integer, multiplier : Integer)
    implements Numeric.product
    : .multiplicand * .multiplier;

MD.Integer."/" ::= function --> Ratio <-- (Integer, Integer)
    implements Numeric."/"
    requires (.1 != 0)
    : select_Ratio(.0,.1);

MD.Integer.frac_divide ::= synonym of "/";

MD.Integer.frac_quotient ::= function
    --> Ratio <-- (dividend : Integer, divisor : Integer)
    implements Numeric."/"
    requires (.divisor != 0)
    : .dividend / .divisor;

MD.Integer.div ::= function
    --> Integer <-- (Integer, Integer, round_meth : Round_Meth)
    implements Numeric.div
    requires (.1 != 0)
: (
    /* We know we are dividing by a non-zero value. */

    if .0 = 0 then
        0
    else if .1 = 1 then
        .0
    else if .0 = .1 then
        1
    else if .1 = -1 then
        -.0
    else
      (
        /* We know the divisor and dividend do not equal each other and
           that neither of them is a zero or a one. */

        real_q_is_neg ::= (.0 < 0 xor .1 < 0);
        rtz_quotient ::= \*^[Integer_whole_divide_rtz,.0,.1];
        rtz_remainder ::= (.0 - (.1 * rtz_quotient));

        if rtz_remainder = 0 then
            rtz_quotient
        else
          (
            /* We know the divisor does not divide the dividend evently
               and the real number division result would have a fractional
               part, so now we decide how to round that. */

            rti_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 1);
            rdn_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 0);
            rup_quotient ::= rtz_quotient + (real_q_is_neg ??  0 !! 1);

            <-- given .round_meth
                when $=>Down then
                    rdn_quotient
                when $=>Up then
                    rup_quotient
                when $=>To_Zero then
                    rtz_quotient
                when $=>To_Inf then
                    rti_quotient
                default
                    if (2 * abs(rtz_remainder)) < abs(.1) then
                        rtz_quotient
                    else if (2 * abs(rtz_remainder)) > abs(.1) then
                        rti_quotient
                    else
                      (
                        /* The real division remainder is exactly one-half
                           so now we decide how to round that. */

                        given .round_meth
                            when $=>Half_Down then
                                rdn_quotient
                            when $=>Half_Up then
                                rup_quotient
                            when $=>Half_To_Zero then
                                rtz_quotient
                            when $=>Half_To_Inf then
                                rti_quotient
                            when $=>Half_Even
                              (
                                q ::= \*^[Integer_whole_divide_rtz,
                                    abs(rtz_quotient),2];
                                r ::= (abs(rtz_quotient) - (2 * q));
                                rtz_quotient_is_even ::= (r = 0);
                                <-- rtz_quotient_is_even
                                    ?? rtz_quotient !! rti_quotient;
                              )
                            default fail  /* oops, an unhandled case */
                        ;
                      )
            ;
          )
        ;
      )
);

MD.Integer.whole_divide ::= synonym of div;

MD.Integer.whole_quotient ::= function
    --> Integer <-- (dividend : Integer, divisor : Integer,
        round_meth : Round_Meth)
    implements Numeric.whole_quotient
    requires (.divisor != 0)
    : div( .dividend, .divisor, :.round_meth );

MD.Integer.mod ::= function
    --> Integer <-- (Integer, Integer, round_meth : Round_Meth)
    implements Numeric.mod
    requires (.1 != 0)
    : (.0 - (.1 * div(*topic)));

MD.Integer.modulo ::= synonym of mod;

MD.Integer.remainder ::= function
    --> Integer <-- (dividend : Integer, divisor : Integer,
        round_meth : Round_Meth)
    implements Numeric.remainder
    requires (.divisor != 0)
    : mod( .dividend, .divisor, :.round_meth );

MD.Integer.divide_and_modulo ::= function
    --> type of Tuple where has_attrs(topic,\%{ quotient : $Integer,
        remainder : $Integer })
    <-- (Integer, Integer, round_meth : Round_Meth)
    implements Numeric.divide_and_modulo
    requires (.1 != 0)
    : (\%{ quotient : div(*topic), remainder : mod(*topic) });

MD.Integer.quot_and_rem ::= function
    --> type of Tuple where has_attrs(topic,\%{ quotient : $Integer,
        remainder : $Integer })
    <-- (dividend : Integer, divisor : Integer, round_meth : Round_Meth)
    implements Numeric.quot_and_rem
    requires (.divisor != 0)
    : quot_and_rem( .dividend, .divisor, :.round_meth );

/*************************************************************************/

MD.Integer.power ::= function --> Integer <-- (Integer, Integer)
    implements Numeric.power
    requires (.1 >= 0)
    : \*^[Integer_power,.0,.1];

MD.Integer.exp ::= synonym of power;

MD.Integer.exponentiate ::= function
    --> Integer <-- (radix : Integer, exponent : Integer)
    implements Numeric.exponentiate
    requires (.exponent >= 0)
    : .radix exp .exponent;

MD.Integer.factorial ::= function --> Integer.P <-- (Integer.P)
    : \*^[Integer_factorial,.0,.1];

/*************************************************************************/

/* TODO: Consider defining these for negative integers too. */

/* Calculate using the Euclidean algorithm. */

MD.Integer.gcd ::= function --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent} identity 0
    : (.0 = .1 ?? .0 !! .1 = 0 ?? .0
        !! 0( .1, mod( .0, .1, round_meth : $=>To_Zero ) ));

MD.Integer.greatest_common_divisor ::= synonym of gcd;

MD.Integer.lcm ::= function --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent}
    : (.0 = .1 ?? .0 !! .0 = 0 and .1 = 0 ?? 0
        !! div( .0 * .1, gcd(.0,.1), round_meth : $=>To_Zero ));

MD.Integer.least_common_multiple ::= synonym of lcm;
