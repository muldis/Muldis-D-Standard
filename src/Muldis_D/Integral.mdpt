Muldis_D:Plain_Text:ASCII:"http://muldis.com":"0.200";

package_segment Muldis_D:"http://muldis.com":"0.200":Integral;

/*************************************************************************/

MD.Integral ::= abstract_type composes Numeric;

MD.Integer ::= type of Universal where \*^[isa_Integer,topic] default 0 
    composes Integral composes Cardinal composes Ordinal;

MD.Integer.Int ::= synonym of Integer;

MD.Integer.NN ::= type of Integer where topic >= 0;

MD.Integer.P ::= type of Integer.NN where topic > 0 default 1;

/*************************************************************************/

MD.Integer."<=>" ::= function
    --> Order <-- (0|lhs : Integer, 1|rhs : Integer)
    implements Ordered."<=>"
: (
       .0 = .1                     ?? $=>Same
    !! \*^[Integer_in_order,.0,.1] ?? $=>Less
    !!                                $=>More
);

MD.Integer.order ::= synonym of "<=>";

/*************************************************************************/

MD.Integer."--" ::= function --> Integer <-- (Integer)
    implements Ordinal."--" : (.0 - 1);

MD.Integer.pred ::= synonym of "--";
MD.Integer.dec  ::= synonym of "--";

MD.Integer."++" ::= function --> Integer <-- (Integer)
    implements Ordinal."++" : (.0 + 1);

MD.Integer.succ ::= synonym of "++";
MD.Integer.inc  ::= synonym of "++";

/*************************************************************************/

MD.Integer.monadic."-" ::= function
    --> Integer <-- (Integer) implements Numeric.monadic."-"
    : \*^[Integer_opposite,.0];

MD.Integer.opposite         ::= synonym of monadic."-";
MD.Integer.additive_inverse ::= synonym of monadic."-";

MD.Integer.reciprocal ::= function
    --> Ratio <-- (Integer) requires (.0 != 0) implements Numeric.reciprocal
    : select_Ratio(1,.0);

MD.Integer.multiplicative_inverse ::= synonym of reciprocal;

MD.Integer.abs ::= function --> Integer.NN <-- (Integer)
    implements Numeric.abs
    : \*^[Integer_abs,.0];

MD.Integer.modulus ::= synonym of abs;

MD.Integer."+" ::= function
    --> Integer <-- (0|augend : Integer, 1|addend : Integer)
    implements Numeric."+" is {commutative,associative} identity 0
    : \*^[Integer_plus,.0,.1];

MD.Integer.plus ::= synonym of "+";
MD.Integer.add  ::= synonym of "+";
MD.Integer.sum  ::= synonym of "+";

MD.Integer."-" ::= function
    --> Integer <-- (0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."-" : \*^[Integer_minus,.0,.1];

MD.Integer.minus      ::= synonym of "-";
MD.Integer.subtract   ::= synonym of "-";
MD.Integer.diff       ::= synonym of "-";
MD.Integer.difference ::= synonym of "-";

MD.Integer."|-|" ::= function
    --> Integer.NN <-- (0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."|-|" : abs(.0 + -.1);

MD.Integer.abs_diff  ::= synonym of "|-|";
MD.Integer.abs_minus ::= synonym of "|-|";

MD.Integer."*" ::= function
    --> Integer <-- (0|multiplicand : Integer, 1|multiplier : Integer)
    implements Numeric."*" is {commutative,associative} identity 1
    : \*^[Integer_times,.0,.1];

MD.Integer.times    ::= synonym of "*";
MD.Integer.multiply ::= synonym of "*";
MD.Integer.product  ::= synonym of "*";

MD.Integer."/" ::= function
    --> Ratio <-- (0|dividend : Integer, 1|divisor : Integer)
    requires (.1 != 0)
    implements Numeric."/"
    : select_Ratio(.0,.1);

MD.Integer.frac_divide   ::= synonym of "/";
MD.Integer.frac_quotient ::= synonym of "/";

MD.Integer.div ::= function
    --> Integer <-- (0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.div
: (
    /* We know we are dividing by a non-zero value. */

    if .0 = 0 then
        0
    else if .1 = 1 then
        .0
    else if .0 = .1 then
        1
    else if .1 = -1 then
        -.0
    else
      (
        /* We know the divisor and dividend do not equal each other and
           that neither of them is a zero or a one. */

        real_q_is_neg ::= (.0 < 0 xor .1 < 0);
        rtz_quotient ::= \*^[Integer_whole_divide_rtz,.0,.1];
        rtz_remainder ::= (.0 - (.1 * rtz_quotient));

        if rtz_remainder = 0 then
            rtz_quotient
        else
          (
            /* We know the divisor does not divide the dividend evently
               and the real number division result would have a fractional
               part, so now we decide how to round that. */

            rti_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 1);
            rdn_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 0);
            rup_quotient ::= rtz_quotient + (real_q_is_neg ??  0 !! 1);

            <-- given .round_meth
                when $=>Down then
                    rdn_quotient
                when $=>Up then
                    rup_quotient
                when $=>To_Zero then
                    rtz_quotient
                when $=>To_Inf then
                    rti_quotient
                default
                    if (2 * abs(rtz_remainder)) < abs(.1) then
                        rtz_quotient
                    else if (2 * abs(rtz_remainder)) > abs(.1) then
                        rti_quotient
                    else
                      (
                        /* The real division remainder is exactly one-half
                           so now we decide how to round that. */

                        given .round_meth
                            when $=>Half_Down then
                                rdn_quotient
                            when $=>Half_Up then
                                rup_quotient
                            when $=>Half_To_Zero then
                                rtz_quotient
                            when $=>Half_To_Inf then
                                rti_quotient
                            when $=>Half_Even
                              (
                                q ::= \*^[Integer_whole_divide_rtz,
                                    abs(rtz_quotient),2];
                                r ::= (abs(rtz_quotient) - (2 * q));
                                rtz_quotient_is_even ::= (r = 0);
                                <-- rtz_quotient_is_even
                                    ?? rtz_quotient !! rti_quotient;
                              )
                            default fail  /* oops, an unhandled case */
                        ;
                      )
            ;
          )
        ;
      )
);

MD.Integer.whole_divide   ::= synonym of div;
MD.Integer.whole_quotient ::= synonym of div;

MD.Integer.mod ::= function
    --> Integer <-- (0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.mod
    : (.0 - (.1 * div(*topic)));

MD.Integer.modulo    ::= synonym of mod;
MD.Integer.remainder ::= synonym of mod;

MD.Integer.divide_and_modulo ::= function
    --> type of Tuple where (has_attrs(topic,\%{ quotient : $Integer,
        remainder : $Integer })) <--
        (0|dividend : Integer, 1|divisor : Integer, round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.divide_and_modulo
    : (\%{ quotient : div(*topic), remainder : mod(*topic) });

MD.Integer.quot_and_rem ::= synonym of divide_and_modulo;

/*************************************************************************/

MD.Integer.power ::= function
    --> Integer <-- (0|base|radix : Integer, 1|exponent : Integer)
    requires (.1 >= 0)
    implements Numeric.power : \*^[Integer_power,.0,.1];

MD.Integer.exp          ::= synonym of power;
MD.Integer.exponentiate ::= synonym of power;

MD.Integer.factorial ::= function --> Integer.P <-- (Integer.P)
    : \*^[Integer_factorial,.0,.1];

/*************************************************************************/

/* TODO: Consider defining these for negative integers too. */

/* Calculate using the Euclidean algorithm. */

MD.Integer.gcd ::= function
    --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent} identity 0
    : (.0 = .1 ?? .0 !! .1 = 0 ?? .0
        !! 0( .1, mod( .0, .1, round_meth : $=>To_Zero ) ));

MD.Integer.greatest_common_divisor ::= synonym of gcd;

MD.Integer.lcm ::= function
    --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent}
    : (.0 = .1 ?? .0 !! .0 = 0 and .1 = 0 ?? 0
        !! div( .0 * .1, gcd(.0,.1), round_meth : $=>To_Zero ));

MD.Integer.least_common_multiple ::= synonym of lcm;
