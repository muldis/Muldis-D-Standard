Muldis_D:Plain_Text:ASCII:"http://muldis.com":"0.200";

package_segment Muldis_D:"http://muldis.com":"0.200":Integral;

/*************************************************************************/

MD.Integral ::= abstract_type composes Numeric;

MD.Integer ::= type of Universal where \*^[isa_Integer,topic] default 0 
    composes Integral composes Cardinal composes Ordinal;

MD.Integer.Int ::= synonym of Integer;

MD.Integer.NN ::= type of Integer where topic >= 0;

MD.Integer.P ::= type of Integer.NN where topic > 0 default 1;

/*************************************************************************/

MD.Integer."<=>"|order ::= function
    --> Order <-- (0|lhs : Integer, 1|rhs : Integer)
    implements Ordered."<=>"
: (
       .0 = .1                     ?? $=>Same
    !! \*^[Integer_in_order,.0,.1] ?? $=>Less
    !!                                $=>More
);

/*************************************************************************/

MD.Integer."--"|pred|dec ::= function --> Integer <-- (Integer)
    implements Ordinal."--" : (.0 - 1);

MD.Integer."++"|succ|inc ::= function --> Integer <-- (Integer)
    implements Ordinal."++" : (.0 + 1);

/*************************************************************************/

MD.Integer.monadic."-"|opposite|additive_inverse ::= function
    --> Integer <-- (Integer) implements Numeric.monadic."-"
    : \*^[Integer_opposite,.0];

MD.Integer.reciprocal|multiplicative_inverse ::= function
    --> Ratio <-- (Integer) requires (.0 != 0) implements Numeric.reciprocal
    : select_Ratio(1,.0);

MD.Integer.abs|modulus ::= function --> Integer.NN <-- (Integer)
    implements Numeric.abs
    : \*^[Integer_abs,.0];

MD.Integer."+"|plus|add|sum ::= function
    --> Integer <-- (0|augend : Integer, 1|addend : Integer)
    implements Numeric."+" is {commutative,associative} identity 0
    : \*^[Integer_plus,.0,.1];

MD.Integer."-"|minus|subtract|diff|difference ::= function
    --> Integer <-- (0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."-" : \*^[Integer_minus,.0,.1];

MD.Integer."|-|"|abs_minus|abs_diff ::= function
    --> Integer.NN <-- (0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."|-|" : abs(.0 + -.1);

MD.Integer."*"|times|multiply|product ::= function
    --> Integer <-- (0|multiplicand : Integer, 1|multiplier : Integer)
    implements Numeric."*" is {commutative,associative} identity 1
    : \*^[Integer_times,.0,.1];

MD.Integer."/"|frac_divide|frac_quotient ::= function
    --> Ratio <-- (0|dividend : Integer, 1|divisor : Integer)
    requires (.1 != 0)
    implements Numeric."/"
    : select_Ratio(.0,.1);

MD.Integer.div|whole_divide|whole_quotient ::= function
    --> Integer <-- (0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.div
: (
    /* We know we are dividing by a non-zero value. */

    if .0 = 0 then
        0
    else if .1 = 1 then
        .0
    else if .0 = .1 then
        1
    else if .1 = -1 then
        -.0
    else
      (
        /* We know the divisor and dividend do not equal each other and
           that neither of them is a zero or a one. */

        real_q_is_neg ::= (.0 < 0 xor .1 < 0);
        rtz_quotient ::= \*^[Integer_whole_divide_rtz,.0,.1];
        rtz_remainder ::= (.0 - (.1 * rtz_quotient));

        if rtz_remainder = 0 then
            rtz_quotient
        else
          (
            /* We know the divisor does not divide the dividend evently
               and the real number division result would have a fractional
               part, so now we decide how to round that. */

            rti_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 1);
            rdn_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 0);
            rup_quotient ::= rtz_quotient + (real_q_is_neg ??  0 !! 1);

            <-- given .round_meth
                when $=>Down then
                    rdn_quotient
                when $=>Up then
                    rup_quotient
                when $=>To_Zero then
                    rtz_quotient
                when $=>To_Inf then
                    rti_quotient
                default
                    if (2 * abs(rtz_remainder)) < abs(.1) then
                        rtz_quotient
                    else if (2 * abs(rtz_remainder)) > abs(.1) then
                        rti_quotient
                    else
                      (
                        /* The real division remainder is exactly one-half
                           so now we decide how to round that. */

                        given .round_meth
                            when $=>Half_Down then
                                rdn_quotient
                            when $=>Half_Up then
                                rup_quotient
                            when $=>Half_To_Zero then
                                rtz_quotient
                            when $=>Half_To_Inf then
                                rti_quotient
                            when $=>Half_Even
                              (
                                q ::= \*^[Integer_whole_divide_rtz,
                                    abs(rtz_quotient),2];
                                r ::= (abs(rtz_quotient) - (2 * q));
                                rtz_quotient_is_even ::= (r = 0);
                                <-- rtz_quotient_is_even
                                    ?? rtz_quotient !! rti_quotient;
                              )
                            default fail  /* oops, an unhandled case */
                        ;
                      )
            ;
          )
        ;
      )
);

MD.Integer.mod|modulo|remainder ::= function
    --> Integer <-- (0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.mod : (.0 - (.1 * div(*topic)));

MD.Integer.divide_and_modulo|quot_and_rem ::= function
    --> type of Tuple where (has_attrs(topic,\%{ quotient : $Integer,
        remainder : $Integer })) <--
        (0|dividend : Integer, 1|divisor : Integer, round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.divide_and_modulo
    : (\%{ quotient : div(*topic), remainder : mod(*topic) });

/*************************************************************************/

MD.Integer.power|exp|exponentiate ::= function
    --> Integer <-- (0|base|radix : Integer, 1|exponent : Integer)
    requires (.1 >= 0)
    implements Numeric.power : \*^[Integer_power,.0,.1];

MD.Integer.factorial ::= function --> Integer.P <-- (Integer.P)
    : \*^[Integer_factorial,.0,.1];

/*************************************************************************/

/* TODO: Consider defining these for negative integers too. */

/* Calculate using the Euclidean algorithm. */

MD.Integer.gcd|greatest_common_divisor ::= function
    --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent} identity 0
    : (.0 = .1 ?? .0 !! .1 = 0 ?? .0
        !! 0( .1, mod( .0, .1, round_meth : $=>To_Zero ) ));

MD.Integer.lcm|least_common_multiple ::= function
    --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent}
    : (.0 = .1 ?? .0 !! .0 = 0 and .1 = 0 ?? 0
        !! div( .0 * .1, gcd(.0,.1), round_meth : $=>To_Zero ));
