Muldis_D:Plain_Text:"http://muldis.com":"0.200";

script ASCII;

package_segment Muldis_D:"http://muldis.com":"0.200":Integral;

`#########################################################################`

MD.Integral ::= type abstract composes Numeric and_provides_its_default;

MD.Integer."" ::= type of Universal where \*^[isa_Integer,topic] default 0 
    composes {Integral and_provides_its_default,
        Cardinal and_provides_its_default, Ordinal};

MD.Integer.Int ::= synonym of Integer;

MD.Integer.NN ::= type of Integer where topic >= 0;

MD.Integer.P ::= type of Integer.NN where topic > 0 default 1;

`#########################################################################`

MD.Integer."<=>" ::= function --> Order <-- (Integer, Integer)
    implements Ordered."<=>"
: (
       .0 = .1                     ?? $=>Same
    !! \*^[Integer_in_order,.0,.1] ?? $=>Less
    !!                                $=>More
);

MD.Integer.order ::= synonym of "<=>";

`#########################################################################`

MD.Integer."--" ::= function --> Integer <-- (Integer)
    implements Ordinal."--" : (.0 - 1);

MD.Integer.pred ::= synonym of "--";
MD.Integer.dec  ::= synonym of "--";

MD.Integer."++" ::= function --> Integer <-- (Integer)
    implements Ordinal."++" : (.0 + 1);

MD.Integer.succ ::= synonym of "++";
MD.Integer.inc  ::= synonym of "++";

`#########################################################################`

MD.Integer.monadic."-" ::= function --> Integer <-- (Integer)
    implements Numeric.monadic."-"
    : \*^[Integer_opposite,.0];

MD.Integer.opposite         ::= synonym of monadic."-";
MD.Integer.additive_inverse ::= synonym of monadic."-";

MD.Integer.reciprocal ::= function --> Ratio <-- (Integer)
    implements Numeric.reciprocal
    requires (.0 != 0)
    : select_Ratio(1,.0);

MD.Integer.multiplicative_inverse ::= synonym of reciprocal;

MD.Integer.abs ::= function --> Integer.NN <-- (Integer)
    implements Numeric.abs
    : \*^[Integer_abs,.0];

MD.Integer.modulus ::= synonym of abs;

MD.Integer."+" ::= function --> Integer <-- (Integer, Integer)
    implements Numeric."+"
    is {commutative,associative} identity 0
    : \*^[Integer_plus,.0,.1];

MD.Integer.plus ::= synonym of "+";
MD.Integer.add  ::= synonym of "+";

MD.Integer.sum ::= function
    --> Integer <-- (augend : Integer, addend : Integer)
    implements Numeric.sum
    : .augend + .addend];

MD.Integer."-" ::= function --> Integer <-- (Integer, Integer)
    implements Numeric."-"
    : \*^[Integer_minus,.0,.1];

MD.Integer.minus    ::= synonym of "-";
MD.Integer.subtract ::= synonym of "-";

MD.Integer.diff ::= function
    --> Integer <-- (minuend : Integer, subtrahend : Integer)
    implements Numeric.diff
    : .minuend - .subtrahend;

MD.Integer.difference ::= synonym of diff;

MD.Integer."|-|" ::= function --> Integer.NN <-- (Integer, Integer)
    implements Numeric."|-|"
    is {commutative}
    : abs(.0 + -.1);

MD.Integer.abs_minus ::= synonym of "|-|";

MD.Integer.abs_diff ::= function
    --> Integer.NN <-- (minuend : Integer, subtrahend : Integer)
    implements Numeric."|-|"
    : .minuend |-| .subtrahend;

MD.Integer."*" ::= function --> Integer <-- (Integer, Integer)
    implements Numeric."*"
    is {commutative,associative} identity 1
    : \*^[Integer_times,.0,.1];

MD.Integer.times    ::= synonym of "*";
MD.Integer.multiply ::= synonym of "*";

MD.Integer.product ::= function
    --> Integer <-- (multiplicand : Integer, multiplier : Integer)
    implements Numeric.product
    : .multiplicand * .multiplier;

MD.Integer."/" ::= function --> Ratio <-- (Integer, Integer)
    implements Numeric."/"
    requires (.1 != 0)
    : select_Ratio(.0,.1);

MD.Integer.frac_divide ::= synonym of "/";

MD.Integer.frac_quotient ::= function
    --> Ratio <-- (dividend : Integer, divisor : Integer)
    implements Numeric."/"
    requires (.divisor != 0)
    : .dividend / .divisor;

MD.Integer.div ::= function
    --> Integer <-- (Integer, Integer, round_meth : Round_Meth)
    implements Numeric.div
    requires (.1 != 0)
    : whole_quotient( dividend : .0, divisor : .1, :.round_meth );

MD.Integer.whole_divide ::= synonym of div;

MD.Integer.whole_quotient ::= function
    --> Integer <-- (dividend : Integer, divisor : Integer,
        round_meth : Round_Meth)
    implements Numeric.whole_quotient
    requires (.divisor != 0)
: (
    `We know we are dividing by a non-zero value.`

       .dividend = 0        ?? 0
    !! .divisor  = 1        ?? .dividend
    !! .dividend = .divisor ?? 1
    !! .divisor  = -1       ?? -.dividend
    !!
      (
        `This is the case where the divisor and dividend do not equal
           each other and neither of them is a zero or a one.`

        real_q_is_neg ::= (.dividend < 0 xor .divisor < 0);
        rtz_quotient  ::= \*^[Integer_whole_divide_rtz,.dividend,.divisor];
        rtz_remainder ::= (.dividend - (.divisor * rtz_quotient));

        <-- rtz_remainder = 0 ?? rtz_quotient
         !!
          (
            `This is the case where the divisor does not divide the
               dividend evently and the real number division result would
               have a fractional part, so we decide how to round that.`

            rti_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 1));
            rdn_quotient ::= (rtz_quotient + (real_q_is_neg ?? -1 !! 0));
            rup_quotient ::= (rtz_quotient + (real_q_is_neg ??  0 !! 1));

            <-- .round_meth ??? {
                $=>Down    : rdn_quotient,
                $=>Up      : rup_quotient,
                $=>To_Zero : rtz_quotient,
                $=>To_Inf  : rti_quotient,
            } !!!
                   (2 * abs(rtz_remainder)) < abs(.divisor) ?? rtz_quotient
                !! (2 * abs(rtz_remainder)) > abs(.divisor) ?? rti_quotient
                !!
                  (
                    `This is the case where real division remainder is
                       exactly one-half so we decide how to round that.`

                    .round_meth ??? {
                        $=>Half_Down    : rdn_quotient,
                        $=>Half_Up      : rup_quotient,
                        $=>Half_To_Zero : rtz_quotient,
                        $=>Half_To_Inf  : rti_quotient,
                        $=>Half_Even    :
                          (
                            q ::= \*^[Integer_whole_divide_rtz,
                                abs(rtz_quotient),2];
                            r ::= (abs(rtz_quotient) - (2 * q));
                            rtz_quotient_is_even ::= (r = 0);
                            <-- rtz_quotient_is_even ?? rtz_quotient
                             !! rti_quotient;
                          ),
                    } !!! fail  `oops, an unhandled case`
                  )
            ;
          )
        ;
      )
);

MD.Integer.mod ::= function
    --> Integer <-- (Integer, Integer, round_meth : Round_Meth)
    implements Numeric.mod
    requires (.1 != 0)
    : (.0 - (.1 * div(*topic)));

MD.Integer.modulo ::= synonym of mod;

MD.Integer.remainder ::= function
    --> Integer <-- (dividend : Integer, divisor : Integer,
        round_meth : Round_Meth)
    implements Numeric.remainder
    requires (.divisor != 0)
    : mod( .dividend, .divisor, :.round_meth );

MD.Integer.divide_and_modulo ::= function
    --> type of Tuple where has_attrs(topic,\%{ quotient : $Integer,
        remainder : $Integer })
    <-- (Integer, Integer, round_meth : Round_Meth)
    implements Numeric.divide_and_modulo
    requires (.1 != 0)
    : (\%{ quotient : div(*topic), remainder : mod(*topic) });

MD.Integer.quot_and_rem ::= function
    --> type of Tuple where has_attrs(topic,\%{ quotient : $Integer,
        remainder : $Integer })
    <-- (dividend : Integer, divisor : Integer, round_meth : Round_Meth)
    implements Numeric.quot_and_rem
    requires (.divisor != 0)
    : quot_and_rem( .dividend, .divisor, :.round_meth );

`#########################################################################`

MD.Integer.power ::= function --> Integer <-- (Integer, Integer)
    implements Numeric.power
    requires (.1 >= 0)
    : \*^[Integer_power,.0,.1];

MD.Integer.exp ::= synonym of power;

MD.Integer.exponentiate ::= function
    --> Integer <-- (radix : Integer, exponent : Integer)
    implements Numeric.exponentiate
    requires (.exponent >= 0)
    : .radix exp .exponent;

MD.Integer.factorial ::= function --> Integer.P <-- (Integer.P)
    : \*^[Integer_factorial,.0,.1];

`#########################################################################`

`TODO: Consider defining these for negative integers too.`

`Calculate using the Euclidean algorithm.`

MD.Integer.gcd ::= function --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent} identity 0
    : if .1=0 then .0 else 0( .1, mod( .0, .1, round_meth : $=>To_Zero ) );

MD.Integer.greatest_common_divisor ::= synonym of gcd;

MD.Integer.lcm ::= function --> Integer.NN <-- (Integer.NN, Integer.NN)
    is {commutative,associative,idempotent}
    : (if .0 = 0 or .1 = 0 then 0
        else div( .0 * .1, gcd(.0,.1), round_meth : $=>To_Zero ));

MD.Integer.least_common_multiple ::= synonym of lcm;
