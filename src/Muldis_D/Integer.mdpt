Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package_segment Muldis_D:"http://muldis.com":0:Integer;

/*************************************************************************/

Muldis_D.Integral ::= abstract_type composes Numeric;

Muldis_D.Integer ::= LL_Integer
    composes Integral composes Cardinal composes Ordinal;

Muldis_D.Integer.Int ::= Integer;

Muldis_D.Integer.NN ::= Integer where (!LL_is_neg(.0));

Muldis_D.Integer.P ::= Integer.NN where (.0 != 0);

/*************************************************************************/

Muldis_D.Integer."<=>"|order ::= function
    (Order <-- 0|lhs : Integer, 1|rhs : Integer)
    implements Ordered."<=>"
: (
       .0 = .1                           ?? :$Order.Same
    !! LL_is_neg(.0)  and !LL_is_neg(.1) ?? :$Order.Less
    !! !LL_is_neg(.0) and LL_is_neg(.1)  ?? :$Order.More
    !! LL_is_neg(.0)  and LL_is_neg(.1)
        ?? (LL_in_order(LL_magnitude(.0),LL_magnitude(.1))
            ?? :$Order.More !! :$Order.Less)
    !! (LL_in_order(LL_magnitude(.0),LL_magnitude(.1))
            ?? :$Order.Less !! :$Order.More)
);

/*************************************************************************/

Muldis_D.Integer."--"|pred|dec ::= function (Integer <-- 0 : Integer)
    implements Ordinal."--" : (.0 - 1);

Muldis_D.Integer."++"|succ|inc ::= function (Integer <-- 0 : Integer)
    implements Ordinal."++" : (.0 + 1);

/*************************************************************************/

Muldis_D.Integer.monadic."-"|opposite|additive_inverse ::= function
    (Integer <-- 0 : Integer) implements Numeric.monadic."-"
    : (.0 = 0 ?? .0 !! LL_integer(!LL_is_neg(.0),LL_magnitude(.0)));

Muldis_D.Integer.abs|modulus ::= function (Integer.NN <-- 0 : Integer)
    implements Numeric.abs
    : (LL_is_neg(.0) ?? LL_integer(true,LL_magnitude(.0)) !! .0);

Muldis_D.Integer."+"|plus|add|sum ::= function
    (Integer <-- 0|augend : Integer, 1|addend : Integer)
    implements Numeric."+" is_commutative is_associative identity 0
: (
    s0 ::= LL_is_neg(.0);
    m0 ::= LL_magnitude(.0);
    s1 ::= LL_is_neg(.1);
    m1 ::= LL_magnitude(.1);
    <-- .0 = 0             ?? .1
     !! .1 = 0             ?? .0
     !! s0 = s1            ?? LL_integer(s0,LL_plus(m0,m1))
     !! m0 = m1            ?? 0
     !! LL_in_order(m0,m1) ?? LL_integer(s1,LL_minus(m1,m0))
     !!                       LL_integer(s0,LL_minus(m0,m1))
     ;
);

Muldis_D.Integer."-"|minus|subtract|diff|difference ::= function
    (Integer <-- 0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."-" : (.0 + -.1);

Muldis_D.Integer."|-|"|abs_minus|abs_diff ::= function
    (Integer.NN <-- 0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."|-|" : (abs(.0 + -.1));

Muldis_D.Integer."*"|times|multiply|product ::= function
    (Integer <-- 0|multiplicand : Integer, 1|multiplier : Integer)
    implements Numeric."*" is_commutative is_associative identity 1
    : (.0 = 1 ?? .1 !! .1 = 1 ?? .0 !! .0 = 0 or .1 = 0 ?? 0
        !! LL_integer( LL_is_neg(.0) xor LL_is_neg(.1),
        LL_times(LL_magnitude(.0),LL_magnitude(.1)) ));

Muldis_D.Integer."/"|frac_divide|frac_quotient ::= function
    (Ratio <-- 0|dividend : Integer, 1|divisor : Integer)
    requires (.1 != 0)
    implements Numeric."/" : (...);

Muldis_D.Integer.div|whole_divide|whole_quotient ::= function
    (Integer <-- 0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.div
: (
    if .1 = 1 then
        .0
    else if .0 = .1 then
        1
    else if .0 = 0 then
        0
    else
      (
        rtz_quotient ::= LL_integer( LL_is_neg(.0) xor LL_is_neg(.1),
            LL_divide(LL_magnitude(.0),LL_magnitude(.1)) );
        rtz_remainder ::= .0 - .1 * rtz_quotient;

        if rtz_remainder = 0 then
            rtz_quotient
        else
          (
            dbl_azq ::= 2 * abs(rtz_quotient);
            adsr ::= abs(.1);
            azq_eq_half_adsr ::= dbl_azq = adsr;
            azq_lt_half_adsr ::= dbl_azq < adsr;
            azq_gt_half_adsr ::= dbl_azq > adsr;

/* TODO: FINISH THIS ROUTINE DEFINITION! */

            <-- given round_meth
                when :$Down then
                    rtz_quotient + (rtz_quotient <= 0) ?? -1 !! 0
                when :$Up then
                    rtz_quotient + (rtz_quotient > 0) ?? 1 !! 0
                when :$To_Zero then
                    rtz_quotient
                when :$To_Inf then
                    rtz_quotient + 1
                when :$Half_Down
                when :$Half_Up
                when :$Half_To_Zero
                when :$Half_To_Inf
                when :$Half_Even
                default fail  /* oops, an unhandled case */
            ;
          )
        ;
      )
);

Muldis_D.Integer.mod|remainder|modulo ::= function
    (Integer <-- 0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.mod : (.0 - .1 * div(*_));

Muldis_D.Integer.quot_and_rem ::= function
    (Tuple where (has_attrs(.0,:%{ quotient : :*$Integer,
        remainder : :*$Integer })) <--
        0|dividend : Integer, 1|divisor : Integer, round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.quot_and_rem
    : (:%{ quotient : div(*_), remainder : mod(*_) });

/*************************************************************************/

Muldis_D.Integer.power|exp|exponentiate ::= function
    (Integer <-- 0|base|radix : Integer, 1|exponent : Integer)
    requires (!LL_is_neg(.1))
    implements Numeric.power : (...);

Muldis_D.Integer.factorial ::= function (Integer.P <-- 0 : Integer.P) :
    ([*] enumerated(1 .. .0));
