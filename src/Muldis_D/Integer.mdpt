Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package_segment Muldis_D:"http://muldis.com":0:Integer;

/*************************************************************************/

Muldis_D.Integral ::= abstract_type composes Numeric;

Muldis_D.Integer ::= LL_Integer
    composes Integral composes Cardinal composes Ordinal;

Muldis_D.Integer.Int ::= Integer;

Muldis_D.Integer.NN ::= type of Integer where (!LL_is_neg(.0));

Muldis_D.Integer.P ::= type of Integer.NN where (.0 != 0);

/*************************************************************************/

Muldis_D.Integer."<=>"|order ::= function
    (Order <-- 0|lhs : Integer, 1|rhs : Integer)
    implements Ordered."<=>"
: (
       .0 = .1                           ?? $=>Same
    !! LL_is_neg(.0)  and !LL_is_neg(.1) ?? $=>Less
    !! !LL_is_neg(.0) and LL_is_neg(.1)  ?? $=>More
    !! LL_is_neg(.0)  and LL_is_neg(.1)
        ?? (LL_in_order(LL_magnitude(.0),LL_magnitude(.1))
            ?? $=>More !! $=>Less)
    !! (LL_in_order(LL_magnitude(.0),LL_magnitude(.1))
            ?? $=>Less !! $=>More)
);

/*************************************************************************/

Muldis_D.Integer."--"|pred|dec ::= function (Integer <-- 0 : Integer)
    implements Ordinal."--" : (.0 - 1);

Muldis_D.Integer."++"|succ|inc ::= function (Integer <-- 0 : Integer)
    implements Ordinal."++" : (.0 + 1);

/*************************************************************************/

Muldis_D.Integer.monadic."-"|opposite|additive_inverse ::= function
    (Integer <-- 0 : Integer) implements Numeric.monadic."-"
    : (.0 = 0 ?? .0 !! LL_integer(!LL_is_neg(.0),LL_magnitude(.0)));

Muldis_D.Integer.abs|modulus ::= function (Integer.NN <-- 0 : Integer)
    implements Numeric.abs
    : (LL_is_neg(.0) ?? LL_integer(true,LL_magnitude(.0)) !! .0);

Muldis_D.Integer."+"|plus|add|sum ::= function
    (Integer <-- 0|augend : Integer, 1|addend : Integer)
    implements Numeric."+" is_commutative is_associative identity 0
: (
    s0 ::= LL_is_neg(.0);
    m0 ::= LL_magnitude(.0);
    s1 ::= LL_is_neg(.1);
    m1 ::= LL_magnitude(.1);
    <-- .0 = 0             ?? .1
     !! .1 = 0             ?? .0
     !! s0 = s1            ?? LL_integer(s0,LL_plus(m0,m1))
     !! m0 = m1            ?? 0
     !! LL_in_order(m0,m1) ?? LL_integer(s1,LL_minus(m1,m0))
     !!                       LL_integer(s0,LL_minus(m0,m1))
     ;
);

Muldis_D.Integer."-"|minus|subtract|diff|difference ::= function
    (Integer <-- 0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."-" : (.0 + -.1);

Muldis_D.Integer."|-|"|abs_minus|abs_diff ::= function
    (Integer.NN <-- 0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."|-|" : (abs(.0 + -.1));

Muldis_D.Integer."*"|times|multiply|product ::= function
    (Integer <-- 0|multiplicand : Integer, 1|multiplier : Integer)
    implements Numeric."*" is_commutative is_associative identity 1
    : (.0 = 1 ?? .1 !! .1 = 1 ?? .0 !! .0 = 0 or .1 = 0 ?? 0
        !! LL_integer( LL_is_neg(.0) xor LL_is_neg(.1),
        LL_times(LL_magnitude(.0),LL_magnitude(.1)) ));

Muldis_D.Integer."/"|frac_divide|frac_quotient ::= function
    (Ratio <-- 0|dividend : Integer, 1|divisor : Integer)
    requires (.1 != 0)
    implements Numeric."/" : ...;

Muldis_D.Integer.div|whole_divide|whole_quotient ::= function
    (Integer <-- 0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.div
: (
    /* We know we are dividing by a non-zero value. */

    if .1 = 1 then
        .0
    else if .0 = .1 then
        1
    else if .0 = 0 then
        0
    else
      (
        /* We know the divisor and dividend do not equal each other and
           that neither of them is a zero or a one. */

        real_q_is_neg ::= LL_is_neg(.0) xor LL_is_neg(.1);
        rtz_quotient ::= LL_integer( real_q_is_neg,
            LL_divide(LL_magnitude(.0),LL_magnitude(.1)) );
        rtz_remainder ::= .0 - .1 * rtz_quotient;

        if rtz_remainder = 0 then
            rtz_quotient
        else
          (
            /* We know the divisor does not divide the dividend evently
               and the real number division result would have a fractional
               part, so now we decide how to round that. */

            rti_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 1);
            rdn_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 0);
            rup_quotient ::= rtz_quotient + (real_q_is_neg ??  0 !! 1);

            <-- given .round_meth
                when $=>Down then
                    rdn_quotient
                when $=>Up then
                    rup_quotient
                when $=>To_Zero then
                    rtz_quotient
                when $=>To_Inf then
                    rti_quotient
                default
                    if (2 * abs(rtz_remainder)) < abs(.1) then
                        rtz_quotient
                    else if (2 * abs(rtz_remainder)) > abs(.1) then
                        rti_quotient
                    else
                      (
                        /* The real division remainder is exactly one-half
                           so now we decide how to round that. */

                        given .round_meth
                            when $=>Half_Down then
                                rdn_quotient
                            when $=>Half_Up then
                                rup_quotient
                            when $=>Half_To_Zero then
                                rtz_quotient
                            when $=>Half_To_Inf then
                                rti_quotient
                            when $=>Half_Even
                              (
                                q ::= LL_integer( false,
                                    LL_divide(LL_magnitude(rtz_quotient),
                                    LL_magnitude(2)) );
                                r ::= abs(rtz_quotient) - 2 * q;
                                rtz_quotient_is_even ::= r = 0;
                                <-- rtz_quotient_is_even
                                    ?? rtz_quotient !! rti_quotient;
                              )
                            default fail  /* oops, an unhandled case */
                        ;
                      )
            ;
          )
        ;
      )
);

Muldis_D.Integer.mod|remainder|modulo ::= function
    (Integer <-- 0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.mod : (.0 - .1 * div(*_));

Muldis_D.Integer.quot_and_rem ::= function
    (Tuple where (has_attrs(.0,\%{ quotient : $Integer,
        remainder : $Integer })) <--
        0|dividend : Integer, 1|divisor : Integer, round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.quot_and_rem
    : (\%{ quotient : div(*_), remainder : mod(*_) });

/*************************************************************************/

Muldis_D.Integer.power|exp|exponentiate ::= function
    (Integer <-- 0|base|radix : Integer, 1|exponent : Integer)
    requires (!LL_is_neg(.1))
    implements Numeric.power : ...;

Muldis_D.Integer.factorial ::= function (Integer.P <-- 0 : Integer.P)
    : ([*] enumerated(1 .. .0));
