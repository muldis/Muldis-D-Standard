Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package_segment Muldis_D:"http://muldis.com":0:Integer;

/*************************************************************************/

MD.Integral ::= abstract_type composes Numeric;

MD.Integer ::= synonym of ::MDLL.LL_Integer
    composes Integral composes Cardinal composes Ordinal;

MD.Integer.Int ::= synonym of Integer;

MD.Integer.NN ::= type of Integer where (!::MDLL.LL_is_neg(*topic));

MD.Integer.P ::= type of Integer.NN where (topic != 0);

/*************************************************************************/

MD.Integer."<=>"|order ::= function
    (Order <-- 0|lhs : Integer, 1|rhs : Integer)
    implements Ordered."<=>"
: (
       .0 = .1                           ?? $=>Same
    !! ::MDLL.LL_is_neg(*.0)  and !::MDLL.LL_is_neg(*.1) ?? $=>Less
    !! !::MDLL.LL_is_neg(*.0) and ::MDLL.LL_is_neg(*.1)  ?? $=>More
    !! ::MDLL.LL_is_neg(*.0)  and ::MDLL.LL_is_neg(*.1)
        ?? (::MDLL.LL_in_order(*\*:[::MDLL.LL_magnitude(*.0),::MDLL.LL_magnitude(*.1)])
            ?? $=>More !! $=>Less)
    !! (::MDLL.LL_in_order(*\*:[::MDLL.LL_magnitude(*.0),::MDLL.LL_magnitude(*.1)])
            ?? $=>Less !! $=>More)
);

/*************************************************************************/

MD.Integer."--"|pred|dec ::= function (Integer <-- Integer)
    implements Ordinal."--" : (.0 - 1);

MD.Integer."++"|succ|inc ::= function (Integer <-- Integer)
    implements Ordinal."++" : (.0 + 1);

/*************************************************************************/

MD.Integer.monadic."-"|opposite|additive_inverse ::= function
    (Integer <-- Integer) implements Numeric.monadic."-"
    : (.0 = 0 ?? .0 !! ::MDLL.LL_integer(*\*:[!::MDLL.LL_is_neg(*.0),::MDLL.LL_magnitude(*.0)]));

MD.Integer.abs|modulus ::= function (Integer.NN <-- Integer)
    implements Numeric.abs
    : (::MDLL.LL_is_neg(*.0) ?? ::MDLL.LL_integer(*\*:[true,::MDLL.LL_magnitude(*.0)]) !! .0);

MD.Integer."+"|plus|add|sum ::= function
    (Integer <-- 0|augend : Integer, 1|addend : Integer)
    implements Numeric."+" is_commutative is_associative identity 0
: (
    s0 ::= ::MDLL.LL_is_neg(*.0);
    m0 ::= ::MDLL.LL_magnitude(*.0);
    s1 ::= ::MDLL.LL_is_neg(*.1);
    m1 ::= ::MDLL.LL_magnitude(*.1);
    <-- .0 = 0             ?? .1
     !! .1 = 0             ?? .0
     !! s0 = s1            ?? ::MDLL.LL_integer(*\*:[s0,::MDLL.LL_plus(*m0,m1)])
     !! m0 = m1            ?? 0
     !! ::MDLL.LL_in_order(*\*:[m0,m1]) ?? ::MDLL.LL_integer(*\*:[s1,::MDLL.LL_minus(*\*:[m1,m0])])
     !!                       ::MDLL.LL_integer(*\*:[s0,::MDLL.LL_minus(*\*:[m0,m1])])
     ;
);

MD.Integer."-"|minus|subtract|diff|difference ::= function
    (Integer <-- 0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."-" : (.0 + -.1);

MD.Integer."|-|"|abs_minus|abs_diff ::= function
    (Integer.NN <-- 0|minuend : Integer, 1|subtrahend : Integer)
    implements Numeric."|-|" : (abs(.0 + -.1));

MD.Integer."*"|times|multiply|product ::= function
    (Integer <-- 0|multiplicand : Integer, 1|multiplier : Integer)
    implements Numeric."*" is_commutative is_associative identity 1
    : (.0 = 1 ?? .1 !! .1 = 1 ?? .0 !! .0 = 0 or .1 = 0 ?? 0
        !! ::MDLL.LL_integer(*\*:[ ::MDLL.LL_is_neg(*.0) xor ::MDLL.LL_is_neg(*.1),
        ::MDLL.LL_times(*\*:[::MDLL.LL_magnitude(*.0),::MDLL.LL_magnitude(*.1)]) ]));

MD.Integer."/"|frac_divide|frac_quotient ::= function
    (Ratio <-- 0|dividend : Integer, 1|divisor : Integer)
    requires (.1 != 0)
    implements Numeric."/" : ...;

MD.Integer.div|whole_divide|whole_quotient ::= function
    (Integer <-- 0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.div
: (
    /* We know we are dividing by a non-zero value. */

    if .1 = 1 then
        .0
    else if .0 = .1 then
        1
    else if .0 = 0 then
        0
    else
      (
        /* We know the divisor and dividend do not equal each other and
           that neither of them is a zero or a one. */

        real_q_is_neg ::= ::MDLL.LL_is_neg(*.0) xor ::MDLL.LL_is_neg(*.1);
        rtz_quotient ::= ::MDLL.LL_integer(*\*:[ real_q_is_neg,
            ::MDLL.LL_divide(*\*:[::MDLL.LL_magnitude(*.0),::MDLL.LL_magnitude(*.1)]) ]);
        rtz_remainder ::= .0 - .1 * rtz_quotient;

        if rtz_remainder = 0 then
            rtz_quotient
        else
          (
            /* We know the divisor does not divide the dividend evently
               and the real number division result would have a fractional
               part, so now we decide how to round that. */

            rti_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 1);
            rdn_quotient ::= rtz_quotient + (real_q_is_neg ?? -1 !! 0);
            rup_quotient ::= rtz_quotient + (real_q_is_neg ??  0 !! 1);

            <-- given .round_meth
                when $=>Down then
                    rdn_quotient
                when $=>Up then
                    rup_quotient
                when $=>To_Zero then
                    rtz_quotient
                when $=>To_Inf then
                    rti_quotient
                default
                    if (2 * abs(rtz_remainder)) < abs(.1) then
                        rtz_quotient
                    else if (2 * abs(rtz_remainder)) > abs(.1) then
                        rti_quotient
                    else
                      (
                        /* The real division remainder is exactly one-half
                           so now we decide how to round that. */

                        given .round_meth
                            when $=>Half_Down then
                                rdn_quotient
                            when $=>Half_Up then
                                rup_quotient
                            when $=>Half_To_Zero then
                                rtz_quotient
                            when $=>Half_To_Inf then
                                rti_quotient
                            when $=>Half_Even
                              (
                                q ::= ::MDLL.LL_integer(*\*:[ false,
                                    ::MDLL.LL_divide(*\*:[::MDLL.LL_magnitude(*rtz_quotient),
                                    ::MDLL.LL_magnitude(*2)]) ]);
                                r ::= abs(rtz_quotient) - 2 * q;
                                rtz_quotient_is_even ::= r = 0;
                                <-- rtz_quotient_is_even
                                    ?? rtz_quotient !! rti_quotient;
                              )
                            default fail  /* oops, an unhandled case */
                        ;
                      )
            ;
          )
        ;
      )
);

MD.Integer.mod|remainder|modulo ::= function
    (Integer <-- 0|dividend : Integer, 1|divisor : Integer,
        round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.mod : (.0 - .1 * div(*_));

MD.Integer.quot_and_rem ::= function
    (Tuple where (has_attrs(topic,\%{ quotient : $Integer,
        remainder : $Integer })) <--
        0|dividend : Integer, 1|divisor : Integer, round_meth : Round_Meth)
    requires (.1 != 0) implements Numeric.quot_and_rem
    : (\%{ quotient : div(*_), remainder : mod(*_) });

/*************************************************************************/

MD.Integer.power|exp|exponentiate ::= function
    (Integer <-- 0|base|radix : Integer, 1|exponent : Integer)
    requires (!::MDLL.LL_is_neg(*.1))
    implements Numeric.power : ...;

MD.Integer.factorial ::= function (Integer.P <-- Integer.P)
    : ([*] enumerated(1 .. .0));
