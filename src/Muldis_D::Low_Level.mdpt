Muldis_D:PT_STD:ASCII:"http://muldis.com":0;

package MDLL ::= Muldis_D::Low_Level:"http://muldis.com":0;

searching [MDLL];

/*************************************************************************/

/* A List is a generic ordered list of 0..N elements; but you don't
   access elements using numeric indexes but rather without any indexes.
   One can conceive of implementing the general case of an List either
   with an array or singly-linked list, where either is copy-on-write;
   all of the fundamental operators are abstract enough to work either way.
   This is exposed in the high level type system as Universal. */

MDLL.List ::= type of (isa \*^1[maximal_type])
    where TRUE() default EMPTY();

/*************************************************************************/

MDLL.EMPTY ::= constant \*^1[constant_EMPTY];

/* Note, prepend has 2 conceptual arguments, in order ["elem","to"]. */

MDLL.prepend ::= function --> List <-- List
    requires (
           empty(*topic)                           ?? FALSE()
        !! empty(*nonfirst(*topic))              ?? FALSE()
        !! empty(*nonfirst(*nonfirst(*topic))) ?? TRUE()
        !! FALSE()
    )
    : \*^1[function_prepend,first(*topic),first(*nonfirst(*topic))];

MDLL.empty ::= function --> Boolean <-- List
    : \*^1[function_empty,topic];

MDLL.first ::= function --> List <-- List
    requires (empty(*topic) ?? FALSE() !! TRUE()) : \*^1[function_first,topic];

MDLL.nonfirst ::= function --> List <-- List
    requires (empty(*topic) ?? FALSE() !! TRUE()) : \*^1[function_nonfirst,topic];

/*************************************************************************/

/* A Boolean is a list of exactly 0 (false) or 1 (true) elements, in the
   latter case whose sole element is the empty list.
   This is exposed in the high level type system as Boolean. */

MDLL.Boolean ::= type of List
    where (
           empty(*topic)              ?? TRUE()
        !! empty(*nonfirst(*topic)) ?? empty(*first(*topic))
        !! FALSE()
    )
    default FALSE();

MDLL.FALSE ::= synonym of EMPTY;

MDLL.TRUE ::= constant prepend(*\*:[EMPTY(),EMPTY()]);

/*************************************************************************/

MDLL.Pair ::= type of List
    where (
           empty(*topic)                           ?? FALSE()
        !! empty(*nonfirst(*topic))              ?? FALSE()
        !! empty(*nonfirst(*nonfirst(*topic))) ?? TRUE()
        !! FALSE()
    )
    default prepend(*\*:[EMPTY(),
        prepend(*\*:[EMPTY(),EMPTY()])]);

/*************************************************************************/

MDLL.same ::= function
    --> Boolean <-- Pair is_commutative
: (
    lhs ::= first(*topic);
    rhs ::= second(*topic);
    <-- empty(*lhs) ?? empty(*rhs)
     !! empty(*rhs) ?? FALSE()
     !! self(*\*:[first(*lhs),first(*rhs)])
        ?? self(*\*:[nonfirst(*lhs),nonfirst(*rhs)])
     !! FALSE()
);

MDLL.in_order ::= function
    --> Boolean <-- Pair
: (
    lhs ::= first(*topic);
    rhs ::= second(*topic);
    <-- empty(*lhs) ?? TRUE()
     !! empty(*rhs) ?? FALSE()
     !! same(*\*:[first(*lhs),first(*rhs)])
        ?? self(*\*:[nonfirst(*lhs),nonfirst(*rhs)])
     !! self(*\*:[first(*lhs),first(*rhs)])
);

MDLL.elems_in_order ::= function
    --> Boolean <-- List
: (
       empty(*topic)                            ?? TRUE()
    !! empty(*nonfirst(*topic))               ?? TRUE()
    !! in_order(*\*:[first(*topic),second(*topic)]) ?? self(*nonfirst(*topic))
    !! FALSE()
);

MDLL.second ::= function --> List <-- List
    requires (empty(*topic) ?? FALSE() !! TRUE())
    : first(*nonfirst(*topic));

MDLL.last ::= function --> List <-- List
    requires (empty(*topic) ?? FALSE() !! TRUE())
    : (empty(*nonfirst(*topic)) ?? first(*topic) !! self(*nonfirst(*topic)));

MDLL.nonlast ::= function --> List <-- List
    requires (empty(*topic) ?? FALSE() !! TRUE())
    : (empty(*nonfirst(*topic)) ?? EMPTY()
        !! prepend(*\*:[first(*topic),self(*nonfirst(*topic))]));

MDLL.catenate ::= function
    --> List <-- Pair
: (
    lhs ::= first(*topic);
    rhs ::= second(*topic);
    <-- empty(*lhs) ?? rhs !! empty(*rhs) ?? lhs
        !! self(*\*:[nonlast(*lhs),prepend(*\*:[last(*lhs),rhs])]);
);

/*************************************************************************/

/* A Natural is a list of 0..N elements where each element is an empty
   list; the numeric value (0..N) is equal to the count of elements.
   This is not exposed in the high-level type system at all. */

MDLL.Natural ::= type of List
    where (empty(*topic) ?? TRUE()
        !! empty(*first(*topic)) ?? self(*nonfirst(*topic)) !! FALSE());

MDLL.ZERO ::= synonym of EMPTY;

MDLL.zero ::= synonym of empty;

MDLL.pred ::= function --> Natural <-- Natural
    requires (zero(*topic) ?? FALSE() !! TRUE()) : nonfirst(*topic);

MDLL.succ ::= function --> Natural <-- Natural
    : prepend(*\*:[EMPTY(),topic]);

MDLL.1 ::= constant succ(*ZERO());
MDLL.2 ::= constant succ(*1());
MDLL.3 ::= constant succ(*2());
MDLL.4 ::= constant succ(*3());
MDLL.5 ::= constant succ(*4());
MDLL.6 ::= constant succ(*5());
MDLL.7 ::= constant succ(*6());
MDLL.8 ::= constant succ(*7());
MDLL.9 ::= constant succ(*8());
MDLL.10 ::= constant succ(*9());

MDLL.Pair_of_Natural ::= type of Pair
    where (first(*topic) isa $Natural
        ?? second(*topic) isa $Natural !! FALSE());

MDLL.plus ::= function
    --> Natural <-- Pair_of_Natural
    is_commutative is_associative identity ZERO()
: (
    augend ::= first(*topic);
    addend ::= second(*topic);
    <-- zero(*augend) ?? addend !! zero(*addend) ?? augend
        !! self(*\*:[succ(*augend),pred(*addend)])
);

MDLL.minus ::= function
    --> Natural <-- Pair_of_Natural
    requires in_order(*\*:[second(*topic),first(*topic)])
: (
    minuend ::= first(*topic);
    subtrahend ::= second(*topic);
    <-- zero(*subtrahend) ?? minuend !! same(*\*:[minuend,subtrahend]) ?? ZERO()
        !! self(*\*:[pred(*minuend),pred(*subtrahend)])
);

MDLL.times ::= function
    --> Natural <-- Pair_of_Natural
    is_commutative is_associative identity 1()
: (
    multiplicand ::= first(*topic);
    multiplier ::= second(*topic);
    <-- same(*\*:[multiplicand,1()]) ?? multiplier !! same(*\*:[multiplier,1()]) ?? multiplicand
        !! zero(*multiplicand) ?? ZERO() !! zero(*multiplier) ?? ZERO()
        !! plus(*\*:[multiplicand,self(*\*:[multiplicand,pred(*multiplier)])])
);

MDLL.divide ::= function
    --> Natural <-- Pair_of_Natural
    requires (zero(*second(*topic)) ?? FALSE() !! TRUE())
: (
    dividend ::= first(*topic);
    divisor ::= second(*topic);
    <-- same(*\*:[divisor,1()]) ?? dividend !! same(*\*:[dividend,divisor]) ?? 1()
        !! in_order(*\*:[dividend,divisor]) ?? ZERO()
        !! succ(*self(*\*:[minus(*\*:[dividend,divisor]),divisor]))
);

/*************************************************************************/

MDLL.count ::= function --> Natural <-- List
    : (empty(*topic) ?? ZERO() !! succ(*self(*nonfirst(*topic))));

MDLL.elem ::= function
    --> List <-- Pair
    requires (
        list ::= first(*topic);
        index ::= second(*topic);
        <-- index isa $Natural ?? in_order(*\*:[succ(*index),count(*list)]) !! FALSE()
    )
: (
    list ::= first(*topic);
    index ::= second(*topic);
    <-- zero(*index) ?? first(*list) !! self(*\*:[nonfirst(*list),pred(*index)])
);

/* Note that slice() can only return a non-empty list slice. */

MDLL.slice ::= function
    --> List <-- Pair
    requires (
        list ::= first(*topic);
        range ::= second(*topic);
        if range isa $Pair_of_Natural then
          (
            first_index ::= first(*range);
            last_index ::= second(*range);
            <-- in_order(*\*:[first_index,last_index])
                ?? in_order(*\*:[succ(*last_index),count(*list)])
                !! FALSE()
          )
        else FALSE();
    )
: (
    list ::= first(*topic);
    range ::= second(*topic);
    first_index ::= first(*range);
    last_index ::= second(*range);
    <-- empty(*nonfirst(*list)) ?? list
     !! zero(*first_index) ?? prepend(*\*:[first(*list), 
        self(*\*:[nonfirst(*list),\*:[first_index,pred(*last_index)]])])
     !! self(*\*:[nonfirst(*list),\*:[pred(*first_index),pred(*last_index)]]);
);

MDLL.every_elem_same_count ::= function
    --> Boolean <-- List
: (
       empty(*topic)              ?? TRUE()
    !! empty(*nonfirst(*topic)) ?? TRUE()
    !! same(*\*:[count(*first(*topic)),count(*second(*topic))])
        ?? self(*nonfirst(*topic))
    !! FALSE()
);

/*************************************************************************/

MDLL.Structure_Base ::= type of Pair
    where (first(*topic) isa $Natural);

MDLL.Structure ::=
    Integer|String|Array|Heading|Renaming|Tuple
    |Relation|Identifier|Capsule|Stream|External
    default FALSE();

MDLL.structure_kind ::= function
    --> List <-- Structure_Base : first(*topic);

MDLL.payload ::= function
    --> List <-- Structure_Base : second(*topic);

/*************************************************************************/

MDLL.SK_INTEGER    ::= synonym of ZERO;
MDLL.SK_STRING     ::= synonym of 1;
MDLL.SK_ARRAY      ::= synonym of 2;
MDLL.SK_HEADING    ::= synonym of 3;
MDLL.SK_RENAMING   ::= synonym of 4;
MDLL.SK_TUPLE      ::= synonym of 5;
MDLL.SK_RELATION   ::= synonym of 6;
MDLL.SK_IDENTIFIER ::= synonym of 7;
MDLL.SK_CAPSULE    ::= synonym of 8;
MDLL.SK_STREAM     ::= synonym of 9;
MDLL.SK_EXTERNAL   ::= synonym of 10;

/*************************************************************************/

/* An Integer payload is a list of exactly 2 elements where the first
   element is
   FALSE if the numeric value is >= 0 and TRUE if the numeric value
   is < 0; that first element can be read as "is negative (false/true)".
   The second element is a Natural that defines the magnitude of the
   integer's numeric value.  Every combination of first/second elements is
   valid with the sole exception of [true,0] as we don't want 2 zero ints.
   This is exposed in the high level type system as Integer. */

MDLL.Integer ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_INTEGER()])
        ?? payload(*topic) isa $Integer_Payload !! FALSE());

MDLL.Integer_Payload ::= type of Pair where
(
    is_neg    ::= first(*topic);
    magnitude ::= second(*topic);
    if is_neg isa $Boolean then
        if magnitude isa $Natural then
            if same(*\*:[magnitude,ZERO()]) then
                same(*\*:[is_neg,FALSE()])
            else TRUE()
        else FALSE()
    else FALSE();
);

MDLL.integer ::= function
    --> Integer <-- Integer_Payload
    : \*:[SK_INTEGER(),topic];

MDLL.is_neg ::= function --> Boolean <-- Integer
    : first(*payload(*topic));

MDLL.magnitude ::= function
    --> Natural <-- Integer
    : second(*payload(*topic));

/*************************************************************************/

MDLL.String ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_STRING()])
        ?? payload(*topic) isa $String_Payload !! FALSE());

MDLL.String_Payload ::= type of List
    where (empty(*topic) ?? TRUE()
        !! first(*topic) isa $Integer_Payload
        ?? self(*nonfirst(*topic)) !! FALSE());

MDLL.string ::= function
    --> String <-- String_Payload
    : \*:[SK_STRING(),topic];

MDLL.List_of_String_Payloads ::= type of List
    where (empty(*topic) ?? TRUE() !! first(*topic) isa $String_Payload
        ?? self(*nonfirst(*topic)) !! FALSE());

/*************************************************************************/

MDLL.Array ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_ARRAY()]));

MDLL.array ::= function --> Array <-- List
    : \*:[SK_ARRAY(),topic];

/*************************************************************************/

MDLL.Heading ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_HEADING()])
        ?? payload(*topic) isa $Heading_Payload !! FALSE());

MDLL.Heading_Payload ::= type of List_of_String_Payloads
    where (elems_in_order(*topic));

MDLL.heading ::= function
    --> Heading <-- Heading_Payload
    : \*:[SK_HEADING(),topic];

/*************************************************************************/

MDLL.Renaming ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_RENAMING()])
        ?? payload(*topic) isa $Renaming_Payload !! FALSE());

MDLL.Renaming_Payload ::= type of Pair where
(
    after  ::= first(*topic);
    before ::= second(*topic);
    if after isa $Heading_Payload then
        if before isa $List_of_String_Payloads then
            same(*\*:[count(*after),count(*before)])
        else FALSE()
    else FALSE();
);

MDLL.renaming ::= function
    --> Renaming <-- Renaming_Payload
    : \*:[SK_RENAMING(),topic];

MDLL.renaming_after ::= function
    --> Heading_Payload <-- Renaming : first(*payload(*topic));

MDLL.renaming_before ::= function
    --> List_of_String_Payloads <-- Renaming
    : second(*payload(*topic));

/*************************************************************************/

MDLL.Tuple ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_TUPLE()])
        ?? payload(*topic) isa $Tuple_Payload !! FALSE());

MDLL.Tuple_Payload ::= type of Pair where
(
    heading ::= first(*topic);
    body    ::= second(*topic);
    if heading isa $Heading_Payload then
        same(*\*:[count(*heading),count(*body)])
    else FALSE();
);

MDLL.tuple ::= function
    --> Tuple <-- Tuple_Payload
    : \*:[SK_TUPLE(),topic];

MDLL.tuple_heading ::= function
    --> Heading_Payload <-- Tuple : first(*payload(*topic));

MDLL.tuple_body ::= function --> List <-- Tuple
    : second(*payload(*topic));

/*************************************************************************/

MDLL.Relation ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_RELATION()])
        ?? payload(*topic) isa $Relation_Payload !! FALSE());

MDLL.Relation_Payload ::= type of Pair where
(
    heading ::= first(*topic);
    body    ::= second(*topic);
    if heading isa $Heading_Payload then
        if empty(*body) then
            TRUE()
        else if same(*\*:[count(*heading),count(*first(*body))]) then
            if every_elem_same_count(*body) then
                elems_in_order(*body)
            else FALSE()
        else FALSE()
    else FALSE();
);

MDLL.relation ::= function
    --> Relation <-- Relation_Payload
    : \*:[SK_RELATION(),topic];

MDLL.relation_heading ::= function
    --> Heading_Payload <-- Relation : first(*payload(*topic));

MDLL.relation_body ::= function
    --> List <-- Relation : second(*payload(*topic));

/*************************************************************************/

MDLL.Identifier ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_IDENTIFIER()])
        ?? payload(*topic) isa $Identifier_Payload !! FALSE());

MDLL.Identifier_Payload ::= type of List where
(
    if same(*\*:[count(*topic),4()]) then
      (
        pkg_name_base       ::= elem(*\*:[topic,ZERO()]);
        pkg_name_ext        ::= elem(*\*:[topic,1()]);
        rel_starts_n_lev_up ::= elem(*\*:[topic,2()]);
        path_beneath_pkg    ::= elem(*\*:[topic,3()]);
        <-- if pkg_name_base isa $List_of_String_Payloads then
                if pkg_name_ext isa $List_of_String_Payloads then
                    if rel_starts_n_lev_up isa $Natural then
                        if path_beneath_pkg isa $List_of_String_Payloads then
                            if empty(*pkg_name_base) then
                                if empty(*pkg_name_ext) then
                                    if empty(*path_beneath_pkg) then
                                        zero(*rel_starts_n_lev_up)
                                    else TRUE()
                                else FALSE()
                            else zero(*rel_starts_n_lev_up)
                        else FALSE()
                    else FALSE()
                else FALSE()
            else FALSE()
            ;
      )
    else FALSE()
);

MDLL.identifier ::= function
    --> Identifier <-- Identifier_Payload
    : \*:[SK_IDENTIFIER(),topic];

MDLL.pkg_name_base ::= function
    --> List_of_String_Payloads <-- Identifier
    : elem(*\*:[payload(*topic),ZERO()]);

MDLL.pkg_name_ext ::= function
    --> List_of_String_Payloads <-- Identifier
    : elem(*\*:[payload(*topic),1()]);

MDLL.rel_starts_n_lev_up ::= function
    --> Natural <-- Identifier : elem(*\*:[payload(*topic),2()]);

MDLL.path_beneath_pkg ::= function
    --> List_of_String_Payloads <-- Identifier
    : elem(*\*:[payload(*topic),3()]);

/*************************************************************************/

MDLL.Reference ::= type of Identifier where
(
    if empty(*pkg_name_base(*topic)) then
        FALSE()
    else if empty(*pkg_name_ext(*topic)) then
        FALSE()
    else if zero(*rel_starts_n_lev_up(*topic)) then
        TRUE()
    else FALSE()
);

/*************************************************************************/

MDLL.every_elem_isa ::= function
    --> Boolean <-- Pair
    requires (second(*topic) isa $Reference)
: (
    list ::= first(*topic);
    type ::= second(*topic);
    <-- empty(*list) ?? TRUE()
        !! first(*list) isa type ?? self(*\*:[nonfirst(*list),type]) !! FALSE()
);

/*************************************************************************/

MDLL.Capsule ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_CAPSULE()])
        ?? payload(*topic) isa $Capsule_Payload !! FALSE());

MDLL.Capsule_Payload ::= type of Pair
    where (first(*topic) isa $Reference_Payload
        ?? second(*topic) isa $Tuple_Payload !! FALSE());

MDLL.capsule ::= function
    --> Capsule <-- Capsule_Payload
    : \*:[SK_CAPSULE(),topic];

MDLL.capsule_type ::= function
    --> Reference_Payload <-- Capsule : first(*payload(*topic));

MDLL.capsule_attrs ::= function
    --> Tuple_Payload <-- Capsule : second(*payload(*topic));

/*************************************************************************/

MDLL.Stream ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_STREAM()])
        ?? payload(*topic) isa $Integer_Payload !! FALSE());

MDLL.stream ::= function
    --> Stream <-- Integer_Payload
    : \*:[SK_STREAM(),topic];

/*************************************************************************/

MDLL.External ::= type of Structure_Base
    where (same(*\*:[structure_kind(*topic),SK_EXTERNAL()]));

MDLL.external ::= function
    --> External <-- List : \*:[SK_EXTERNAL(),topic];

/*************************************************************************/

/* Two values are normally considered to have the same low-level type only
   if they are both values of the same one of the types {Boolean, Integer,
   String, Array, SC_Heading, SC_Renaming, Tuple, Relation, SC_Identifier,
   Capsule, Stream, External}, but as a special case, we treat each value
   that isn't of any of those types as having its own singleton type, and
   so every type system value has the same low-level type as itself. */

MDLL.same_low_level_type ::= function
    --> Boolean <-- Pair is_commutative
: (
    lhs ::= first(*topic);
    rhs ::= second(*topic);
    <-- if lhs isa $Boolean then
            rhs isa $Boolean
        else if lhs isa $Structure then
            if rhs isa $Structure then
                same(*\*:[structure_kind(*lhs),structure_kind(*rhs)])
            else FALSE()
        else same(*\*:[lhs,rhs])
);
