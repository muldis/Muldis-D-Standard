`Muldis_Content_Predicate
MCP version http://muldis.com 0.201.0 MCP
MCP script Unicode 2.1 UTF-8 MCP
MCP syntax Muldis_D_Plain_Text http://muldis.com 0.201.0 MCP
MCP model Muldis_Data_Language http://muldis.com 0.201.0 MCP
Muldis_Content_Predicate`

`#########################################################################`
`#########################################################################`

(\Package : (
    identity : (
        package_base_name : [\System],
        authority : "http://muldis.com",
        version_number : "0.201.0",
    ),
    foundation : (
        authority : "http://muldis.com",
        version_number : "0.201.0",
    ),
    floating : {\$package},
    materials : (

`#########################################################################`

        Any : (\Function : (
            is_type_definer : True,
            evaluates : True,
            default : False,
        )),

        None : (\Function : (
            is_type_definer : True,
            evaluates : False,
        )),

        same : (\Function : (
            returns : \$Boolean,
            matches : (\$Any, \$Any),
            is_commutative : True,
            evaluates : (evaluates args --> \foundation::Any_same()),
        )),

        '=' : (\Alias : ( of : \$same, )),

        not_same : (\Function : (
            negates : \$same,
            is_commutative : True,
        )),

        '!=' : (\Alias : ( of : \$not_same, )),

        Unicode_Aliases::'≠' : (\Alias : ( of : \$not_same, )),

        is_a : (\Function : (
            returns : \$Boolean,
            matches : (\$Any, \$Signature),
            evaluates : (evaluates (args:.\0,) --> Signature_to_Function_Call_But_0::(args:.\1)),
        )),

        not_is_a : (\Function : (
            negates : \$is_a,
        )),

`#########################################################################`

        Orderable::'' : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        in_order::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Orderable, \$Orderable),
        )),

        in_order::Before_All_Others_L : (\Function : (
            returns : \$Boolean,
            matches : (\$Before_All_Others, \$Orderable),
            implements : \$folder::'',
            evaluates : (True),
        )),

        in_order::Before_All_Others_R : (\Function : (
            returns : \$Boolean,
            matches : (\$Orderable, \$Before_All_Others),
            implements : \$folder::'',
            evaluates : (args:.\0 = args:.\1),
        )),

        in_order::After_All_Others_L : (\Function : (
            returns : \$Boolean,
            matches : (\$After_All_Others, \$Orderable),
            implements : \$folder::'',
            evaluates : (args:.\0 = args:.\1),
        )),

        in_order::After_All_Others_R : (\Function : (
            returns : \$Boolean,
            matches : (\$Orderable, \$After_All_Others),
            implements : \$folder::'',
            evaluates : (True),
        )),

        before : (\Function : (
            commutes : \$after,
        )),

        '<' : (\Alias : ( of : \$before, )),

        after : (\Function : (
            negates : \$before_or_same,
        )),

        '>' : (\Alias : ( of : \$after, )),

        before_or_same : (\Alias : ( of : \$in_order, )),

        '<=' : (\Alias : ( of : \$before_or_same, )),

        Unicode_Aliases::'≤' : (\Alias : ( of : \$before_or_same, )),

        after_or_same : (\Function : (
            commutes : \$before_or_same,
        )),

        '>=' : (\Alias : ( of : \$after_or_same, )),

        Unicode_Aliases::'≥' : (\Alias : ( of : \$after_or_same, )),

        min : (\Function : (
            returns : \$Orderable,
            matches : (\$Orderable, \$Orderable),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : \!After_All_Others,
            evaluates : (if args:.\0 in_order args:.\1 then args:.\0 else args:.\1),
        )),

        max : (\Function : (
            returns : \$Orderable,
            matches : (\$Orderable, \$Orderable),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : \!Before_All_Others,
            evaluates : (if args:.\0 in_order args:.\1 then args:.\1 else args:.\0),
        )),

        minmax : (\Function : (
            returns : (\$Orderable, \$Orderable),
            matches : (\$Orderable, \$Orderable),
            is_commutative : True,
            evaluates : (if args:.\0 in_order args:.\1 then args else (args:.\1, args:.\0)),
        )),

`#########################################################################`

        Successable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        asset::'' : (\Function : (
            virtual : True,
            returns : \$Any,
            matches : (\$Successable,),
        )),

        succ : (\Function : (
            returns : {\$Successable, \$After_All_Others},
            matches : (\$Successable,),
            evaluates : (args:.\0 nth_succ 1),
        )),

        nth_succ::'' : (\Function : (
            virtual : True,
            returns : {\$Successable, \$After_All_Others},
            matches : (\$Successable, \$Integer_NN),
        )),

`#########################################################################`

        Bicessable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Orderable, \$Successable},
            provides_default_for : {\$Orderable, \$Successable},
        )),

        pred : (\Function : (
            returns : {\$Bicessable, \$Before_All_Others},
            matches : (\$Bicessable,),
            evaluates : (args:.\0 nth_pred 1),
        )),

        nth_pred::'' : (\Function : (
            virtual : True,
            returns : {\$Bicessable, \$Before_All_Others},
            matches : (\$Bicessable, \$Integer_NN),
        )),

`#########################################################################`

        Boolable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        to_Boolean::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Boolable,),
        )),

        so  : (\Alias : ( of : \$to_Boolean, )),
        '?' : (\Alias : ( of : \$to_Boolean, )),

        not_so : (\Function : (
            negates : \$to_Boolean,
        )),

        '!?' : (\Alias : ( of : \$not_so, )),

`#########################################################################`

        Boolean : (\Function : (
            is_type_definer : True,
            composes : {\$Bicessable, \$Boolable},
            provides_default_for : {\$Boolable},
            evaluates : \foundation::Boolean(),
            default : False,
        )),

        False : (\Function : (
            is_type_definer : True,
            constant : False,
        )),

        Unicode_Aliases::'⊥' : (\Alias : ( of : \$False, )),

        True : (\Function : (
            is_type_definer : True,
            constant : True,
        )),

        Unicode_Aliases::'⊤' : (\Alias : ( of : \$True, )),

        in_order::Boolean : (\Function : (
            returns : \$Boolean,
            matches : (\$Boolean, \$Boolean),
            implements : \$folder::'',
            evaluates : (!args:.\0 or args:.\1),
        )),

        asset::Boolean : (\Function : (
            returns : \$Boolean,
            matches : (\$Boolean,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        nth_pred::Boolean : (\Function : (
            returns : {\$False, \$Before_All_Others},
            matches : (\$Boolean, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\1 = 0 then args:.\0 else if args:.\1 = 1 and args:.\0 then False else \!Before_All_Others),
        )),

        nth_succ::Boolean : (\Function : (
            returns : {\$True, \$After_All_Others},
            matches : (\$Boolean, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\1 = 0 then args:.\0 else if args:.\1 = 1 and !args:.\0 then True else \!After_All_Others),
        )),

        to_Boolean::Boolean : (\Function : (
            returns : \$Boolean,
            matches : (\$Boolean,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        not : (\Function : (
            negates : \$to_Boolean::Boolean,
        )),

        '!' : (\Alias : ( of : \$not, )),

        Unicode_Aliases::'¬' : (\Alias : ( of : \$not, )),

        and : (\Function : (
            returns : \$Boolean,
            matches : (\$Boolean, \$Boolean),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : True,
            evaluates : (args:.\0 and_then args:.\1),
        )),

        Unicode_Aliases::'∧' : (\Alias : ( of : \$and, )),

        nand : (\Function : (
            negates : \$and,
            is_commutative : True,
        )),

        not_and : (\Alias : ( of : \$nand, )),

        Unicode_Aliases::'⊼' : (\Alias : ( of : \$nand, )),
        Unicode_Aliases::'↑' : (\Alias : ( of : \$nand, )),

        or : (\Function : (
            returns : \$Boolean,
            matches : (\$Boolean, \$Boolean),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : False,
            evaluates : (args:.\0 or_else args:.\1),
        )),

        Unicode_Aliases::'∨' : (\Alias : ( of : \$or, )),

        nor : (\Function : (
            negates : \$or,
            is_commutative : True,
        )),

        not_or : (\Alias : ( of : \$nor, )),

        Unicode_Aliases::'⊽' : (\Alias : ( of : \$nor, )),
        Unicode_Aliases::'↓' : (\Alias : ( of : \$nor, )),

        xnor : (\Function : (
            returns : \$Boolean,
            matches : (\$Boolean, \$Boolean),
            is_associative : True,
            is_commutative : True,
            identity : True,
            evaluates : (args:.\0 = args:.\1),
        )),

        iff : (\Alias : ( of : \$xnor, )),

        Unicode_Aliases::'↔' : (\Alias : ( of : \$xnor, )),

        xor : (\Function : (
            negates : \$xnor,
            is_associative : True,
            is_commutative : True,
            identity : False,
        )),

        Unicode_Aliases::'⊻' : (\Alias : ( of : \$xor, )),
        Unicode_Aliases::'↮' : (\Alias : ( of : \$xor, )),

        imp : (\Function : (
            returns : \$Boolean,
            matches : (\$Boolean, \$Boolean),
            evaluates : (if args:.\0 then args:.\1 else True),
        )),

        implies : (\Alias : ( of : \$imp, )),

        Unicode_Aliases::'→' : (\Alias : ( of : \$imp, )),

        nimp : (\Function : (
            negates : \$imp,
        )),

        not_implies : (\Alias : ( of : \$nimp, )),

        Unicode_Aliases::'↛' : (\Alias : ( of : \$nimp, )),

        if : (\Function : (
            commutes : \$imp,
        )),

        Unicode_Aliases::'←' : (\Alias : ( of : \$if, )),

        nif : (\Function : (
            commutes : \$nimp,
        )),

        not_if : (\Alias : ( of : \$nif, )),

        Unicode_Aliases::'↚' : (\Alias : ( of : \$nif, )),

`#########################################################################`

        Round_Meth : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Round_Meth_Attr_Name::(),
                ),
            )),
            default : (\$material : (\To_Zero,)),
        )),

        Round_Meth_Attr_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Attr_Name::(), \'⊆$'::( 1:
                \$(Down,Up,To_Zero,To_Inf
                ,Half_Down,Half_Up,Half_To_Zero,Half_To_Inf
                ,Half_Even,Half_Odd)
            )],
            default : \To_Zero,
        )),

        RM : (\Function : (
            returns : \$Round_Meth,
            matches : (\$Round_Meth_Attr_Name,),
            evaluates : ((\$Round_Meth : (args:.\0,))),
        )),

`#########################################################################`

        Numerical : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Boolable},
        )),

        to_Boolean::Numerical : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Numerical,),
            implements : \$folder::'',
        )),

        is_zero : (\Function : (
            negates : \$to_Boolean::Numerical,
        )),

        zero::'' : (\Function : (
            virtual : True,
            returns : \$Numerical,
            matches : (\$Numerical,),
        )),

        opposite::'' : (\Function : (
            virtual : True,
            returns : \$Numerical,
            matches : (\$Numerical,),
        )),

        additive_inverse : (\Alias : ( of : \$opposite, )),

        reciprocal::'' : (\Function : (
            virtual : True,
            returns : {\$Numerical, \$Div_By_Zero},
            matches : (\$Numerical,),
        )),

        multiplicative_inverse : (\Alias : ( of : \$reciprocal, )),

        modulus::'' : (\Function : (
            virtual : True,
            returns : \$Numerical,
            matches : (\$Numerical,),
        )),

        abs : (\Alias : ( of : \$modulus, )),

        plus::'' : (\Function : (
            virtual : True,
            returns : \$Numerical,
            matches : (\$Numerical, \$Numerical),
            is_associative : True,
            is_commutative : True,
            repeater : \$times,
        )),

        '+' : (\Alias : ( of : \$plus, )),

        minus::'' : (\Function : (
            virtual : True,
            returns : \$Numerical,
            matches : (\$Numerical, \$Numerical),
        )),

        '-' : (\Function : (
            returns : \$Numerical,
            matches : {(\$Numerical), (\$Numerical, \$Numerical)},
            evaluates : (evaluates args --> (if degree::(args) = 1 then \opposite::() else \minus::())),
        )),

        Unicode_Aliases::'−' : (\Alias : ( of : '-' )),

        modulus_minus : (\Function : (
            returns : \$Numerical,
            matches : (\$Numerical, \$Numerical),
            is_commutative : True,
            evaluates : (modulus args:.\0 - args:.\1),
        )),

        abs_minus : (\Alias : ( of : \$modulus_minus, )),
        '|-|'     : (\Alias : ( of : \$modulus_minus, )),

        Unicode_Aliases::'|−|' : (\Alias : ( of : \$modulus_minus, )),

        times::'' : (\Function : (
            virtual : True,
            returns : \$Numerical,
            matches : (\$Numerical, \$Numerical),
            is_associative : True,
            is_commutative : True,
            repeater : \$integral_nn_power,
        )),

        '*' : (\Alias : ( of : \$times, )),

        Unicode_Aliases::'×' : (\Alias : ( of : \$times, )),

        multiple_of::'' : (\Function : (
            virtual : True,
            returns : {\$Boolean, \$Div_By_Zero},
            matches : (\$Numerical, \$Numerical),
        )),

        nearest_multiple_of : (\Function : (
            returns : {\$Numerical, \$Div_By_Zero},
            matches : (\$Numerical, \$Numerical, \$Round_Meth),
            evaluates : (if is_zero args:.\1 then \!Div_By_Zero
                else guard args:.\1 * (args:.\0 div args:.\1)),
        )),

        round : (\Alias : ( of : \$nearest_multiple_of, )),

        fractional_divided_by::'' : (\Function : (
            virtual : True,
            returns : {\$Numerical, \$Div_By_Zero},
            matches : (\$Numerical, \$Numerical),
        )),

        '/' : (\Alias : ( of : \$fractional_divided_by, )),

        Unicode_Aliases::'÷' : (\Alias : ( of : \$fractional_divided_by, )),
        Unicode_Aliases::'∕' : (\Alias : ( of : \$fractional_divided_by, )),

        integral_divided_by::'' : (\Function : (
            virtual : True,
            returns : {\$Numerical, \$Div_By_Zero},
            matches : (\$Numerical, \$Numerical, \$Round_Meth),
        )),

        div : (\Alias : ( of : \$integral_divided_by, )),

        modulo : (\Function : (
            returns : {\$Numerical, \$Div_By_Zero},
            matches : (\$Numerical, \$Numerical, \$Round_Meth),
            evaluates : (if is_zero args:.\1 then \!Div_By_Zero
                else guard args:.\0 - (args:.\0 nearest_multiple_of args:.\1)),
        )),

        mod : (\Alias : ( of : \$modulo, )),

        divided_by_and_modulo::'' : (\Function : (
            returns : ({\$Numerical, \$Div_By_Zero}, {\$Numerical, \$Div_By_Zero}),
            matches : (\$Numerical, \$Numerical, \$Round_Meth),
            evaluates : ((args:.\0 div args:.\1, args:.\0 mod args:.\1)),
        )),

        integral_power::'' : (\Function : (
            virtual : True,
            returns : {\$Numerical, \$Zero_To_The_Zero},
            matches : (\$Numerical, \$Integral),
        )),

        '**' : (\Alias : ( of : \$integral_power, )),

        integral_nn_power::'' : (\Function : (
            virtual : True,
            returns : {\$Numerical, \$Zero_To_The_Zero},
            matches : (\$Numerical, \$Integral_NN),
        )),

        power : (\Alias : ( of : \$integral_nn_power, )),

`#########################################################################`

        Integral::'' : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Bicessable, \$Numerical},
            provides_default_for : {\$Bicessable, \$Numerical},
        )),

        Integral_NN : (\Function : (
            is_type_definer : True,
            evaluates : (Integral args:.\0 and_then guard
                args:.\0 >= zero::(args:.\0)),
        )),

        Integral_P : (\Function : (
            is_type_definer : True,
            evaluates : (Integral_NN::(args:.\0) and_then guard
                args:.\0 > zero::(args:.\0)),
            default : (succ::(Integral::())),
        )),

        '--' : (\Function : (
            returns : {\$Integral, \$Before_All_Others},
            matches : (\$Integral,),
            evaluates : (pred args:.\0),
        )),

        '++' : (\Function : (
            returns : {\$Integral, \$After_All_Others},
            matches : (\$Integral,),
            evaluates : (succ args:.\0),
        )),

        to_Integer::'' : (\Function : (
            virtual : True,
            returns : \$Integer,
            matches : (\$Integral,),
        )),

        factorial::'' : (\Function : (
            virtual : True,
            returns : \$Integral_P,
            matches : (\$Integral_NN,),
        )),

        gcd : (\Function : (
            returns : \$Integral_P,
            matches : (\$Integral_NN, \$Integral_NN),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : ((if is_zero args:.\1 then args:.\0 else guard material::(args:.\1, mod::(args:.\0, args:.\1, RM::(\To_Zero))))
                note "Calculate using the Euclidean algorithm."),
        )),

        greatest_common_divisor : (\Alias : ( of : \$gcd, )),

        lcm : (\Function : (
            returns : \$Integral_NN,
            matches : (\$Integral_NN, \$Integral_NN),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : (if is_zero args:.\0 or is_zero args:.\1 then zero args:.\0
                else guard div::(args:.\0 * args:.\1, args:.\0 gcd args:.\1, RM::(\To_Zero))),
        )),

        least_common_multiple : (\Alias : ( of : \$lcm, )),

        coprime : (\Function : (
            returns : \$Boolean,
            matches : (\$Integral, \$Integral),
            evaluates : ((abs::(args:.\0) gcd abs::(args:.\1)) = succ::(zero args:.\0)),
        )),

`#########################################################################`

        Integer::'' : (\Function : (
            is_type_definer : True,
            composes : {\$Integral},
            provides_default_for : {\$Integral},
            evaluates : \foundation::Integer(),
            default : 0,
        )),

        Integer_NN : (\Function : (
            is_type_definer : True,
            evaluates : [\Integer::(), \'>='::( 1: 0 )],
        )),

        Integer_P : (\Function : (
            is_type_definer : True,
            evaluates : [\Integer_NN::(), \'>'::( 1: 0 )],
            default : 1,
        )),

        in_order::Integer : (\Function : (
            returns : \$Boolean,
            matches : (\$Integer, \$Integer),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Integer_in_order()),
        )),

        asset::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        nth_pred::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer, \$Integer_NN),
            implements : \$folder::Integral,
            evaluates : (args:.\0 - args:.\1),
        )),

        nth_succ::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer, \$Integer_NN),
            implements : \$folder::Integral,
            repeater : \$plus::Integer,
            evaluates : (args:.\0 + args:.\1),
        )),

        to_Boolean::Integer : (\Function : (
            returns : \$Boolean,
            matches : (\$Integer,),
            implements : \$folder::'',
            evaluates : (args:.\0 != 0),
        )),

        zero::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer,),
            implements : \$folder::'',
            evaluates : (0),
        )),

        opposite::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Integer_opposite()),
        )),

        reciprocal::Integer : (\Function : (
            returns : {\$Fraction, \$Div_By_Zero},
            matches : (\$Integer,),
            implements : \$folder::'',
            evaluates : (1 / args:.\0),
        )),

        modulus::Integer : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Integer,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Integer_modulus()),
        )),

        plus::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer, \$Integer),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            identity : 0,
            repeater : \$times::Integer,
            evaluates : (evaluates args --> \foundation::Integer_plus()),
        )),

        minus::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer, \$Integer),
            implements : \$folder::'',
            right_identity : 0,
            evaluates : (evaluates args --> \foundation::Integer_minus()),
        )),

        times::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer, \$Integer),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            identity : 1,
            repeater : \$integral_nn_power::Integer,
            evaluates : (evaluates args --> \foundation::Integer_times()),
        )),

        multiple_of::Integer : (\Function : (
            returns : {\$Boolean, \$Div_By_Zero},
            matches : (\$Integer, \$Integer),
            implements : \$folder::'',
            evaluates : (if args:.\1 = 0 then \!Div_By_Zero
                else guard evaluates args --> \foundation::Integer_multiple_of()),
        )),

        fractional_divided_by::Integer : (\Function : (
            returns : {\$Fraction, \$Div_By_Zero},
            matches : (\$Integer, \$Integer),
            implements : \$folder::'',
            right_identity : 1,
            evaluates : (
                n ::= args:.\0;
                d ::= args:.\1;

                returns if d = 0 then \!Div_By_Zero else guard q;

                q ::= (\Fraction : (
                    numerator   : div::((if d > 0 then n else -n), gcd, RM::(\To_Zero)),
                    denominator : div::((if d > 0 then d else -d), gcd, RM::(\To_Zero)),
                ));

                gcd ::= gcd::(abs::(n), abs::(d));
            ),
        )),

        integral_divided_by::Integer : (\Function : (
            returns : {\$Integer, \$Div_By_Zero},
            matches : (\$Integer, \$Integer, \$Round_Meth),
            implements : \$folder::'',
            right_identity : 1,
            evaluates : (
                dividend   ::= args:.\0;
                divisor    ::= args:.\1;
                round_meth ::= args:.\2;

                returns if divisor = 0 then \!Div_By_Zero else guard e1;

                e1 note "This is the case where we are dividing by a non-zero.";

                e1 ::=   if dividend = 0       then 0
                    else if divisor  = 1       then dividend
                    else if dividend = divisor then 1
                    else if divisor  = -1      then -dividend
                    else                            e2
                ;

                e2 note "This is the case where the divisor and dividend do not"
                    " equal each other and neither of them is a zero or a one.";

                e2 ::= (
                    real_q_is_neg ::= dividend < 0 xor divisor < 0;
                    rtz_quotient  ::= foundation::Integer_divided_by_rtz(dividend, divisor);
                    rtz_remainder ::= dividend - (divisor * rtz_quotient);

                    returns if rtz_remainder = 0 then rtz_quotient else e3;
                );

                e3 note "This is the case where the divisor does not divide the"
                    " dividend evenly and the real number division result would"
                    " have a fractional part, so we decide how to round that.";

                e3 ::= (
                    rti_quotient ::= rtz_quotient + (if real_q_is_neg then -1 else 1);
                    rdn_quotient ::= rtz_quotient + (if real_q_is_neg then -1 else 0);
                    rup_quotient ::= rtz_quotient + (if real_q_is_neg then  0 else 1);

                    returns given round_meth
                        when RM::(\Down)    then rdn_quotient
                        when RM::(\Up)      then rup_quotient
                        when RM::(\To_Zero) then rtz_quotient
                        when RM::(\To_Inf)  then rti_quotient
                        default
                                 if (2 * abs::(rtz_remainder)) < abs::(divisor) then rtz_quotient
                            else if (2 * abs::(rtz_remainder)) > abs::(divisor) then rti_quotient
                            else e4
                    ;
                );

                e4 note "This is the case where real division remainder is"
                    " exactly one-half so we decide how to round that.";

                e4 ::= (
                    q ::= foundation::Integer_divided_by_rtz(abs::(rtz_quotient),2)
                    r ::= abs::(rtz_quotient) - (2 * q);
                    rtz_quotient_is_even ::= r = 0;

                    returns given round_meth
                        when RM::(\Half_Down)    then rdn_quotient
                        when RM::(\Half_Up)      then rup_quotient
                        when RM::(\Half_To_Zero) then rtz_quotient
                        when RM::(\Half_To_Inf)  then rti_quotient
                        when RM::(\Half_Even)    then
                            (if rtz_quotient_is_even then rtz_quotient else rti_quotient)
                        when RM::(\Half_Odd)     then
                            (if rtz_quotient_is_even then rti_quotient else rtz_quotient)
                        default fail  `oops, an unhandled case`
                    ;
                );
            ),
        )),

        integral_power::Integer : (\Function : (
            returns : {\$Fraction, \$Zero_To_The_Zero},
            matches : (\$Integer, \$Integer),
            implements : \$folder::'',
            evaluates : (if args:.\0 = 0 and args:.\1 = 0 then \!Zero_To_The_Zero
                else guard args:.\0 / 1 ** args:.\1),
        )),

        integral_nn_power::Integer : (\Function : (
            returns : {\$Integer, \$Zero_To_The_Zero},
            matches : (\$Integer, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\0 = 0 and args:.\1 = 0 then \!Zero_To_The_Zero
                else guard evaluates args --> \foundation::Integer_nn_power()),
        )),

        to_Integer::Integer : (\Function : (
            returns : \$Integer,
            matches : (\$Integer,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        factorial::Integer : (\Function : (
            returns : \$Integer_P,
            matches : (\$Integer_NN,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Integer_factorial()),
        )),

`#########################################################################`

        Fractional::'' : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Orderable, \$Numerical},
        )),

        Fractional_NN : (\Function : (
            is_type_definer : True,
            evaluates : (Fractional args:.\0 and_then guard
                args:.\0 >= zero::(args:.\0)),
        )),

        to_Fraction::'' : (\Function : (
            virtual : True,
            returns : \$Fraction,
            matches : (\$Fractional,),
        )),

        numerator::'' : (\Function : (
            virtual : True,
            returns : \$Integral,
            matches : (\$Fractional,),
        )),

        denominator::'' : (\Function : (
            virtual : True,
            returns : \$Integral_P,
            matches : (\$Fractional,),
        )),

`#########################################################################`

        Fraction::'' : (\Function : (
            is_type_definer : True,
            composes : {\$Fractional},
            provides_default_for : {\$Fractional},
            evaluates : (\$Signature::Article_Match : (
                label : \Fraction,
                attrs : [
                    (
                        numerator : \Integer::(),
                        denominator : \Integer_P::(),
                    ),
                    \(args:.\0:.\numerator coprime args:.\0:.\denominator),
                ],
            )),
            default : 0.0,
        )),

        Fraction_NN : (\Function : (
            is_type_definer : True,
            evaluates : [\Fraction::(), \'>='::( 1: 0.0 )],
        )),

        in_order::Fraction : (\Function : (
            returns : \$Boolean,
            matches : (\$Fraction, \$Fraction),
            implements : \$folder::'',
            evaluates : (
                if (denominator args:.\0) = (denominator args:.\1)
                    then in_order::(numerator args:.\0, numerator args:.\1)
                else
                  (
                    common_d ::= lcm::(denominator args:.\0, denominator args:.\1);
                    returns in_order::(
                        (numerator args:.\0) * div::(common_d, denominator args:.\0, RM::(\To_Zero)),
                        (numerator args:.\1) * div::(common_d, denominator args:.\1, RM::(\To_Zero)),
                    );
                  )
            ),
        )),

        to_Boolean::Fraction : (\Function : (
            returns : \$Boolean,
            matches : (\$Fraction,),
            implements : \$folder::'',
            evaluates : (args:.\0 != 0.0),
        )),

        zero::Fraction : (\Function : (
            returns : \$Fraction,
            matches : (\$Fraction,),
            implements : \$folder::'',
            evaluates : (0.0),
        )),

        opposite::Fraction : (\Function : (
            returns : \$Fraction,
            matches : (\$Fraction,),
            implements : \$folder::'',
            evaluates : (-(numerator args:.\0) / (denominator args:.\0)),
        )),

        reciprocal::Fraction : (\Function : (
            returns : {\$Fraction, \$Div_By_Zero},
            matches : (\$Fraction,),
            implements : \$folder::'',
            evaluates : (if args:.\0 = 0.0 then \!Div_By_Zero
                else guard (denominator args:.\0) / (numerator args:.\0)),
        )),

        modulus::Fraction : (\Function : (
            returns : \$Fraction_NN,
            matches : (\$Fraction,),
            implements : \$folder::'',
            evaluates : (abs::(numerator args:.\0) / (denominator args:.\0)),
        )),

        plus::Fraction : (\Function : (
            returns : \$Fraction,
            matches : (\$Fraction, \$Fraction),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            identity : 0.0,
            repeater : \$times::Fraction_Integer,
            evaluates : (
                if (denominator args:.\0) = (denominator args:.\1)
                    then (numerator args:.\0) + (numerator args:.\1) / (denominator args:.\0)
                else
                  (
                    common_d ::= lcm::(denominator args:.\0, denominator args:.\1);
                    returns ((numerator args:.\0) * div::(common_d, denominator args:.\0, RM::(\To_Zero)))
                        + ((numerator args:.\1) * div::(common_d, denominator args:.\1, RM::(\To_Zero)))
                        / common_d;
                  )
            ),
        )),

        minus::Fraction : (\Function : (
            returns : \$Fraction,
            matches : (\$Fraction, \$Fraction),
            implements : \$folder::'',
            right_identity : 0.0,
            evaluates : (args:.\0 + -args:.\1),
        )),

        times::Fraction : (\Function : (
            returns : \$Fraction,
            matches : (\$Fraction, \$Fraction),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            identity : 1.0,
            repeater : \$integral_nn_power::Fraction,
            evaluates : (((numerator args:.\0) * (numerator args:.\1))
                / ((denominator args:.\0) * (denominator args:.\1))),
        )),

        times::Fraction_Integer : (\Function : (
            returns : \$Fraction,
            matches : (\$Fraction, \$Integer),
            implements : \$folder::'',
            evaluates : (((numerator args:.\0) * args:.\1) / (denominator args:.\0)),
        )),

        multiple_of::Fraction : (\Function : (
            returns : {\$Boolean, \$Div_By_Zero},
            matches : (\$Fraction, \$Fraction),
            implements : \$folder::'',
            evaluates : (if args:.\1 = 0.0 then \!Div_By_Zero
                else guard (args:.\0 mod args:.\1) = 0.0),
        )),

        fractional_divided_by::Fraction : (\Function : (
            returns : {\$Fraction, \$Div_By_Zero},
            matches : (\$Fraction, \$Fraction),
            implements : \$folder::'',
            right_identity : 1.0,
            evaluates : (if args:.\1 = 0.0 then \!Div_By_Zero
                else guard args:.\0 * reciprocal::(args:.\1)),
        )),

        integral_divided_by::Fraction : (\Function : (
            returns : {\$Fraction, \$Div_By_Zero},
            matches : (\$Fraction, \$Fraction, \$Round_Meth),
            implements : \$folder::'',
            right_identity : 1.0,
            evaluates : (
                d ::= lcm::(denominator args:.\0, denominator args:.\1);
                n0 ::= (numerator args:.\0) * div::(d, denominator args:.\0, RM::(\To_Zero));
                n1 ::= (numerator args:.\1) * div::(d, denominator args:.\1, RM::(\To_Zero));
                returns if args:.\1 = 0.0 then \!Div_By_Zero
                    else guard div::(n0 * d, n1 * d, args:.\2) / 1;
            ),
        )),

        integral_power::Fraction : (\Function : (
            returns : {\$Fraction, \$Zero_To_The_Zero},
            matches : (\$Fraction, \$Integer),
            implements : \$folder::'',
            evaluates : (evaluates \integral_nn_power::()
                <-- (if args:.\1 >= 0 then args else (reciprocal::(args:.\0), -args:.\1))),
        )),

        integral_nn_power::Fraction : (\Function : (
            returns : {\$Fraction, \$Zero_To_The_Zero},
            matches : (\$Fraction, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\0 = 0.0 and args:.\1 = 0 then \!Zero_To_The_Zero
                else guard ((numerator args:.\0) ** args:.\1) / ((denominator args:.\0) ** args:.\1)),
        )),

        to_Fraction::Fraction : (\Function : (
            returns : \$Fraction,
            matches : (\$Fraction,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        numerator::Fraction : (\Function : (
            returns : \$Integer,
            matches : (\$Fraction,),
            evaluates : (args:.\0:>.\numerator),
        )),

        denominator::Fraction : (\Function : (
            returns : \$Integer_P,
            matches : (\$Fraction,),
            evaluates : (args:.\0:>.\denominator),
        )),

`#########################################################################`

        Emptyable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Boolable},
        )),

        to_Boolean::Emptyable : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Emptyable,),
            implements : \$folder::'',
        )),

        has_any_members : (\Alias : ( of : \$to_Boolean::Emptyable, )),

        is_empty : (\Function : (
            negates : \$to_Boolean::Emptyable,
        )),

        Unicode_Aliases::'∅?' : (\Alias : ( of : \$is_empty, )),

        empty::'' : (\Function : (
            virtual : True,
            returns : {\$Emptyable, \$No_Empty_Value},
            matches : (\$Emptyable,),
        )),

        Unicode_Aliases::'∅' : (\Alias : ( of : \$empty, )),

`#########################################################################`

        Stringy : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Orderable, \$Emptyable},
            provides_default_for : {\$Emptyable},
        )),

        substring_of::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Stringy, \$Stringy),
        )),

        superstring_of : (\Function : (
            commutes : \$substring_of,
        )),

        proper_substring_or_superstring : (\Function : (
            returns : \$Boolean,
            matches : (\$Stringy, \$Stringy),
            is_commutative : True,
            evaluates : (args:.\0 != args:.\1 and (args:.\0 substring_or_superstring args:.\1)),
        )),

        substring_or_superstring : (\Function : (
            returns : \$Boolean,
            matches : (\$Stringy, \$Stringy),
            is_commutative : True,
            evaluates : ((args:.\0 substring_of args:.\1) or (args:.\0 superstring_of args:.\1)),
        )),

        overlaps_string::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Stringy, \$Stringy),
            is_commutative : True,
        )),

        disjoint_string::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Stringy, \$Stringy),
            is_commutative : True,
        )),

        catenate::'' : (\Function : (
            virtual : True,
            returns : \$Stringy,
            matches : (\$Stringy, \$Stringy),
            is_associative : True,
            repeater : \$replicate,
        )),

        '~' : (\Alias : ( of : \$catenate, )),

        replicate::'' : (\Function : (
            virtual : True,
            returns : \$Stringy,
            matches : (\$Stringy, \$Integer_NN),
        )),

        '~#' : (\Alias : ( of : \$replicate, )),

`#########################################################################`

        Bits : (\Function : (
            is_type_definer : True,
            composes : {\$Stringy},
            provides_default_for : {\$Stringy},
            evaluates : (\$Signature::Article_Match : (
                label : \Bits,
                attrs : (
                    bits : \Array::Bits(),
                ),
            )),
            default : \~?"",
        )),

        Array::Bits : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(), \all::( 1: \in::( 1: 0..1 ) )],
        )),

        in_order::Bits : (\Function : (
            returns : \$Boolean,
            matches : (\$Bits, \$Bits),
            implements : \$folder::'',
            evaluates : ((Bits_to_Array_Bits args:.\0) in_order (Bits_to_Array_Bits args:.\1)),
        )),

        to_Boolean::Bits : (\Function : (
            returns : \$Boolean,
            matches : (\$Bits,),
            implements : \$folder::'',
            evaluates : (args:.\0 != \~?""),
        )),

        empty::Bits : (\Function : (
            returns : \$Bits,
            matches : (\$Bits,),
            implements : \$folder::'',
            evaluates : (\~?""),
        )),

        substring_of::Bits : (\Function : (
            returns : \$Boolean,
            matches : (\$Bits, \$Bits),
            implements : \$folder::'',
            evaluates : ((Bits_to_Array_Bits args:.\0) substring_of (Bits_to_Array_Bits args:.\1)),
        )),

        overlaps_string::Bits : (\Function : (
            returns : \$Boolean,
            matches : (\$Bits, \$Bits),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((Bits_to_Array_Bits args:.\0)
                overlaps_string (Bits_to_Array_Bits args:.\1)),
        )),

        disjoint_string::Bits : (\Function : (
            returns : \$Boolean,
            matches : (\$Bits, \$Bits),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((Bits_to_Array_Bits args:.\0)
                disjoint_string (Bits_to_Array_Bits args:.\1)),
        )),

        catenate::Bits : (\Function : (
            returns : \$Bits,
            matches : (\$Bits, \$Bits),
            implements : \$folder::'',
            is_associative : True,
            identity : \~?"",
            repeater : \$replicate::Bits,
            evaluates : (Bits_from_Array_Bits::((Bits_to_Array_Bits args:.\0)
                ~ (Bits_to_Array_Bits args:.\1))),
        )),

        replicate::Bits : (\Function : (
            returns : \$Bits,
            matches : (\$Bits, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (Bits_from_Array_Bits::((Bits_to_Array_Bits args:.\0) ~# args:.\1)),
        )),

        Bits_from_Array_Bits : (\Function : (
            returns : \$Bits,
            matches : (\$Array::Bits,),
            evaluates : ((\Bits : (bits : args:.\0,))),
        )),

        Bits_to_Array_Bits : (\Function : (
            returns : \$Array::Bits,
            matches : (\$Bits,),
            evaluates : (args:.\0:>.\bits),
        )),

`#########################################################################`

        Blob : (\Function : (
            is_type_definer : True,
            composes : {\$Stringy},
            evaluates : (\$Signature::Article_Match : (
                label : \Blob,
                attrs : (
                    octets : \Array::Octets(),
                ),
            )),
            default : \~+"",
        )),

        Array::Octets : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(), \all::( 1: \in::( 1: 0..255 ) )],
        )),

        in_order::Blob : (\Function : (
            returns : \$Boolean,
            matches : (\$Blob, \$Blob),
            implements : \$folder::'',
            evaluates : ((Blob_to_Octets args:.\0) in_order (Blob_to_Octets args:.\1)),
        )),

        to_Boolean::Blob : (\Function : (
            returns : \$Boolean,
            matches : (\$Blob,),
            implements : \$folder::'',
            evaluates : (args:.\0 != \~+""),
        )),

        empty::Blob : (\Function : (
            returns : \$Blob,
            matches : (\$Blob,),
            implements : \$folder::'',
            evaluates : (\~+""),
        )),

        substring_of::Blob : (\Function : (
            returns : \$Boolean,
            matches : (\$Blob, \$Blob),
            implements : \$folder::'',
            evaluates : ((Blob_to_Octets args:.\0) substring_of (Blob_to_Octets args:.\1)),
        )),

        overlaps_string::Blob : (\Function : (
            returns : \$Boolean,
            matches : (\$Blob, \$Blob),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((Blob_to_Octets args:.\0) overlaps_string (Blob_to_Octets args:.\1)),
        )),

        disjoint_string::Blob : (\Function : (
            returns : \$Boolean,
            matches : (\$Blob, \$Blob),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((Blob_to_Octets args:.\0) disjoint_string (Blob_to_Octets args:.\1)),
        )),

        catenate::Blob : (\Function : (
            returns : \$Blob,
            matches : (\$Blob, \$Blob),
            implements : \$folder::'',
            is_associative : True,
            identity : \~+"",
            repeater : \$replicate::Blob,
            evaluates : (Blob_from_Octets::((Blob_to_Octets args:.\0) ~ (Blob_to_Octets args:.\1))),
        )),

        replicate::Blob : (\Function : (
            returns : \$Blob,
            matches : (\$Blob, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (Blob_from_Octets::((Blob_to_Octets args:.\0) ~# args:.\1)),
        )),

        Blob_from_Octets : (\Function : (
            returns : \$Blob,
            matches : (\$Array::Octets,),
            evaluates : ((\Blob : (octets : args:.\0,))),
        )),

        Blob_to_Octets : (\Function : (
            returns : \$Array::Octets,
            matches : (\$Blob,),
            evaluates : (args:.\0:>.\octets),
        )),

`#########################################################################`

        Textual : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Stringy},
        )),

        to_Text::'' : (\Function : (
            virtual : True,
            returns : \$Text,
            matches : (\$Textual,),
        )),

`#########################################################################`

        Text::'' : (\Function : (
            is_type_definer : True,
            composes : {\$Textual},
            provides_default_for : {\$Textual},
            evaluates : (\$Signature::Article_Match : (
                label : \Text,
                attrs : (
                    unicode_codes : \Array::Unicode_Codes(),
                ),
            )),
            default : "",
        )),

        Text::Unicode : (\Alias : ( of : \$Text, )),

        Array::Unicode_Codes : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(),
                \all::( 1: \in::( 1: ?..{0..0xD7FF,0xE000..0x10FFFF} ) )],
        )),

        Text::ASCII : (\Function : (
            is_type_definer : True,
            evaluates : (Text::Unicode::(args:.\0) and_then guard
                Array::ASCII_Chars::(Text_from_Unicode_Codes args:.\0)),
        )),

        Array::ASCII_Chars : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::Unicode_Codes(), \all::( 1: \in::( 1: 0..127 ) )],
        )),

        in_order::Text : (\Function : (
            returns : \$Boolean,
            matches : (\$Text, \$Text),
            implements : \$folder::'',
            evaluates : ((Text_to_Unicode_Codes args:.\0) in_order (Text_to_Unicode_Codes args:.\1)),
        )),

        to_Boolean::Text : (\Function : (
            returns : \$Boolean,
            matches : (\$Text,),
            implements : \$folder::'',
            evaluates : (args:.\0 != ""),
        )),

        empty::Text : (\Function : (
            returns : \$Text,
            matches : (\$Text,),
            implements : \$folder::'',
            evaluates : (""),
        )),

        substring_of::Text : (\Function : (
            returns : \$Boolean,
            matches : (\$Text, \$Text),
            implements : \$folder::'',
            evaluates : ((Text_to_Unicode_Codes args:.\0)
                substring_of (Text_to_Unicode_Codes args:.\1)),
        )),

        overlaps_string::Text : (\Function : (
            returns : \$Boolean,
            matches : (\$Text, \$Text),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((Text_to_Unicode_Codes args:.\0)
                overlaps_string (Text_to_Unicode_Codes args:.\1)),
        )),

        disjoint_string::Text : (\Function : (
            returns : \$Boolean,
            matches : (\$Text, \$Text),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((Text_to_Unicode_Codes args:.\0)
                disjoint_string (Text_to_Unicode_Codes args:.\1)),
        )),

        catenate::Text : (\Function : (
            returns : \$Text,
            matches : (\$Text, \$Text),
            implements : \$folder::'',
            is_associative : True,
            identity : "",
            repeater : \$replicate::Text,
            evaluates : (Text_from_Unicode_Codes::((Text_to_Unicode_Codes args:.\0)
                ~ (Text_to_Unicode_Codes args:.\1))),
        )),

        replicate::Text : (\Function : (
            returns : \$Text,
            matches : (\$Text, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (Text_from_Unicode_Codes::((Text_to_Unicode_Codes args:.\0) ~# args:.\1)),
        )),

        to_Text::Text : (\Function : (
            returns : \$Text,
            matches : (\$Text,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        Text_from_Unicode_Codes : (\Function : (
            returns : \$Text,
            matches : (\$Array::Unicode_Codes,),
            evaluates : ((\Text : (unicode_codes : args:.\0,))),
        )),

        Text_to_Unicode_Codes : (\Function : (
            returns : \$Array::Unicode_Codes,
            matches : (\$Text,),
            evaluates : (args:.\0:>.\unicode_codes),
        )),

        Text_from_ASCII_Chars : (\Function : (
            returns : \$Text::ASCII,
            matches : (\$Array::ASCII_Chars,),
            evaluates : (Text_from_Unicode_Codes args:.\0),
        )),

        Text_to_ASCII_Chars : (\Function : (
            returns : \$Array::ASCII_Chars,
            matches : (\$Text::ASCII,),
            evaluates : (Text_to_Unicode_Codes args:.\0),
        )),

        Blob_is_UTF_8 : (\Function : (
            returns : \$Boolean,
            matches : (\$Blob,),
            evaluates : (...),
        )),

        Text_from_UTF_8_Blob : (\Function : (
            returns : {\$Text::Unicode, \$Unicode::..., ...},
            matches : (\$Blob,),
            evaluates : (...),
        )),

        Text_from_UTF_8_Blob_with_repl_Text : (\Function : (
            returns : \$Text::Unicode,
            matches : (\$Blob, \$Text::Unicode),
            evaluates : (...),
        )),

        Text_from_UTF_8_Blob_with_repl_char : (\Function : (
            returns : \$Text::Unicode,
            matches : (\$Blob,),
            evaluates : (Text_from_UTF_8_Blob_with_repl_Text::(args:.\0,"\\c<0xFFFD>")),
        )),

        Text_to_UTF_8_Blob : (\Function : (
            returns : \$Blob,
            matches : (\$Text::Unicode,),
            evaluates : (...),
        )),

        Blob_is_ASCII : (\Function : (
            returns : \$Boolean,
            matches : (\$Blob,),
            evaluates : (Array::ASCII_Chars(Blob_to_Octets args:.\0)),
        )),

        Text_from_ASCII_Blob : (\Function : (
            returns : {\$Text::ASCII, \$ASCII::High_Bit_Not_Zero},
            matches : (\$Blob,),
            evaluates : (
                octets ::= Blob_to_Octets args:.\0;
                returns if Array::ASCII_Chars(octets)
                    then guard Text_from_ASCII_Chars octets
                    else ASCII::High_Bit_Not_Zero();
            ),
        )),

        Text_from_ASCII_Blob_with_repl_Text : (\Function : (
            returns : \$Text::ASCII,
            matches : (\$Blob, \$Text::ASCII),
            evaluates : (
                src_octets ::= Blob_to_Octets args:.\0;
                repl_chars ::= Text_to_ASCII_Chars args:.\1;
                result_chars ::=
                    given #repl_chars
                        when 0 then
                            src_octets where \in::( 1: 0..127 )
                        when 1 then guard
                            src_octets
                                map \(if args:.\0 in 0..127 then args:.\0 else args:.\1)
                                    <-- (1 : repl_chars.0,)
                        default
                            src_octets
                                map \(if args:.\0 in 0..127 then [args:.\0] else args:.\1)
                                    <-- (1 : repl_chars,)
                                reduce \catenate::()
                    ;
                returns Text_from_ASCII_Chars result_chars;
            ),
        )),

        Text_to_ASCII_Blob : (\Function : (
            returns : \$Blob,
            matches : (\$Text::ASCII,),
            evaluates : (Blob_from_Octets::(Text_to_ASCII_Chars args:.\0)),
        )),

`#########################################################################`

        Accessible : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        has_any_at::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Accessible, \$Any),
        )),

        '.?' : (\Alias : ( of : \$has_any_at, )),

        not_has_any_at : (\Function : (
            negates : \$has_any_at,
        )),

        '.!?' : (\Alias : ( of : \$not_has_any_at, )),

        has_mapping_at::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (Accessible, (Any, Any)),
        )),

        '.:?' : (\Alias : ( of : \$has_mapping_at, )),

        mapping_at::'' : (\Function : (
            virtual : True,
            returns : (\$Any, \$Any),
            matches : (\$Accessible, \$Any),
            accepts : (args:.\0 .? args:.\1),
        )),

        '.:' : (\Alias : ( of : \$mapping_at, )),

        at::'' : (\Function : (
            virtual : True,
            returns : \$Any,
            matches : (\$Accessible, \$Any),
            accepts : (args:.\0 .? args:.\1),
        )),

        '.' : (\Alias : ( of : \$at, )),

        maybe_at::'' : (\Function : (
            virtual : True,
            returns : \$Any,
            matches : (\$Accessible, \$Any),
        )),

        '.!' : (\Alias : ( of : \$maybe_at, )),

        replace_at::'' : (\Function : (
            virtual : True,
            returns : \$Accessible,
            matches : (Accessible, (Any, Any)),
            accepts : (args:.\0 .? (args:.\1.\0)),
        )),

        '.:=' : (\Alias : ( of : \$replace_at, )),

        shiftless_insert_at::'' : (\Function : (
            virtual : True,
            returns : \$Accessible,
            matches : (Accessible, (Any, Any)),
            accepts : (not args:.\0 .? (args:.\1.\0)),
        )),

        '.+' : (\Alias : ( of : \$shiftless_insert_at, )),

        shiftless_remove_at::'' : (\Function : (
            virtual : True,
            returns : \$Accessible,
            matches : (\$Accessible, \$Any),
            accepts : (args:.\0 .? args:.\1),
        )),

        '.-' : (\Alias : ( of : \$shiftless_remove_at, )),

        replace_or_insert_at::'' : (\Function : (
            virtual : True,
            returns : \$Accessible,
            matches : (Accessible, (Any, Any)),
        )),

        '.=+' : (\Alias : ( of : \$replace_or_insert_at, )),

        shiftless_maybe_remove_at::'' : (\Function : (
            virtual : True,
            returns : \$Accessible,
            matches : (\$Accessible, \$Any),
        )),

        '.?-' : (\Alias : ( of : \$shiftless_maybe_remove_at, )),

`#########################################################################`

        Homogeneous : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Emptyable},
        )),

        singular::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous,),
        )),

        only_member::'' : (\Function : (
            virtual : True,
            returns : \$Any,
            matches : (\$Homogeneous,),
            accepts : (singular args:.\0),
        )),

        in : (\Function : (
            commutes : \$has,
        )),

        Unicode_Aliases::'∈' : (\Alias : ( of : \$in, )),

        not_in : (\Function : (
            commutes : \$not_has,
        )),

        Unicode_Aliases::'∉' : (\Alias : ( of : \$not_in, )),

        has : (\Function : (
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Any),
            evaluates : (has_n::(args:.\0, args:.\1, 1)),
        )),

        Unicode_Aliases::'∋' : (\Alias : ( of : \$has, )),

        not_has : (\Function : (
            negates : \$has,
        )),

        Unicode_Aliases::'∌' : (\Alias : ( of : \$not_has, )),

        has_n::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Any, \$Integer_NN),
        )),

        multiplicity::'' : (\Function : (
            virtual : True,
            returns : \$Integer_NN,
            matches : (\$Homogeneous, \$Any),
        )),

        all_unique::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous,),
        )),

        unique::'' : (\Function : (
            virtual : True,
            returns : \$Homogeneous,
            matches : (\$Homogeneous,),
        )),

        proper_subset_of : (\Function : (
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Homogeneous),
            evaluates : (args:.\0 != args:.\1 and (args:.\0 subset_of args:.\1)),
        )),

        Unicode_Aliases::'⊂' : (\Alias : ( of : \$proper_subset_of, )),

        not_proper_subset_of : (\Function : (
            negates : \$proper_subset_of,
        )),

        Unicode_Aliases::'⊄' : (\Alias : ( of : \$not_proper_subset_of, )),

        proper_superset_of : (\Function : (
            commutes : \$proper_subset_of,
        )),

        Unicode_Aliases::'⊃' : (\Alias : ( of : \$proper_superset_of, )),

        not_proper_superset_of : (\Function : (
            negates : \$proper_superset_of,
        )),

        Unicode_Aliases::'⊅' : (\Alias : ( of : \$not_proper_superset_of, )),

        subset_of::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Homogeneous),
        )),

        Unicode_Aliases::'⊆' : (\Alias : ( of : \$subset_of, )),

        not_subset_of : (\Function : (
            negates : \$subset_of,
        )),

        Unicode_Aliases::'⊈' : (\Alias : ( of : \$not_subset_of, )),

        superset_of : (\Function : (
            commutes : \$subset_of,
        )),

        Unicode_Aliases::'⊇' : (\Alias : ( of : \$superset_of, )),

        not_superset_of : (\Function : (
            negates : \$superset_of,
        )),

        Unicode_Aliases::'⊉' : (\Alias : ( of : \$not_superset_of, )),

        same_members::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Homogeneous),
            is_commutative : True,
        )),

        proper_subset_or_superset : (\Function : (
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Homogeneous),
            is_commutative : True,
            evaluates : (not (args:.\0 same_members args:.\1) and (args:.\0 subset_or_superset args:.\1)),
        )),

        subset_or_superset : (\Function : (
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Homogeneous),
            is_commutative : True,
            evaluates : ((args:.\0 subset_of args:.\1) or (args:.\0 superset_of args:.\1)),
        )),

        overlaps_members::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Homogeneous),
            is_commutative : True,
        )),

        disjoint_members::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Homogeneous),
            is_commutative : True,
        )),

        any::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Signature),
        )),

        there_exists : (\Alias : ( of : \$any, )),

        Unicode_Aliases::'∃' : (\Alias : ( of : \$any, )),

        none : (\Function : (
            negates : \$any,
        )),

        there_does_not_exist : (\Alias : ( of : \$none, )),

        Unicode_Aliases::'∄' : (\Alias : ( of : \$none, )),

        all : (\Function : (
            returns : \$Boolean,
            matches : (\$Homogeneous, \$Signature),
            evaluates : (args:.\0 none \not_is_a::( 1: args:.\1 )),
        )),

        for_all : (\Alias : ( of : \$all, )),

        Unicode_Aliases::'∀' : (\Alias : ( of : \$all, )),

        not_all : (\Function : (
            negates : \$all,
        )),

`#########################################################################`

        Unionable : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Homogeneous},
        )),

        insert : (\Function : (
            returns : \$Unionable,
            matches : (\$Unionable, \$Any),
            evaluates : (insert_n::(args:.\0, args:.\1, 1)),
        )),

        insert_n::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Any, \$Integer_NN),
        )),

        remove : (\Function : (
            returns : \$Unionable,
            matches : (\$Unionable, \$Any),
            evaluates : (remove_n::(args:.\0, args:.\1, 1)),
        )),

        remove_n::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Any, \$Integer_NN),
        )),

        member_plus::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Unionable),
            is_associative : True,
        )),

        Unicode_Aliases::'⊎' : (\Alias : ( of : \$member_plus, )),

        except::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Unionable),
        )),

        Unicode_Aliases::'∖' : (\Alias : ( of : \$except, )),

        intersect::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Unionable),
            is_associative : True,
            is_idempotent : True,
        )),

        Unicode_Aliases::'∩' : (\Alias : ( of : \$intersect, )),

        union::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Unionable),
            is_idempotent : True,
        )),

        Unicode_Aliases::'∪' : (\Alias : ( of : \$union, )),

        exclusive::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Unionable),
        )),

        symm_diff : (\Alias : ( of : \$exclusive, )),

        Unicode_Aliases::'∆' : (\Alias : ( of : \$exclusive, )),

        nest::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable,),
            accepts : (...),
        )),

        group : (\Alias : ( of : \$nest, )),

        unnest::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable,),
            accepts : (...),
        )),

        ungroup : (\Alias : ( of : \$unnest, )),

        where::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Signature),
        )),

        Unicode_Aliases::'σ' : (\Alias : ( of : \$where, )),

        filtering : (\Function : (
            commutes : \$where,
        )),

        map::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Unionable, \$Function_Call_But_0),
        )),

        reduce::'' : (\Function : (
            virtual : True,
            returns : \$Any,
            matches : (\$Unionable, \$Function_Call_But_0_1),
        )),

`#########################################################################`

        Discrete : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Unionable},
            provides_default_for : {\$Unionable},
        )),

        to_Set::'' : (\Function : (
            virtual : True,
            returns : \$Set,
            matches : (\$Discrete,),
        )),

        '?|' : (\Alias : ( of : \$to_Set, )),

        to_Bag::'' : (\Function : (
            virtual : True,
            returns : \$Bag,
            matches : (\$Discrete,),
        )),

        '+|' : (\Alias : ( of : \$to_Bag, )),

        count::'' : (\Function : (
            virtual : True,
            returns : \$Integer_NN,
            matches : (\$Discrete,),
        )),

        cardinality : (\Alias : ( of : \$count, )),
        '#'         : (\Alias : ( of : \$count, )),

        unique_count::'' : (\Function : (
            virtual : True,
            returns : \$Integer_NN,
            matches : (\$Discrete,),
        )),

        order : (\Function : (
            returns : \$Positional,
            matches : (\$Discrete,),
            evaluates : (args:.\0 order_using \in_order::()),
        )),

        order_using::'' : (\Function : (
            virtual : True,
            returns : \$Positional,
            matches : (\$Discrete, \$Function_Call_But_0_1),
        )),

`#########################################################################`

        Positional : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Stringy, \$Discrete, \$Accessible},
            provides_default_for : {\$Discrete},
        )),

        singular::Positional : (\Function : (
            returns : \$Boolean,
            matches : (\$Positional,),
            implements : \$folder::'',
            evaluates : ((unique_count args:.\0) = 1),
        )),

        only_member::Positional : (\Function : (
            returns : \$Any,
            matches : (\$Positional,),
            implements : \$folder::'',
            accepts : (singular args:.\0),
            evaluates : (first args:.\0),
        )),

        subset_of::Positional : (\Function : (
            returns : \$Boolean,
            matches : (\$Positional, \$Positional),
            implements : \$folder::'',
            evaluates : ((to_Bag args:.\0) subset_of (to_Bag args:.\1)),
        )),

        same_members::Positional : (\Function : (
            returns : \$Boolean,
            matches : (\$Positional, \$Positional),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((to_Bag args:.\0) same_members (to_Bag args:.\1)),
        )),

        overlaps_members::Positional : (\Function : (
            returns : \$Boolean,
            matches : (\$Positional, \$Positional),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((to_Bag args:.\0) overlaps_members (to_Bag args:.\1)),
        )),

        disjoint_members::Positional : (\Function : (
            returns : \$Boolean,
            matches : (\$Positional, \$Positional),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : ((to_Bag args:.\0) disjoint_members (to_Bag args:.\1)),
        )),

        member_plus::Positional : (\Function : (
            returns : \$Positional,
            matches : (\$Positional, \$Positional),
            implements : \$folder::'',
            is_associative : True,
            evaluates : (args:.\0 ~ args:.\1),
        )),

        unique_count::Positional : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Positional,),
            implements : \$folder::'',
            evaluates : (count::(to_Set args:.\0)),
        )),

        has_any_at::Positional : (\Function : (
            returns : \$Boolean,
            matches : (\$Positional, \$Integer),
            implements : \$folder::'',
            evaluates : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 < first_unused_ord_pos::(args:.\0)),
        )),

        has_mapping_at::Positional : (\Function : (
            returns : \$Boolean,
            matches : (Positional, (Integer, Any)),
            implements : \$folder::'',
            evaluates : (args:.\0 .? (args:.\1.\0) and_then guard args:.\0.(args:.\1.\0) = (args:.\1.\1)),
        )),

        mapping_at::Positional : (\Function : (
            returns : (\$Integer, \$Any),
            matches : (\$Positional, \$Integer),
            implements : \$folder::'',
            accepts : (args:.\0 .? args:.\1),
            evaluates : ((args:.\1, args:.\0.args:.\1)),
        )),

        maybe_at::Positional : (\Function : (
            returns : \$Any,
            matches : (\$Positional, \$Integer),
            implements : \$folder::'',
            evaluates : (if args:.\0 .? args:.\1 then guard args:.\0.args:.\1 else \!No_Such_Ord_Pos),
        )),

        replace_at::Positional : (\Function : (
            returns : \$Positional,
            matches : (Positional, (Integer, Any)),
            implements : \$folder::'',
            accepts : (args:.\0 .? (args:.\1.\0)),
            evaluates : (
                src ::= args:.\0;
                rop ::= args:.\1.\0;
                repl_member ::= args:.\1.\1;
                fop ::= first_ord_pos src;
                lop ::= last_ord_pos src;
                emp ::= empty src;
                returns (if rop > fop then guard slice_range::(src, fop, --rop) else emp)
                    insert repl_member
                    catenate (if rop < lop then guard slice_range::(src, ++rop, lop) else emp);
            ),
        )),

        shiftless_insert_at::Positional : (\Function : (
            returns : \$Positional,
            matches : (Positional, (Integer, Any)),
            implements : \$folder::'',
            accepts : (args:.\1.\0 = first_unused_ord_pos::(args:.\0)),
            evaluates : (args:.\0 insert args:.\1.\1),
        )),

        shiftless_remove_at::Positional : (\Function : (
            returns : \$Positional,
            matches : (\$Positional, \$Integer),
            implements : \$folder::'',
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 = --first_unused_ord_pos::(args:.\0)),
            evaluates : (nonlast args:.\0),
        )),

        replace_or_insert_at::Positional : (\Function : (
            returns : \$Positional,
            matches : (Positional, (Integer, Any)),
            implements : \$folder::'',
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 <= first_unused_ord_pos::(args:.\0)),
            evaluates : (if args:.\0 .? (args:.\1.\0) then guard args:.\0 .:= (args:.\1.\0) else guard args:.\0 .+ (args:.\1.\0)),
        )),

        shiftless_maybe_remove_at::Positional : (\Function : (
            returns : \$Positional,
            matches : (\$Positional, \$Integer),
            implements : \$folder::'',
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 >= --first_unused_ord_pos::(args:.\0)),
            evaluates : (if args:.\1 = --first_unused_ord_pos::(args:.\0) then guard nonlast args:.\0 else args:.\0),
        )),

        to_Array::'' : (\Function : (
            virtual : True,
            returns : \$Array,
            matches : (\$Positional,),
        )),

        '~|' : (\Alias : ( of : \$to_Array, )),

        squish : (\Function : (
            returns : \$Positional,
            matches : (\$Positional,),
            evaluates : (args:.\0 map \(( group : args:.\0, member : False ))
                pipe nest map \(args:.\0.\group)),
        )),

        first_possible_ord_pos::'' : (\Function : (
            virtual : True,
            returns : \$Integer,
            matches : (\$Positional,),
        )),

        first_unused_ord_pos : (\Function : (
            returns : \$Integer,
            matches : (\$Positional,),
            evaluates : (first_possible_ord_pos::(args:.\0) + #args:.\0),
        )),

        first_ord_pos : (\Function : (
            returns : \$Integer,
            matches : (\$Positional,),
            accepts : (so args:.\0),
            evaluates : (first_possible_ord_pos::(args:.\0)),
        )),

        last_ord_pos : (\Function : (
            returns : \$Integer,
            matches : (\$Positional,),
            accepts : (so args:.\0),
            evaluates : (--first_unused_ord_pos::(args:.\0)),
        )),

        slice_n::'' : (\Function : (
            virtual : True,
            returns : \$Positional,
            matches : (\$Positional, \$Integer, \$NN_Integer),
            accepts : (args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\1 + args:.\2 <= first_unused_ord_pos::(args:.\0)),
        )),

        slice_range : (\Function : (
            returns : \$Positional,
            matches : (\$Positional, \$Integer, \$Integer),
            accepts : (so args:.\0 and args:.\1 >= first_possible_ord_pos::(args:.\0)
                and args:.\2 < first_unused_ord_pos::(args:.\0)),
            evaluates : (slice_n::(args:.\0, args:.\1, args:.\2 - args:.\1 + 1)),
        )),

        first : (\Function : (
            returns : \$Any,
            matches : (\$Positional,),
            accepts : (so args:.\0),
            evaluates : (args:.\0 . first_ord_pos::(args:.\0)),
        )),

        nonfirst : (\Function : (
            returns : \$Positional,
            matches : (\$Positional,),
            accepts : (so args:.\0),
            evaluates : (slice_range::(args:.\0, ++first_ord_pos::(args:.\0), last_ord_pos::(args:.\0))),
        )),

        last : (\Function : (
            returns : \$Any,
            matches : (\$Positional,),
            accepts : (so args:.\0),
            evaluates : (args:.\0 . last_ord_pos::(args:.\0)),
        )),

        nonlast : (\Function : (
            returns : \$Positional,
            matches : (\$Positional,),
            accepts : (so args:.\0),
            evaluates : (slice_range::(args:.\0, first_ord_pos::(args:.\0), --last_ord_pos::(args:.\0))),
        )),

        ord_pos_succ_all_matches::'' : (\Function : (
            virtual : True,
            returns : \$Integer,
            matches : (\$Positional, \$Positional),
            is_commutative : True,
        )),

`#########################################################################`

        Array::'' : (\Function : (
            is_type_definer : True,
            composes : {\$Positional},
            provides_default_for : {\$Positional},
            evaluates : \foundation::Array(),
            default : [],
        )),

        Array_C0 : (\Function : (
            is_type_definer : True,
            constant : [],
        )),

        Unicode_Aliases::'~∅' : (\Alias : ( of : \$Array_C0, )),

        in_order::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            evaluates : (
                i ::= args:.\0 ord_pos_succ_all_matches args:.\1;
              returns
                if not args:.\0 .? i then
                    e1 ::= True
                else if not args:.\1 .? i then
                    False
                else guard
                    e2 ::= args:.\0.i in_order args:.\1.i;

                e1 note "This is the case where LHS is a leading subsequence of or is equal to RHS.";
                e2 note "This will succeed iff in_order() is defined for the member type.";
            ),
        )),

        to_Boolean::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (args:.\0 != []),
        )),

        empty::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : ([]),
        )),

        substring_of::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_substring_of()),
        )),

        overlaps_string::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (evaluates args --> \foundation::Array_overlaps_string()),
        )),

        disjoint_string::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (evaluates args --> \foundation::Array_disjoint_string()),
        )),

        catenate::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            is_associative : True,
            identity : [],
            repeater : \$replicate::Array,
            evaluates : (evaluates args --> \foundation::Array_catenate()),
        )),

        replicate::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_replicate()),
        )),

        has_n::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_has_n()),
        )),

        multiplicity::Array : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Array, \$Any),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_multiplicity()),
        )),

        all_unique::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_all_unique()),
        )),

        unique::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_unique()),
        )),

        any::Array : (\Function : (
            returns : \$Boolean,
            matches : (\$Array, \$Signature),
            implements : \$folder::'',
            evaluates : (foundation::Array_any(args:.\0, Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        insert_n::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_insert_n()),
        )),

        remove_n::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_remove_n()),
        )),

        except::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            right_identity : [],
            evaluates : (evaluates args --> \foundation::Array_except()),
        )),

        intersect::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            is_associative : True,
            is_idempotent : True,
            evaluates : (evaluates args --> \foundation::Array_intersect()),
        )),

        union::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            is_idempotent : True,
            identity : [],
            evaluates : (evaluates args --> \foundation::Array_union()),
        )),

        exclusive::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            identity : [],
            evaluates : (evaluates args --> \foundation::Array_exclusive()),
        )),

        nest::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (evaluates args --> \foundation::Array_nest()),
        )),

        unnest::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (evaluates args --> \foundation::Array_unnest()),
        )),

        where::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Signature),
            implements : \$folder::'',
            evaluates : (foundation::Array_where(args:.\0, Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        map::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Function_Call_But_0),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_map()),
        )),

        reduce::Array : (\Function : (
            returns : \$Any,
            matches : (\$Array, \$Function_Call_But_0_1),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_reduce()),
        )),

        to_Set::Array : (\Function : (
            returns : \$Set,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (to_Set::(to_Bag args:.\0)),
        )),

        to_Bag::Array : (\Function : (
            returns : \$Bag,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_to_Bag()),
        )),

        count::Array : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_count()),
        )),

        order_using::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$Function_Call_But_0_1),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Array_order_using()),
        )),

        at::Array : (\Function : (
            returns : \$Any,
            matches : (\$Array, \$Integer_NN),
            implements : \$folder::'',
            accepts : (args:.\0 .? args:.\1),
            evaluates : (evaluates args --> \foundation::Array_at()),
        )),

        to_Array::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        first_possible_ord_pos::Array : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Array,),
            implements : \$folder::'',
            evaluates : (0),
        )),

        slice_n::Array : (\Function : (
            returns : \$Array,
            matches : (\$Array, \$NN_Integer, \$NN_Integer),
            implements : \$folder::'',
            accepts : (args:.\1 + args:.\2 <= #args:.\0),
            evaluates : (evaluates args --> \foundation::Array_slice_n()),
        )),

        ord_pos_succ_all_matches::Array : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Array, \$Array),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (evaluates args --> \foundation::Array_ord_pos_succ_all_matches()),
        )),

`#########################################################################`

        Setty : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

`#########################################################################`

        Set : (\Function : (
            is_type_definer : True,
            composes : {\$Discrete, \$Setty},
            provides_default_for : {\$Setty},
            evaluates : (\$Signature::Article_Match : (
                label : \Set,
                attrs : (
                    members : [\Bag::(), \all_unique::()],
                ),
            )),
            default : {},
        )),

        Set_C0 : (\Function : (
            is_type_definer : True,
            constant : {},
        )),

        Unicode_Aliases::'?∅' : (\Alias : ( of : \$Set_C0, )),

        to_Boolean::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (args:.\0 != {}),
        )),

        empty::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : ({}),
        )),

        singular::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (singular args:.\0:>.\members),
        )),

        only_member::Set : (\Function : (
            returns : \$Any,
            matches : (\$Set,),
            implements : \$folder::'',
            accepts : (singular args:.\0),
            evaluates : (only_member args:.\0:>.\members),
        )),

        has_n::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (has_n::(args:.\0:>.\members, args:.\1, args:.\2)),
        )),

        multiplicity::Set : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Set, \$Any),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\members multiplicity args:.\1),
        )),

        all_unique::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (True),
        )),

        unique::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        subset_of::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\members subset_of args:.\1:>.\members),
        )),

        same_members::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (args:.\0 = args:.\1),
        )),

        overlaps_members::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (args:.\0:>.\members overlaps_members args:.\1:>.\members),
        )),

        disjoint_members::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (args:.\0:>.\members disjoint_members args:.\1:>.\members),
        )),

        any::Set : (\Function : (
            returns : \$Boolean,
            matches : (\$Set, \$Signature),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\members any args:.\1),
        )),

        insert_n::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\0 has args:.\1 or args:.\2 = 0 then args:.\0
                else (\Set : (members : insert_n::(args:.\0:>.\members, args:.\1, 1),))),
        )),

        remove_n::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : ((\Set : (members : remove_n::(args:.\0:>.\members, args:.\1, args:.\2),))),
        )),

        member_plus::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {},
            evaluates : (args:.\0 union args:.\1),
        )),

        except::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            right_identity : {},
            evaluates : ((\Set : (members : args:.\0:>.\members except args:.\1:>.\members,))),
        )),

        intersect::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : ((\Set : (members : args:.\0:>.\members intersect args:.\1:>.\members,))),
        )),

        union::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {},
            evaluates : ((\Set : (members : args:.\0:>.\members union args:.\1:>.\members,))),
        )),

        exclusive::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Set),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            identity : {},
            evaluates : ((\Set : (members : args:.\0:>.\members exclusive args:.\1:>.\members,))),
        )),

        nest::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : ((\Set : (members : nest args:.\0:>.\members,))),
        )),

        unnest::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : ((\Set : (members : unnest args:.\0:>.\members,))),
        )),

        where::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Signature),
            implements : \$folder::'',
            evaluates : ((\Set : (members : args:.\0:>.\members where args:.\1,))),
        )),

        map::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set, \$Function_Call_But_0),
            implements : \$folder::'',
            evaluates : ((\Set : (members : args:.\0:>.\members map args:.\1,))),
        )),

        reduce::Set : (\Function : (
            returns : \$Any,
            matches : (\$Set, \$Function_Call_But_0_1),
            implements : \$folder::'',
            evaluates : ((\Set : (members : args:.\0:>.\members reduce args:.\1,))),
        )),

        to_Set::Set : (\Function : (
            returns : \$Set,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        to_Bag::Set : (\Function : (
            returns : \$Bag,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\members),
        )),

        count::Set : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (count args:.\0:>.\members),
        )),

        unique_count::Set : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Set,),
            implements : \$folder::'',
            evaluates : (count args:.\0),
        )),

        order_using::Set : (\Function : (
            returns : \$Array,
            matches : (\$Set, \$Function_Call_But_0_1),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\members order_using args:.\1),
        )),

`#########################################################################`

        Bag : (\Function : (
            is_type_definer : True,
            composes : {\$Discrete},
            evaluates : \foundation::Bag(),
            default : {0:0},
        )),

        Bag_C0 : (\Function : (
            is_type_definer : True,
            constant : {0:0},
        )),

        Unicode_Aliases::'+∅' : (\Alias : ( of : \$Bag_C0, )),

        to_Boolean::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : (args:.\0 != {0:0}),
        )),

        empty::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : ({0:0}),
        )),

        singular::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_singular()),
        )),

        only_member::Bag : (\Function : (
            returns : \$Any,
            matches : (\$Bag,),
            implements : \$folder::'',
            accepts : (singular args:.\0),
            evaluates : (evaluates args --> \foundation::Bag_only_member()),
        )),

        has_n::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_has_n()),
        )),

        multiplicity::Bag : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Bag, \$Any),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_multiplicity()),
        )),

        all_unique::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_all_unique()),
        )),

        unique::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_unique()),
        )),

        subset_of::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_subset_of()),
        )),

        same_members::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (args:.\0 = args:.\1),
        )),

        overlaps_members::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (evaluates args --> \foundation::Bag_overlaps_members()),
        )),

        disjoint_members::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (evaluates args --> \foundation::Bag_disjoint_members()),
        )),

        any::Bag : (\Function : (
            returns : \$Boolean,
            matches : (\$Bag, \$Signature),
            implements : \$folder::'',
            evaluates : (foundation::Bag_any(args:.\0, Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        insert_n::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_insert_n()),
        )),

        remove_n::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Any, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_remove_n()),
        )),

        member_plus::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            identity : {0:0},
            evaluates : (evaluates args --> \foundation::Bag_member_plus()),
        )),

        except::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            right_identity : {0:0},
            evaluates : (evaluates args --> \foundation::Bag_except()),
        )),

        intersect::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : (evaluates args --> \foundation::Bag_intersect()),
        )),

        union::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : {0:0},
            evaluates : (evaluates args --> \foundation::Bag_union()),
        )),

        exclusive::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Bag),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            identity : {0:0},
            evaluates : (evaluates args --> \foundation::Bag_exclusive()),
        )),

        nest::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (evaluates args --> \foundation::Bag_nest()),
        )),

        unnest::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (evaluates args --> \foundation::Bag_unnest()),
        )),

        where::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Signature),
            implements : \$folder::'',
            evaluates : (foundation::Bag_where(args:.\0, Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        map::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag, \$Function_Call_But_0),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_map()),
        )),

        reduce::Bag : (\Function : (
            returns : \$Any,
            matches : (\$Bag, \$Function_Call_But_0_1),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_reduce()),
        )),

        to_Set::Bag : (\Function : (
            returns : \$Set,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : ((\Set : (members : unique args:.\0,))),
        )),

        to_Bag::Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        count::Bag : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_count()),
        )),

        unique_count::Bag : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Bag,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_unique_count()),
        )),

        order_using::Bag : (\Function : (
            returns : \$Array,
            matches : (\$Bag, \$Function_Call_But_0_1),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Bag_order_using()),
        )),

`#########################################################################`

        Attributive : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

        has_any_attrs::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Attributive,),
        )),

        '?$' : (\Alias : ( of : \$has_any_attrs, )),

        is_nullary : (\Function : (
            negates : \$has_any_attrs,
        )),

        '!?$' : (\Alias : ( of : \$is_nullary, )),

        nullary::'' : (\Function : (
            virtual : True,
            returns : \$Attributive,
            matches : (\$Attributive,),
        )),

        is_unary::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Attributive,),
        )),

        degree::'' : (\Function : (
            virtual : True,
            returns : \$Integer_NN,
            matches : (\$Attributive,),
        )),

        '#$' : (\Alias : ( of : \$degree, )),

        heading::'' : (\Function : (
            virtual : True,
            returns : \$Heading,
            matches : (\$Attributive,),
        )),

        '$' : (\Alias : ( of : \$heading, )),

        subheading_of : (\Function : (
            returns : \$Boolean,
            matches : (\$Attributive, \$Attributive),
            evaluates : (foundation::Tuple_subheading_of($args:.\0, $args:.\1)),
        )),

        Unicode_Aliases::'⊆$' : (\Alias : ( of : \$subheading_of, )),

        superheading_of : (\Function : (
            commutes : \$subheading_of,
        )),

        has_subheading : (\Alias : ( of : \$superheading_of, )),
        '$?'           : (\Alias : ( of : \$superheading_of, )),

        Unicode_Aliases::'⊇$' : (\Alias : ( of : \$superheading_of, )),

        same_heading : (\Function : (
            returns : \$Boolean,
            matches : (\$Attributive, \$Attributive),
            is_commutative : True,
            evaluates : ($args:.\0 = $args:.\1),
        )),

        '=$' : (\Alias : ( of : \$same_heading, )),

        proper_subheading_or_superheading : (\Function : (
            returns : \$Boolean,
            matches : (\$Attributive, \$Attributive),
            is_commutative : True,
            evaluates : ($args:.\0 != $args:.\1 and (args:.\0 subheading_or_superheading args:.\1)),
        )),

        subheading_or_superheading : (\Function : (
            returns : \$Boolean,
            matches : (\$Attributive, \$Attributive),
            is_commutative : True,
            evaluates : ((args:.\0 subheading_of args:.\1) or (args:.\0 superheading_of args:.\1)),
        )),

        overlaps_heading : (\Function : (
            returns : \$Boolean,
            matches : (\$Attributive, \$Attributive),
            is_commutative : True,
            evaluates : (foundation::Tuple_overlaps_heading($args:.\0, $args:.\1)),
        )),

        disjoint_heading : (\Function : (
            returns : \$Boolean,
            matches : (\$Attributive, \$Attributive),
            is_commutative : True,
            evaluates : (foundation::Tuple_disjoint_heading($args:.\0, $args:.\1)),
        )),

        except_heading : (\Function : (
            returns : \$Heading,
            matches : (\$Attributive, \$Attributive),
            evaluates : (foundation::Tuple_except_heading($args:.\0, $args:.\1)),
        )),

        Unicode_Aliases::'∖$' : (\Alias : ( of : \$except_heading, )),

        intersect_heading : (\Function : (
            returns : \$Heading,
            matches : (\$Attributive, \$Attributive),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            evaluates : (foundation::Tuple_intersect_heading($args:.\0, $args:.\1)),
        )),

        Unicode_Aliases::'∩$' : (\Alias : ( of : \$intersect_heading, )),

        union_heading : (\Function : (
            returns : \$Heading,
            matches : (\$Attributive, \$Attributive),
            is_associative : True,
            is_commutative : True,
            is_idempotent : True,
            identity : (),
            evaluates : (foundation::Tuple_union_heading($args:.\0, $args:.\1)),
        )),

        Unicode_Aliases::'∪$' : (\Alias : ( of : \$union_heading, )),

        exclusive : (\Function : (
            returns : \$Heading,
            matches : (\$Attributive, \$Attributive),
            is_associative : True,
            is_commutative : True,
            identity : (),
            evaluates : (foundation::Tuple_exclusive_heading($args:.\0, $args:.\1)),
        )),

        symm_diff_heading : (\Alias : ( of : \$exclusive_heading, )),

        Unicode_Aliases::'∆$' : (\Alias : ( of : \$exclusive_heading, )),

        rename::'' : (\Function : (
            virtual : True,
            returns : \$Attributive,
            matches : (\$Attributive, \$Renaming),
            accepts : (...),
        )),

        '$:=' : (\Alias : ( of : \$rename, )),

        Unicode_Aliases::'ρ' : (\Alias : ( of : \$rename, )),

        renaming : (\Function : (
            commutes : \$rename,
        )),

        can_project_matching::'' : (\Function : (
            virtual : True,
            returns : \$Boolean,
            matches : (\$Attributive, \$Structural),
        )),

        '%=?' : (\Alias : ( of : \$can_project_matching, )),

        on::'' : (\Function : (
            virtual : True,
            returns : \$Attributive,
            matches : (\$Attributive, \$Heading),
            accepts : (args:.\0 $? args:.\1),
        )),

        project : (\Alias : ( of : \$on, )),
        '%='    : (\Alias : ( of : \$on, )),

        Unicode_Aliases::'π' : (\Alias : ( of : \$on, )),

        from : (\Function : (
            commutes : \$on,
        )),

        maybe_on : (\Function : (
            returns : \$Attributive,
            matches : (\$Attributive, \$Heading),
            evaluates : (args:.\0 on (args:.\0 intersect_heading args:.\1)),
        )),

        '%!' : (\Alias : ( of : \$maybe_on, )),

        update::'' : (\Function : (
            virtual : True,
            returns : \$Attributive,
            matches : (\$Attributive, \$Structural),
            accepts : (args:.\0 $? args:.\1),
        )),

        '%:=' : (\Alias : ( of : \$update, )),

        extend::'' : (\Function : (
            virtual : True,
            returns : \$Attributive,
            matches : (\$Attributive, \$Structural),
            accepts : (args:.\0 disjoint_heading args:.\1),
        )),

        '%+' : (\Alias : ( of : \$extend, )),

        but : (\Function : (
            returns : \$Attributive,
            matches : (\$Attributive, \$Heading),
            accepts : (args:.\0 $? args:.\1),
            evaluates : (args:.\0 on (args:.\0 except_heading args:.\1)),
        )),

        project_all_but : (\Alias : ( of : \$but, )),
        '%-'            : (\Alias : ( of : \$but, )),

        update_or_extend : (\Function : (
            returns : \$Attributive,
            matches : (\$Attributive, \$Structural),
            evaluates : (args:.\0 on (args:.\0 except_heading args:.\1) extend args:.\1),
        )),

        '%=+' : (\Alias : ( of : \$update_or_extend, )),

        maybe_but : (\Function : (
            returns : \$Attributive,
            matches : (\$Attributive, \$Heading),
            evaluates : (args:.\0 but (args:.\0 intersect_heading args:.\1)),
        )),

        '%?-' : (\Alias : ( of : \$maybe_but, )),

`#########################################################################`

        Structural : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Attributive, \$Accessible},
            provides_default_for : {\$Attributive, \$Accessible},
        )),

        can_project_matching::Structural : (\Function : (
            returns : \$Boolean,
            matches : (\$Structural, \$Structural),
            implements : \$folder::'',
            evaluates : (args:.\0 $? args:.\1 and_then guard args:.\0 %= $args:.\1 = args:.\1),
        )),

        has_any_at::Structure : (\Function : (
            returns : \$Boolean,
            matches : (\$Structure, \$Attr_Name),
            implements : \$folder::'',
            evaluates : (args:.\0 $? args:.\1),
        )),

        has_mapping_at::Structural : (\Function : (
            returns : \$Boolean,
            matches : (Structural, (Attr_Name, Any)),
            implements : \$folder::'',
            evaluates : (args:.\0 .? (args:.\1.\0) and_then guard args:.\0.(args:.\1.\0) = (args:.\1.\1)),
        )),

        mapping_at::Structural : (\Function : (
            returns : (\$Attr_Name, \$Any),
            matches : (\$Structural, \$Attr_Name),
            implements : \$folder::'',
            accepts : (args:.\0 .? args:.\1),
            evaluates : ((args:.\1, args:.\0.args:.\1)),
        )),

        maybe_at::Structural : (\Function : (
            returns : \$Any,
            matches : (\$Structural, \$Attr_Name),
            implements : \$folder::'',
            evaluates : (if args:.\0 .? args:.\1 then guard args:.\0.args:.\1 else \!No_Such_Attr_Name),
        )),

        replace_at::Structure : (\Function : (
            returns : \$Structure,
            matches : (Structure, (Attr_Name, Any)),
            implements : \$folder::'',
            accepts : (args:.\0 .? (args:.\1.\0)),
            evaluates : (args:.\0 update D1::(args:.\1)),
        )),

        shiftless_insert_at::Structure : (\Function : (
            returns : \$Structure,
            matches : (Structure, (Attr_Name, Any)),
            implements : \$folder::'',
            accepts : (not args:.\0 .? (args:.\1.\0)),
            evaluates : (args:.\0 extend D1::(args:.\1)),
        )),

        shiftless_remove_at::Structure : (\Function : (
            returns : \$Structure,
            matches : (\$Structure, \$Attr_Name),
            implements : \$folder::'',
            accepts : (args:.\0 .? args:.\1),
            evaluates : (args:.\0 but args:.\1),
        )),

        replace_or_insert_at::Structural : (\Function : (
            returns : \$Structural,
            matches : (Structural, (Attr_Name, Any)),
            implements : \$folder::'',
            evaluates : (args:.\0 update_or_extend D1::(args:.\1)),
        )),

        shiftless_maybe_remove_at::Structural : (\Function : (
            returns : \$Structural,
            matches : (\$Structural, \$Attr_Name),
            implements : \$folder::'',
            evaluates : (args:.\0 maybe_but args:.\1),
        )),

        to_Tuple::'' : (\Function : (
            virtual : True,
            returns : \$Tuple,
            matches : (\$Structural,),
        )),

        '%' : (\Alias : ( of : \$to_Tuple, )),

`#########################################################################`

        Tuple::'' : (\Function : (
            is_type_definer : True,
            composes : {\$Structural},
            provides_default_for : {\$Structural},
            evaluates : \foundation::Tuple(),
            default : (),
        )),

        Tuple_D0 : (\Function : (
            is_type_definer : True,
            constant : (),
        )),

        Tuple_D1 : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \is_unary::()],
            default : (False,),
        )),

        D1 : (\Function : (
            returns : \$Tuple_D1,
            matches : (\$Attr_Name, \$Any),
            evaluates : (evaluates args --> \foundation::Tuple_D1_select()),
        )),

        has_any_attrs::Tuple : (\Function : (
            returns : \$Boolean,
            matches : (\$Tuple,),
            implements : \$folder::'',
            evaluates : (args:.\0 != ()),
        )),

        nullary::Tuple : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple,),
            implements : \$folder::'',
            evaluates : (()),
        )),

        is_unary::Tuple : (\Function : (
            returns : \$Boolean,
            matches : (\$Tuple,),
            implements : \$folder::'',
            evaluates : (degree::(args:.\0) = 1),
        )),

        degree::Tuple : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Tuple,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Tuple_degree()),
        )),

        heading::Tuple : (\Function : (
            returns : \$Heading,
            matches : (\$Tuple,),
            implements : \$folder::'',
            evaluates : (evaluates args --> \foundation::Tuple_heading()),
        )),

        rename::Tuple : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple, \$Renaming),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (evaluates args --> \foundation::Tuple_rename()),
        )),

        on::Tuple : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple, \$Heading),
            implements : \$folder::'',
            accepts : (args:.\0 $? args:.\1),
            evaluates : (evaluates args --> \foundation::Tuple_on()),
        )),

        update::Tuple : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple, \$Tuple),
            implements : \$folder::'',
            accepts : (args:.\0 $? args:.\1),
            evaluates : (evaluates args --> \foundation::Tuple_update()),
        )),

        extend::Tuple : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple, \$Tuple),
            implements : \$folder::'',
            accepts : (args:.\0 disjoint_heading args:.\1),
            is_associative : True,
            is_commutative : True,
            identity : (),
            evaluates : (evaluates args --> \foundation::Tuple_extend()),
        )),

        at::Tuple : (\Function : (
            returns : \$Any,
            matches : (\$Tuple, \$Attr_Name),
            implements : \$folder::'',
            accepts : (args:.\0 .? args:.\1),
            evaluates : (args:.\0 :. (args:.\1)),
        )),

        to_Tuple::Tuple : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple,),
            implements : \$folder::'',
            evaluates : (args:.\0),
        )),

        any_attrs : (\Function : (
            returns : \$Boolean,
            matches : (\$Tuple, \$Signature),
            evaluates : (foundation::Tuple_any_attrs(args:.\0, Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        none_of_attrs : (\Function : (
            negates : \$any_attrs,
        )),

        all_attrs : (\Function : (
            returns : \$Boolean,
            matches : (\$Tuple, \$Signature),
            evaluates : (args:.\0 none_of_attrs \not_is_a::( 1: args:.\1 )),
        )),

        not_all_attrs : (\Function : (
            negates : \$all_attrs,
        )),

        all_attr_assets : (\Function : (
            returns : \$Boolean,
            matches : (\$Tuple, \$Signature),
            evaluates : (args:.\0 all_attrs \(evaluates args:.\1 <-- (args:.\0.\asset,))
                <-- (1 : Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        attrs_where : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple, \$Signature),
            evaluates : (foundation::Tuple_attrs_where(args:.\0, Signature_to_Function_Call_But_0::(args:.\1))),
        )),

        attrs_map : (\Function : (
            returns : \$Tuple,
            matches : (\$Tuple, \$Function_Call_But_0),
            evaluates : (evaluates args --> \foundation::Tuple_attrs_map()),
        )),

        attrs_reduce : (\Function : (
            returns : \$Any,
            matches : (\$Tuple, \$Function_Call_But_0_1),
            evaluates : (evaluates args --> \foundation::Tuple_attrs_reduce()),
        )),

`#########################################################################`

        Relational : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Unionable, \$Attributive},
        )),

        to_Boolean::Relational : (\Function : (
            returns : \$Boolean,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (? |args:.\0),
        )),

        empty::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (select_Relational::( like: args:.\0, heading: $args:.\0, body: empty |args:.\0 )),
        )),

        singular::Relational : (\Function : (
            returns : \$Boolean,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (singular |args:.\0),
        )),

        only_member::Relational : (\Function : (
            returns : \$Structural,
            matches : (\$Relational,),
            implements : \$folder::'',
            accepts : (singular args:.\0),
            evaluates : (only_member |args:.\0),
        )),

        has_n::Relational : (\Function : (
            returns : {\$Boolean, \$Not_Same_Heading},
            matches : (\$Relational, \$Structural, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\0 =$ args:.\1 then guard has_n::(|args:.\0, args:.\1, args:.\2)
                else \!Not_Same_Heading),
        )),

        multiplicity::Relational : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Relational, \$Structural),
            implements : \$folder::'',
            evaluates : (|args:.\0 multiplicity args:.\1),
        )),

        all_unique::Relational : (\Function : (
            returns : \$Boolean,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (all_unique |args:.\0),
        )),

        unique::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (select_Relational::( like: args:.\0, heading: $args:.\0, body: unique |args:.\0 )),
        )),

        subset_of::Relational : (\Function : (
            returns : {\$Boolean, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            evaluates : (if args:.\0 =$ args:.\1 then guard |args:.\0 subset_of |args:.\1
                else \!Not_Same_Heading),
        )),

        same_members::Relational : (\Function : (
            returns : {\$Boolean, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (if args:.\0 =$ args:.\1 then guard |args:.\0 same_members |args:.\1
                else \!Not_Same_Heading),
        )),

        overlaps_members::Relational : (\Function : (
            returns : {\$Boolean, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (if args:.\0 =$ args:.\1 then guard |args:.\0 overlaps_members |args:.\1
                else \!Not_Same_Heading),
        )),

        disjoint_members::Relational : (\Function : (
            returns : {\$Boolean, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            is_commutative : True,
            evaluates : (if args:.\0 =$ args:.\1 then guard |args:.\0 disjoint_members |args:.\1
                else \!Not_Same_Heading),
        )),

        any::Relational : (\Function : (
            returns : \$Boolean,
            matches : (\$Relational, \$Signature),
            implements : \$folder::'',
            evaluates : (|args:.\0 any args:.\1),
        )),

        insert_n::Relational : (\Function : (
            returns : {\$Relational, \$Not_Same_Heading},
            matches : (\$Relational, \$Structural, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\0 =$ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: $args:.\0, body: insert_n::(|args:.\0, args:.\1, args:.\2) )
                else \!Not_Same_Heading),
        )),

        remove_n::Relational : (\Function : (
            returns : {\$Relational, \$Not_Same_Heading},
            matches : (\$Relational, \$Structural, \$Integer_NN),
            implements : \$folder::'',
            evaluates : (if args:.\0 =$ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: $args:.\0, body: remove_n::(|args:.\0, args:.\1, args:.\2) )
                else \!Not_Same_Heading),
        )),

        member_plus::Relational : (\Function : (
            returns : {\$Relational, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            is_associative : True,
            evaluates : (if args:.\0 =$ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: $args:.\0, body: |args:.\0 member_plus |args:.\1 )
                else \!Not_Same_Heading),
        )),

        except::Relational : (\Function : (
            returns : {\$Relational, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            evaluates : (if args:.\0 =$ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: $args:.\0, body: |args:.\0 except |args:.\1 )
                else \!Not_Same_Heading),
        )),

        intersect::Relational : (\Function : (
            returns : {\$Relational, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            is_associative : True,
            is_idempotent : True,
            evaluates : (if args:.\0 =$ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: $args:.\0, body: |args:.\0 intersect |args:.\1 )
                else \!Not_Same_Heading),
        )),

        union::Relational : (\Function : (
            returns : {\$Relational, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            is_idempotent : True,
            evaluates : (if args:.\0 =$ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: $args:.\0, body: |args:.\0 union |args:.\1 )
                else \!Not_Same_Heading),
        )),

        exclusive::Relational : (\Function : (
            returns : {\$Relational, \$Not_Same_Heading},
            matches : (\$Relational, \$Relational),
            implements : \$folder::'',
            is_associative : True,
            is_commutative : True,
            evaluates : (if args:.\0 =$ args:.\1 then guard select_Relational::
                    ( like: args:.\0, heading: $args:.\0, body: |args:.\0 exclusive |args:.\1 )
                else \!Not_Same_Heading),
        )),

        nest::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (...),
        )),

        unnest::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational,),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (...),
        )),

        where::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational, \$Signature),
            implements : \$folder::'',
            evaluates : (select_Relational::( like: args:.\0, heading: $args:.\0, body: |args:.\0 where args:.\1 )),
        )),

        map::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational, \$Function_Call_But_0),
            implements : \$folder::'',
            evaluates : (...),
        )),

        reduce::Relational : (\Function : (
            returns : \$Any,
            matches : (\$Relational, \$Function_Call_But_0_1),
            implements : \$folder::'',
            evaluates : (|args:.\0 reduce args:.\1),
        )),

        has_any_attrs::Relational : (\Function : (
            returns : \$Boolean,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : ($args:.\0 != ()),
        )),

        nullary::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (args:.\0 on ()),
        )),

        is_unary::Relational : (\Function : (
            returns : \$Boolean,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (is_unary $args:.\0),
        )),

        degree::Relational : (\Function : (
            returns : \$Integer_NN,
            matches : (\$Relational,),
            implements : \$folder::'',
            evaluates : (degree $args:.\0),
        )),

        rename::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational, \$Renaming),
            implements : \$folder::'',
            accepts : (...),
            evaluates : (select_Relational::( like: args:.\0, heading: $args:.\0 rename args:.\1,
                body: |args:.\0 map \rename::( 1: args:.\1 ) )),
        )),

        can_project_matching::Relational : (\Function : (
            returns : \$Boolean,
            matches : (\$Relational, \$Structural),
            implements : \$folder::'',
            evaluates : (args:.\0 $? args:.\1
                and_then guard |args:.\0 all \(args:.\0 %= $args:.\1 = args:.\1) <-- (1 : args:.\1,)),
        )),

        on::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational, \$Heading),
            implements : \$folder::'',
            accepts : (args:.\0 $? args:.\1),
            evaluates : (select_Relational::( like: args:.\0, heading: $args:.\0 on args:.\1,
                body: |args:.\0 map \on::( 1: args:.\1 ) )),
        )),

        update::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational, \$Structural),
            implements : \$folder::'',
            accepts : (args:.\0 $? args:.\1),
            evaluates : (select_Relational::( like: args:.\0, heading: $args:.\0,
                body: |args:.\0 map \update::( 1: args:.\1 ) )),
        )),

        extend::Relational : (\Function : (
            returns : \$Relational,
            matches : (\$Relational, \$Structural),
            implements : \$folder::'',
            accepts : (args:.\0 disjoint_heading args:.\1),
            evaluates : (select_Relational::( like: args:.\0, heading: $args:.\0 extend args:.\1,
                body: |args:.\0 map \extend::( 1: args:.\1 ) )),
        )),

        body::'' : (\Function : (
            virtual : True,
            returns : \$Unionable,
            matches : (\$Relational,),
        )),

        '|' : (\Alias : ( of : \$body, )),

        select_Relational::'' : (\Function : (
            virtual : True,
            returns : {\$Relational, \$...},
            matches : (like : \$Relational, heading : \$Heading, body : \$Unionable),
        )),

`#########################################################################`

        Tuple_Array : (\Function : (
            is_type_definer : True,
            composes : {\$Relational, \$Positional},
            evaluates : (\$Signature::Article_Match : (
                label : \Tuple_Array,
                attrs : [
                    (
                        heading : \Heading::(),
                        body : [\Array::(), \all::( 1: \Tuple::() )],
                    ),
                    \(args:.\0:.\body all \($args:.\0 = args:.\1) <-- (1: args:.\0:.\heading,)),
                ],
            )),
            default : \~%(),
        )),

        Tuple_Array_D0C0 : (\Function : (
            is_type_definer : True,
            constant : \~%(),
        )),

        Tuple_Array_D0C1 : (\Function : (
            is_type_definer : True,
            constant : \~%[()],
        )),

        heading::Tuple_Array : (\Function : (
            returns : \$Heading,
            matches : (\$Tuple_Array,),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\heading),
        )),

        body::Tuple_Array : (\Function : (
            returns : \$Array,
            matches : (\$Tuple_Array,),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\body),
        )),

        select_Relational::Tuple_Array : (\Function : (
            returns : {\$Relational, \$...},
            matches : (like : \$Tuple_Array, heading : \$Heading, body : \$Array),
            implements : \$folder::'',
            evaluates : ((\Tuple_Array : (args %= \$(heading,body)))),
        )),

`#########################################################################`

        Relation : (\Function : (
            is_type_definer : True,
            composes : {\$Relational, \$Discrete, \$Setty},
            provides_default_for : {\$Relational},
            evaluates : (\$Signature::Article_Match : (
                label : \Relation,
                attrs : [
                    (
                        heading : \Heading::(),
                        body : [\Set::(), \all::( 1: \Tuple::() )],
                    ),
                    \(args:.\0:.\body all \($args:.\0 = args:.\1) <-- (1: args:.\0:.\heading,)),
                ],
            )),
            default : \?%(),
        )),

        Relation_D0C0 : (\Function : (
            is_type_definer : True,
            constant : \?%(),
        )),

        Relation_D0C1 : (\Function : (
            is_type_definer : True,
            constant : \?%{()},
        )),

        heading::Relation : (\Function : (
            returns : \$Heading,
            matches : (\$Relation,),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\heading),
        )),

        body::Relation : (\Function : (
            returns : \$Set,
            matches : (\$Relation,),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\body),
        )),

        select_Relational::Relation : (\Function : (
            returns : {\$Relational, \$...},
            matches : (like : \$Relation, heading : \$Heading, body : \$Set),
            implements : \$folder::'',
            evaluates : ((\Relation : (args %= \$(heading,body)))),
        )),

`#########################################################################`

        Tuple_Bag : (\Function : (
            is_type_definer : True,
            composes : {\$Relational, \$Discrete},
            evaluates : (\$Signature::Article_Match : (
                label : \Tuple_Bag,
                attrs : [
                    (
                        heading : \Heading::(),
                        body : [\Bag::(), \all::( 1: \Tuple::() )],
                    ),
                    \(args:.\0:.\body all \($args:.\0 = args:.\1) <-- (1: args:.\0:.\heading,)),
                ],
            )),
            default : \+%(),
        )),

        Tuple_Bag_D0C0 : (\Function : (
            is_type_definer : True,
            constant : \+%(),
        )),

        Tuple_Bag_D0C1 : (\Function : (
            is_type_definer : True,
            constant : \+%{()},
        )),

        heading::Tuple_Bag : (\Function : (
            returns : \$Heading,
            matches : (\$Tuple_Bag,),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\heading),
        )),

        body::Tuple_Bag : (\Function : (
            returns : \$Bag,
            matches : (\$Tuple_Bag,),
            implements : \$folder::'',
            evaluates : (args:.\0:>.\body),
        )),

        select_Relational::Tuple_Bag : (\Function : (
            returns : {\$Relational, \$...},
            matches : (like : \$Tuple_Bag, heading : \$Heading, body : \$Bag),
            implements : \$folder::'',
            evaluates : ((\Tuple_Bag : (args %= \$(heading,body)))),
        )),

`#########################################################################`

        Intervalish : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Homogeneous},
        )),

`#########################################################################`

        Interval : (\Function : (
            is_type_definer : True,
            composes : {\$Intervalish, \$Setty},
            evaluates : (\$Signature::Article_Match : (
                label : \Interval,
                attrs : \Interval_Attrs::(),
            )),
            default : (\!Before_All_Others..\!After_All_Others),
        )),

        Interval_Attrs : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), ...],
        )),

`#########################################################################`

        Unionable_Intervalish : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Intervalish, \$Unionable},
        )),

`#########################################################################`

        Interval_Set : (\Function : (
            is_type_definer : True,
            composes : {\$Unionable_Intervalish, \$Setty},
            evaluates : (\$Signature::Article_Match : (
                label : \Interval_Set,
                attrs : (
                    members : [\Interval_Bag::(), \all_unique::()],
                ),
            )),
            default : ...,
        )),

`#########################################################################`

        Interval_Bag : (\Function : (
            is_type_definer : True,
            composes : {\$Unionable_Intervalish},
            evaluates : (\$Signature::Article_Match : (
                label : \Interval_Bag,
                attrs : (
                    members : [\Tuple_Bag::(), ...],
                ),
            )),
            default : ...,
        )),

`#########################################################################`

        Quantitative : (\Function : (
            is_type_definer : True,
            is_generalization : True,
            composes : {\$Numerical},
        )),

`#########################################################################`

        Quantity : (\Function : (
            is_type_definer : True,
            composes : {\$Quantitative},
            evaluates : (\$Signature::Article_Match : (
                label : \Quantity,
                attrs : (
                    0 : [\Relation::(), ...],
                ),
            )),
            default : ...,
        )),

`#########################################################################`

        Article : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::Article(),
            default : (False : ()),
        )),

`#########################################################################`

        Handle : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::Handle(),
        )),

        Variable : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::Variable(),
        )),

        Process : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::Process(),
        )),

        Stream : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::Stream(),
        )),

        External::'' : (\Function : (
            is_type_definer : True,
            evaluates : \foundation::External(),
        )),

        External::call_function : (\Function : (
            returns : \$Any,
            matches : (\$Any,),
            evaluates : (evaluates \foundation::External_call_function() <-- args),
        )),

`#########################################################################`

        Excuse : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \Excuse,
                attrs : (
                    0 : \Any(),
                ),
            )),
            default : \!No_Reason,
        )),

        No_Reason : (\Function : (
            is_type_definer : True,
            constant : \!No_Reason,
        )),

        Before_All_Others : (\Function : (
            is_type_definer : True,
            composes : {\$Orderable},
            constant : \!Before_All_Others,
        )),

        After_All_Others : (\Function : (
            is_type_definer : True,
            composes : {\$Orderable},
            constant : \!After_All_Others,
        )),

        Div_By_Zero : (\Function : (
            is_type_definer : True,
            constant : \!Div_By_Zero,
        )),

        Zero_To_The_Zero : (\Function : (
            is_type_definer : True,
            constant : \!Zero_To_The_Zero,
        )),

        No_Empty_Value : (\Function : (
            is_type_definer : True,
            constant : \!No_Empty_Value,
        )),

        No_Such_Ord_Pos : (\Function : (
            is_type_definer : True,
            constant : \!No_Such_Ord_Pos,
        )),

        No_Such_Attr_Name : (\Function : (
            is_type_definer : True,
            constant : \!No_Such_Attr_Name,
        )),

        Not_Same_Heading : (\Function : (
            is_type_definer : True,
            constant : \!Not_Same_Heading,
        )),

        coalesce : (\Function : (
            returns : \$Any,
            matches : (\$Any, \$Any),
            is_associative : True,
            is_idempotent : True,
            left_identity : \!No_Reason,
            evaluates : (if Excuse args:.\0 then args:.\1 else args:.\0),
        )),

        '??' : (\Alias : ( of : \$coalesce, )),

        anticoalesce : (\Function : (
            returns : \$Any,
            matches : (\$Any, \$Any),
            is_associative : True,
            is_idempotent : True,
            left_identity : True,
            evaluates : (if Excuse args:.\0 then args:.\0 else args:.\1),
        )),

        '!!' : (\Alias : ( of : \$anticoalesce, )),

`#########################################################################`

        Package : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \Package,
                attrs : (
                    identity : \Package::Identity::(),
                    foundation : \Package::Foundation::(),
                    uses : \Package::Uses_Map::(),
                    entry : \Package::Entry_Point::(),
                    floating : \Package::Floating::(),
                    materials : \Package::Folder::(),
                ),
            )),
            default : ...,
        )),

        Package::Identity : (\Function : (
            is_type_definer : True,
            evaluates : (
                package_base_name : \Package::Base_Name::(),
                authority : \Package::Canon_Authority::(),
                version_number : \Package::Canon_Version_Number::(),
            ),
        )),

        Package::Foundation : (\Function : (
            is_type_definer : True,
            evaluates : (
                authority : \Package::Canon_Authority::(),
                version_number : \Package::Canon_Version_Number::(),
            ),
        )),

        Package::Base_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Nesting::(), \so::(), \'∌'::( 1: \'' )],
        )),

        Package::Canon_Authority : (\Function : (
            is_type_definer : True,
            evaluates : [\Text::(), \so::()],
        )),

        Package::Canon_Version_Number : (\Function : (
            is_type_definer : True,
            evaluates : [\Text::(), \so::()],
        )),

        Package::Uses_Map : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \'.!?'::( 1: \'' ),
                \all_attr_assets::( 1: \Package::Uses_Item() )],
        )),

        Package::Uses_Item : (\Function : (
            is_type_definer : True,
            evaluates : (
                package_base_name : \Package::Base_Name::(),
                authority : \Package::Canon_Authority::(),
                version_number : \Package::Canon_Version_Number::(),
            ),
        )),

        Package::Entry_Point : (\Function : (
            is_type_definer : True,
            evaluates : \Absolute_Name::(),
        )),

        Package::Floating : (\Function : (
            is_type_definer : True,
            evaluates : [\Set::(), \all::( 1: \Absolute_Name::() )],
        )),

        Package::Folder : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(),
                \all_attr_assets::( 1: {\Package::Folder(), \Material::()} )],
        )),

        Material : (\Function : (
            is_type_definer : True,
            evaluates : {\$Alias, \$Function, \$Procedure},
            default : ...,
        )),

        Alias : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \Alias,
                attrs : (
                    of : \Identity_Identifier(),
                ),
            )),
            default : ((\Alias : (of : Identity_Identifier::(),))),
        )),

        Function : (\Function : (
            is_type_definer : True,
            evaluates : (
                function ::= args:.\0;

                returns Article function
                    and_then guard function:< = \Function
                    and_then guard when_well_formed_Article;

                traits ::= function:>;

                when_well_formed_Article ::=
                    if traits .:? (\is_type_definer, True) then
                        if traits .:? (\is_generalization, True) then
                            when_generalized_type_definer
                        else if traits.?\constant then
                            when_singleton_type_definer
                        else
                            when_regular_type_definer
                    else
                        when_regular_function;

                when_generalized_type_definer ::=
                    traits is_a (\$Signature::Tuple_Attrs_Match : (attrs : (
                        is_type_definer : (type : \True::(),),
                        is_generalization : (type : \True::(),),
                        default : (type : \Expression::(), optional : True),
                    ) %+ type_specialization_attrs_template,))
                    and_then type_specialization_attrs_constraint;

                when_singleton_type_definer ::=
                    traits is_a (\$Signature::Tuple_Attrs_Match : (attrs : (
                        is_type_definer : (type : \True::(),),
                        is_generalization : (type : \False::(), optional : True),
                        constant : (type : \Expression::(),),
                    ) %+ type_specialization_attrs_template,))
                    and_then type_specialization_attrs_constraint;

                when_regular_type_definer ::=
                    traits is_a (\$Signature::Tuple_Attrs_Match : (attrs : (
                        is_type_definer : (type : \True::(),),
                        is_generalization : (type : \False::(), optional : True),
                        evaluates : (type : {\Expression::(), \Signature::()},),
                        default : (type : \Expression::(), optional : True),
                    ) %+ type_specialization_attrs_template,))
                    and_then type_specialization_attrs_constraint;

                type_specialization_attrs_template ::=
                    (
                        composes : (type : \Set_of_Identity_Identifier::(), optional : True),
                        provides_default_for : (type : \Set_of_Identity_Identifier::(), optional : True),
                    );

                type_specialization_attrs_constraint ::=
                    if traits.?\provides_default_for then
                        traits.?\composes
                        and_then guard traits:.\provides_default_for ⊆ traits:.\composes
                    else
                        True;

                when_regular_function ::=
                    traits is_a (\$Signature::Tuple_Attrs_Match : (attrs : (
                        is_type_definer : (type : \False::(), optional : True),
                        virtual : (type : \Boolean::(), optional : True),
                        commutes : (type : \Identity_Identifier::(), optional : True),
                        negates : (type : \Identity_Identifier::(), optional : True),
                        returns : (type : \Signature::(), optional : True),
                        matches : (type : \Signature::Tuple_Attrs_Match_Simple(), optional : True),
                        implements : (type : ..., optional : True),
                        overrides : (type : ..., optional : True),
                        accepts : (type : \Expression::(), optional : True),
                        intends : (type : \Expression::(), optional : True),
                        is_associative : (type : \Boolean::(), optional : True),  `two-way associative`
                        is_commutative : (type : \Boolean::(), optional : True),
                        is_idempotent : (type : \Boolean::(), optional : True),
                        identity : (type : \Expression::(), optional : True),  `iff two-sided identity element exists`
                        left_identity : (type : \Expression::(), optional : True),  `iff only left-identity element exists`
                        right_identity : (type : \Expression::(), optional : True),  `iff only right-identity element exists`
                        repeater : (type : ..., optional : True),
                        evaluates : (type : \Expression::(), optional : True),
                    ),));
            ),
            default : ...,
        )),

        Procedure : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \Procedure,
                attrs : (\$Signature::Tuple_Attrs_Match : (attrs : (
                    virtual : (type : \Boolean::(), optional : True),
                    matches : (type : \Signature::Tuple_Attrs_Match_Simple(), optional : True),
                    implements : (type : ..., optional : True),
                    overrides : (type : ..., optional : True),
                    accepts : (type : \Expression::(), optional : True),
                    intends : (type : \Expression::(), optional : True),
                    performs : (type : \Statement::(), optional : True),
                ),)),
            )),
            default : ...,
        )),

        Signature::'' : (\Function : (
            is_type_definer : True,
            evaluates : {
                \$Function_Call_But_0,
                \$Signature::Conjunction,
                \$Signature::Disjunction,
                \$Signature::Tuple_Attrs_Match_Simple,
                \$Signature::Tuple_Attrs_Match,
                \$Signature::Article_Match,
            },
            default : \Any::(),
        )),

        Signature::Conjunction : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(), \all::( 1: \Signature::() )],
        )),

        Signature::Disjunction : (\Function : (
            is_type_definer : True,
            evaluates : [\Set::(), \all::( 1: \Signature::() )],
        )),

        Signature::Tuple_Attrs_Match_Simple : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \all_attr_assets::( 1: \Signature::() )],
        )),

        Signature::Tuple_Attrs_Match : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    attrs : [
                        \Tuple::(),
                        \all_attr_assets::( 1: \(
                            attr_sig ::= args:.\0;
                            returns
                                attr_sig ⊆$ \$(type,optional)
                                and
                                (attr_sig.?\type and_then guard Signature attr_sig.\type)
                                and
                                if attr_sig.?\optional
                                    then guard Boolean attr_sig.\optional
                                    else True
                            ;
                        ) )
                    ],
                ),
            )),
        )),

        Signature::Article_Match : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \Any::(),
                attrs : \Signature::(),
            )),
        )),

        Expression : (\Function : (
            is_type_definer : True,
            evaluates : {
                \$Literal,
                \$Args,
                \$Evaluates,
                \$Array_Selector,
                \$Set_Selector,
                \$Bag_Selector,
                \$Tuple_Selector,
                \$Article_Selector,
                \$If_Then_Else_Expr,
                \$And_Then,
                \$Or_Else,
                \$Given_When_Default_Expr,
                \$Guard,
                \$Factorization,
                \$Expansion,
                \$Vars,
                \$New,
                \$Current,
            },
            default : (\$Literal : (False,)),
        )),

        Literal : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Any::(),
                ),
            )),
            default : (\$material : (False,)),
        )),

        Args : (\Function : (
            is_type_definer : True,
            constant : \$material,
        )),

        Evaluates : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                ),
            )),
            default : (\$material : ...),
        )),

        Array_Selector : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : [\Array::(), \all::( 1: (
                        0 : \Expression::(),  `member value`
                        1 : \Expression::(),  `multiplicity`
                    ) )],
                ),
            )),
            default : (\$material : ([],)),
        )),

        Set_Selector : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : [\Bag::(), \all::( 1: (
                        0 : \Expression::(),  `member value`
                        1 : \Expression::(),  `multiplicity`
                    ) )],
                ),
            )),
            default : (\$material : ({0:0},)),
        )),

        Bag_Selector : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : [\Bag::(), \all::( 1: (
                        0 : \Expression::(),  `member value`
                        1 : \Expression::(),  `multiplicity`
                    ) )],
                ),
            )),
            default : (\$material : ({0:0},)),
        )),

        Tuple_Selector : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : [\Tuple::(), \all_attr_assets::( 1: \Expression::() )],
                ),
            )),
            default : (\$material : (())),
        )),

        Article_Selector : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),  `label`
                    1 : \Expression::(),  `attributes`
                ),
            )),
            default : (\$material : ((\$folder::Literal : (\'',)),
                (\$folder::Literal : ()))),
        )),

        If_Then_Else_Expr : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                    1 : \Expression::(),
                    2 : \Expression::(),
                ),
            )),
            default : (\$material : ((\$Literal : (False,)),
                (\$Literal : (False,)), (\$Literal : (False,)))),
        )),

        And_Then : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                    1 : \Expression::(),
                ),
            )),
            default : (\$material : ((\$Literal : (False,)),
                (\$Literal : (False,)))),
        )),

        Or_Else : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                    1 : \Expression::(),
                ),
            )),
            default : (\$material : ((\$Literal : (False,)),
                (\$Literal : (False,)))),
        )),

        Given_When_Default_Expr : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                    1 : [\Set::(), \all::( 1: (
                        0 : \Expression::(),
                        1 : \Expression::(),
                    ) )],
                    2 : \Expression::(),
                ),
            )),
            default : (\$material : ((\$Literal : (False,)),
                {}, (\$Literal : (False,)))),
        )),

        Guard : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                ),
            )),
            default : (\$material : ((\$Literal : (False,)),)),
        )),

        Factorization : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    factors : [\Tuple::(), \all_attr_assets::( 1: \Expression::() )],
                    returns : \Expression::(),
                ),
            )),
            default : (\$material : (factors : (), returns : (\$Literal : (False,)))),
        )),

        Expansion : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    factor : \Attr_Name::(),
                ),
            )),
            default : (\$material : (factor : \'',)),
        )),

        Vars : (\Function : (
            is_type_definer : True,
            constant : \$material,
        )),

        New : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                )
            )),
            default : (\$material : ((\$Literal : (False,)),)),
        )),

        Current : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                ),
            )),
            default : (\$material : ((\$New : ((\$Literal : (False,)),)),)),
        )),

        Statement : (\Function : (
            is_type_definer : True,
            evaluates : {
                \$Declare,
                \$Performs,
                \$If_Then_Else_Stmt,
                \$Given_When_Default_Stmt,
                \$Block,
                \$Leave,
                \$Iterate,
            },
            default : (\$Block : ([],)),
        )),

        Declare : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    vars : [\Tuple::(), \all_attr_assets::( 1: \Expression::() )],
                ),
            )),
            default : (\$material : (vars : (),)),
        )),

        Performs : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                ),
            )),
            default : (\$material : ...),
        )),

        If_Then_Else_Stmt : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                    1 : \Statement::(),
                    2 : \Statement::(),
                ),
            )),
            default : (\$material : ((\$Literal : (False,)),
                (\$Block : ([],)), (\$Block : ([],)))),
        )),

        Given_When_Default_Stmt : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    0 : \Expression::(),
                    1 : [\Set::(), \all::( 1: (
                        0 : \Expression::(),
                        1 : \Statement::(),
                    ) )],
                    2 : \Statement::(),
                ),
            )),
            default : (\$material : ((\$Literal : (False,)),
                {}, (\$Block : ([],)))),
        )),

        Block : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (\$Signature::Tuple_Attrs_Match : (attrs : (
                    0 : (type : [\Array::(), \all::( 1: \Statement::() )]),
                    label : (type : \Attr_Name::(), optional : True),
                ),)),
            )),
            default : (\$material : ([],)),
        )),

        Leave : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (\$Signature::Tuple_Attrs_Match : (attrs : (
                    label : (type : \Attr_Name::(), optional : True),
                ),)),
            )),
            default : (\$material : ()),
        )),

        Iterate : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (\$Signature::Tuple_Attrs_Match : (attrs : (
                    label : (type : \Attr_Name::(), optional : True),
                ),)),
            )),
            default : (\$material : ()),
        )),

        Heading : (\Function : (
            is_type_definer : True,
            evaluates : [\Tuple::(), \all_attr_assets::( 1: \True::() )],
        )),

        Attr_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Heading::(), \is_unary::()],
        )),

        Nesting : (\Function : (
            is_type_definer : True,
            evaluates : [\Array::(), \all::( 1: \Attr_Name::() )],
        )),

        Local_Name : (\Function : (
            is_type_definer : True,
            evaluates : [\Nesting::(), \so::(), \(
                given args:.\0.0
                    when \foundation then #args:.\0 = 2
                    when \used       then #args:.\0 ≥ 2  `elem 2 is pkg local alias`
                    when \package    then #args:.\0 ≥ 1
                    when \folder     then #args:.\0 ≥ 1
                    when \material   then #args:.\0 = 1
                    when \floating   then #args:.\0 ≥ 2
                    default False
            )],
            default : [\foundation, ...],
        )),

        Absolute_Name : (\Function : (
            is_type_definer : True,
            evaluates : (Local_Name args:.\0 and_then guard
                args:.\0.0 ⊆$ \$(foundation,used,package)),
        )),

        Routine_Call : (\Function : (
            is_type_definer : True,
            evaluates : (\$Signature::Article_Match : (
                label : \$material,
                attrs : (
                    call : {\Local_Name::(), \Identity_Identifier::(), \Function::(), \Procedure::()},
                    args : \Tuple::(),
                ),
            )),
            default : \foundation::False(),
        )),

        Function_Call : (\Function : (
            is_type_definer : True,
            evaluates : [
                \Routine_Call::(),
                \(args:.\0:>.\asset:.\call is_a {\Local_Name::(), \Identity_Identifier::(), \Function::()}),
            ],
            default : \(False),
        )),

        Function_Call_But_0 : (\Function : (
            is_type_definer : True,
            evaluates : (Function_Call args:.\0 and_then guard
                args:.\0.\args disjoint_heading \0),
        )),

        Function_Call_But_0_1 : (\Function : (
            is_type_definer : True,
            evaluates : (Function_Call args:.\0 and_then guard
                args:.\0.\args disjoint_heading \$(0..1)),
        )),

        Procedure_Call : (\Function : (
            is_type_definer : True,
            evaluates : [
                \Routine_Call::(),
                \(args:.\0:>.\asset:.\call is_a {\Local_Name::(), \Identity_Identifier::(), \Procedure::()}),
            ],
            default : \[],
        )),

        Key_Asset_Pair : (\Function : (
            is_type_definer : True,
            evaluates : (Tuple args:.\0 and_then guard
                $args:.\0 = \$(key,asset)),
        )),

        with_args : (\Function : (
            returns : \$Routine_Call,
            matches : (\$Routine_Call, \$Tuple),
            evaluates : (\$Routine_Call : (
                call : args:.\0:>.\call,
                args : args:.\0:>.\args %+ args:.\1,
            )),
        )),

        '<--' : (\Alias : ( of : \$with_args, )),

        priming : (\Function : (
            commutes : \$assuming,
        )),

        '-->' : (\Alias : ( of : \$priming, )),

        Signature_to_Function_Call_But_0 : (\Function : (
            returns : \$Function_Call_But_0,
            matches : (\$Signature,),
            evaluates : (
                sig ::= args:.\0;
                returns
                    if Function_Call_But_0 sig then
                        sig
                    else if Signature::Conjunction sig then guard
                        \(
                            topic    ::= args:.\0;
                            conj_sig ::= args:.\sig;
                            returns empty::(conj_sig)
                                or_else guard topic is_a first::(conj_sig)
                                and_then guard topic is_a nonfirst::(conj_sig)
                        ) <-- (:sig,)
                    else if Signature::Disjunction sig then guard
                        \(
                            topic    ::= args:.\0;
                            disj_sig ::= args:.\sig;
                            returns disj_sig any \(args:.\topic is_a args:.\0) <-- (:topic,)
                        ) <-- (:sig,)
                    else if Signature::Tuple_Attrs_Match_Simple sig then guard
                        \(
                            topic     ::= args:.\0;
                            tuple_sig ::= args:.\sig;
                            returns Tuple topic
                                and_then guard topic =$ tuple_sig
                                and_then guard
                                    tuple_sig all_attrs \(
                                        name     ::= args:.\0:.\name;
                                        attr_sig ::= args:.\0:.\asset;
                                        topic    ::= args:.\topic;
                                        returns topic.name is_a attr_sig;
                                    ) <-- (:topic,)
                        ) <-- (:sig,)
                    else if Signature::Tuple_Attrs_Match sig then guard
                        \(
                            topic     ::= args:.\0;
                            tuple_sig ::= args:.\sig;
                            attrs_sig ::= tuple_sig:>.\attrs;
                            returns Tuple topic
                                and_then guard
                                    topic ⊆$ attrs_sig
                                    and
                                    (attrs_sig all_attrs \(
                                        name     ::= args:.\0:.\name;
                                        attr_sig ::= args:.\0:.\asset;
                                        topic    ::= args:.\topic;
                                        returns if topic.?name
                                            then guard topic.name is_a attr_sig
                                            else attr_sig.?\optional
                                        ;
                                    ) <-- (:topic,))
                        ) <-- (:sig,)
                    else if Signature::Article_Match sig then guard
                        \(
                            topic       ::= args:.\0;
                            article_sig ::= args:.\sig:>;
                            returns Article topic
                                and_then guard topic:< = article_sig:.\label
                                and_then guard topic:> is_a article_sig:.\attrs
                        ) <-- (:sig,)
                    else
                        fail  `We should never get here.`
                    ;
            ),
        )),

`#########################################################################`

        Annotation::'' : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

`#########################################################################`

        Decoration::'' : (\Function : (
            is_type_definer : True,
            is_generalization : True,
        )),

`#########################################################################`

    ),
))

`#########################################################################`
`#########################################################################`
